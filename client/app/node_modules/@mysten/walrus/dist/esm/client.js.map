{
  "version": 3,
  "sources": ["../../src/client.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { InferBcsType } from '@mysten/bcs';\nimport { bcs } from '@mysten/bcs';\nimport { SuiClient } from '@mysten/sui/client';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport type { ClientCache, ClientWithExtensions } from '@mysten/sui/experimental';\nimport type { TransactionObjectArgument, TransactionResult } from '@mysten/sui/transactions';\nimport { coinWithBalance, Transaction } from '@mysten/sui/transactions';\nimport { normalizeStructTag, parseStructTag } from '@mysten/sui/utils';\n\nimport {\n\tMAINNET_WALRUS_PACKAGE_CONFIG,\n\tstatusLifecycleRank,\n\tTESTNET_WALRUS_PACKAGE_CONFIG,\n} from './constants.js';\nimport {\n\taddMetadata,\n\tBlob,\n\tinsertOrUpdateMetadataPair,\n\tremoveMetadataPair,\n} from './contracts/walrus/blob.js';\nimport type { Committee } from './contracts/walrus/committee.js';\nimport * as metadata from './contracts/walrus/metadata.js';\nimport { StakingInnerV1 } from './contracts/walrus/staking_inner.js';\nimport { StakingPool } from './contracts/walrus/staking_pool.js';\nimport { Staking } from './contracts/walrus/staking.js';\nimport { Storage } from './contracts/walrus/storage_resource.js';\nimport { SystemStateInnerV1 } from './contracts/walrus/system_state_inner.js';\nimport {\n\tcertifyBlob,\n\tdeleteBlob,\n\textendBlob,\n\tregisterBlob,\n\treserveSpace,\n\tSystem,\n} from './contracts/walrus/system.js';\nimport {\n\tBehindCurrentEpochError,\n\tBlobBlockedError,\n\tBlobNotCertifiedError,\n\tInconsistentBlobError,\n\tNoBlobMetadataReceivedError,\n\tNoBlobStatusReceivedError,\n\tNotEnoughBlobConfirmationsError,\n\tNotEnoughSliversReceivedError,\n\tNoVerifiedBlobStatusReceivedError,\n\tRetryableWalrusClientError,\n\tWalrusClientError,\n} from './error.js';\nimport { StorageNodeClient } from './storage-node/client.js';\nimport {\n\tBlobNotRegisteredError,\n\tLegallyUnavailableError,\n\tNotFoundError,\n\tUserAbortError,\n} from './storage-node/error.js';\nimport type { BlobMetadataWithId, BlobStatus, GetSliverResponse } from './storage-node/types.js';\nimport type {\n\tCertifyBlobOptions,\n\tCommitteeInfo,\n\tComputeBlobMetadataOptions,\n\tDeleteBlobOptions,\n\tEncodingType,\n\tExtendBlobOptions,\n\tUploadRelayConfig,\n\tGetBlobMetadataOptions,\n\tGetCertificationEpochOptions,\n\tGetSecondarySliverOptions,\n\tGetSliversOptions,\n\tGetStorageConfirmationOptions,\n\tGetVerifiedBlobStatusOptions,\n\tProtocolMessageCertificate,\n\tReadBlobOptions,\n\tRegisterBlobOptions,\n\tSliversForNode,\n\tStorageNode,\n\tStorageWithSizeOptions,\n\tWalrusClientConfig,\n\tWalrusClientExtensionOptions,\n\tWalrusPackageConfig,\n\tWriteBlobAttributesOptions,\n\tWriteBlobOptions,\n\tWriteBlobToUploadRelayOptions,\n\tWriteEncodedBlobOptions,\n\tWriteEncodedBlobToNodesOptions,\n\tWriteMetadataOptions,\n\tWriteQuiltOptions,\n\tWriteSliverOptions,\n\tWriteSliversToNodeOptions,\n\tWriteFilesOptions,\n\tWriteFilesFlowOptions,\n\tWriteFilesFlow,\n\tWriteFilesFlowRegisterOptions,\n\tWriteFilesFlowUploadOptions,\n\tWriteBlobFlow,\n\tWriteBlobFlowOptions,\n\tWriteBlobFlowRegisterOptions,\n\tWriteBlobFlowUploadOptions,\n} from './types.js';\nimport { blobIdToInt, IntentType, SliverData, StorageConfirmation } from './utils/bcs.js';\nimport {\n\tencodedBlobLength,\n\tgetShardIndicesByNodeId,\n\tgetSourceSymbols,\n\tisAboveValidity,\n\tisQuorum,\n\tsignersToBitmap,\n\tsliverPairIndexFromSecondarySliverIndex,\n\tstorageUnitsFromSize,\n\ttoPairIndex,\n\ttoShardIndex,\n\ttoTypeString,\n} from './utils/index.js';\nimport { SuiObjectDataLoader } from './utils/object-loader.js';\nimport { shuffle, weightedShuffle } from './utils/randomness.js';\nimport { getWasmBindings } from './wasm.js';\nimport { chunk } from '@mysten/utils';\nimport { UploadRelayClient } from './upload-relay/client.js';\nimport { encodeQuilt, encodeQuiltPatchId, parseWalrusId } from './utils/quilts.js';\nimport { BlobReader } from './files/readers/blob.js';\nimport { WalrusBlob } from './files/blob.js';\nimport { WalrusFile } from './files/file.js';\nimport { QuiltFileReader } from './files/readers/quilt-file.js';\nimport { QuiltReader } from './files/readers/quilt.js';\nimport { retry } from './utils/retry.js';\n\nexport class WalrusClient {\n\t#storageNodeClient: StorageNodeClient;\n\t#wasmUrl: string | undefined;\n\n\t#packageConfig: WalrusPackageConfig;\n\t#suiClient: ClientWithExtensions<{\n\t\tjsonRpc: SuiClient;\n\t}>;\n\t#objectLoader: SuiObjectDataLoader;\n\n\t#blobMetadataConcurrencyLimit = 10;\n\t#readCommittee?: CommitteeInfo | Promise<CommitteeInfo> | null;\n\n\t#cache: ClientCache;\n\n\t#uploadRelayConfig: UploadRelayConfig | null = null;\n\t#uploadRelayClient: UploadRelayClient | null = null;\n\n\tconstructor(config: WalrusClientConfig) {\n\t\tif (config.network && !config.packageConfig) {\n\t\t\tconst network = config.network;\n\t\t\tswitch (network) {\n\t\t\t\tcase 'testnet':\n\t\t\t\t\tthis.#packageConfig = TESTNET_WALRUS_PACKAGE_CONFIG;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mainnet':\n\t\t\t\t\tthis.#packageConfig = MAINNET_WALRUS_PACKAGE_CONFIG;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new WalrusClientError(`Unsupported network: ${network}`);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.#packageConfig = config.packageConfig!;\n\t\t}\n\n\t\tthis.#wasmUrl = config.wasmUrl;\n\t\tthis.#uploadRelayConfig = config.uploadRelay ?? null;\n\t\tif (this.#uploadRelayConfig) {\n\t\t\tthis.#uploadRelayClient = new UploadRelayClient(this.#uploadRelayConfig);\n\t\t}\n\n\t\tthis.#suiClient =\n\t\t\tconfig.suiClient ??\n\t\t\tnew SuiClient({\n\t\t\t\turl: config.suiRpcUrl,\n\t\t\t});\n\n\t\tthis.#storageNodeClient = new StorageNodeClient(config.storageNodeClientOptions);\n\t\tthis.#objectLoader = new SuiObjectDataLoader(this.#suiClient);\n\t\tthis.#cache = this.#suiClient.cache.scope('@mysten/walrus');\n\t}\n\n\tstatic experimental_asClientExtension({\n\t\tpackageConfig,\n\t\tnetwork,\n\t\t...options\n\t}: WalrusClientExtensionOptions = {}) {\n\t\treturn {\n\t\t\tname: 'walrus' as const,\n\t\t\tregister: (\n\t\t\t\tclient: ClientWithExtensions<{\n\t\t\t\t\tjsonRpc: SuiClient;\n\t\t\t\t}>,\n\t\t\t) => {\n\t\t\t\tconst walrusNetwork = network || client.network;\n\n\t\t\t\tif (walrusNetwork !== 'mainnet' && walrusNetwork !== 'testnet') {\n\t\t\t\t\tthrow new WalrusClientError('Walrus client only supports mainnet and testnet');\n\t\t\t\t}\n\n\t\t\t\treturn new WalrusClient(\n\t\t\t\t\tpackageConfig\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tpackageConfig,\n\t\t\t\t\t\t\t\tsuiClient: client,\n\t\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tnetwork: walrusNetwork as 'mainnet' | 'testnet',\n\t\t\t\t\t\t\t\tsuiClient: client,\n\t\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t}\n\t/** The Move type for a WAL coin */\n\t#walType() {\n\t\treturn this.#cache.read(['walType'], async () => {\n\t\t\tconst stakedWal = await this.#suiClient.jsonRpc.getNormalizedMoveStruct({\n\t\t\t\tpackage: await this.#getPackageId(),\n\t\t\t\tmodule: 'staked_wal',\n\t\t\t\tstruct: 'StakedWal',\n\t\t\t});\n\n\t\t\tconst balanceType = stakedWal.fields.find((field) => field.name === 'principal')?.type;\n\n\t\t\tif (!balanceType) {\n\t\t\t\tthrow new WalrusClientError('WAL type not found');\n\t\t\t}\n\n\t\t\tconst parsed = parseStructTag(toTypeString(balanceType));\n\t\t\tconst coinType = parsed.typeParams[0];\n\n\t\t\tif (!coinType) {\n\t\t\t\tthrow new WalrusClientError('WAL type not found');\n\t\t\t}\n\n\t\t\treturn normalizeStructTag(coinType);\n\t\t});\n\t}\n\n\t#getPackageId() {\n\t\treturn this.#cache.read(['getPackageId'], async () => {\n\t\t\tconst system = await this.#objectLoader.load(this.#packageConfig.systemObjectId);\n\t\t\treturn parseStructTag(system.type!).address;\n\t\t});\n\t}\n\n\t/** The Move type for a Blob object */\n\tgetBlobType() {\n\t\treturn this.#cache.read(['getBlobType'], async () => {\n\t\t\treturn `${await this.#getPackageId()}::blob::Blob`;\n\t\t});\n\t}\n\n\t#getWalrusPackageId() {\n\t\treturn this.#cache.read(['getSystemPackageId'], async () => {\n\t\t\tconst { package_id } = await this.systemObject();\n\t\t\treturn package_id;\n\t\t});\n\t}\n\n\t#wasmBindings() {\n\t\treturn this.#cache.read(['wasmBindings'], async () => {\n\t\t\treturn getWasmBindings(this.#wasmUrl);\n\t\t});\n\t}\n\n\t/** The cached system object for the walrus package */\n\tsystemObject() {\n\t\treturn this.#objectLoader.load(this.#packageConfig.systemObjectId, System);\n\t}\n\n\t/** The cached staking pool object for the walrus package */\n\tstakingObject() {\n\t\treturn this.#objectLoader.load(this.#packageConfig.stakingPoolId, Staking);\n\t}\n\n\t/** The system state for the current version of walrus contract  */\n\tasync systemState() {\n\t\tconst systemState = await this.#objectLoader.loadFieldObject(\n\t\t\tthis.#packageConfig.systemObjectId,\n\t\t\t{ type: 'u64', value: (await this.systemObject()).version },\n\t\t\tSystemStateInnerV1,\n\t\t);\n\n\t\treturn systemState;\n\t}\n\n\t/** The staking state for the current version of walrus contract */\n\tasync stakingState() {\n\t\treturn this.#objectLoader.loadFieldObject(\n\t\t\tthis.#packageConfig.stakingPoolId,\n\t\t\t{\n\t\t\t\ttype: 'u64',\n\t\t\t\tvalue: (await this.stakingObject()).version,\n\t\t\t},\n\t\t\tStakingInnerV1,\n\t\t);\n\t}\n\n\t/** Read a blob from the storage nodes */\n\treadBlob = this.#retryOnPossibleEpochChange(this.#internalReadBlob);\n\n\tasync #internalReadBlob({ blobId, signal }: ReadBlobOptions) {\n\t\tconst systemState = await this.systemState();\n\t\tconst numShards = systemState.committee.n_shards;\n\n\t\tconst blobMetadata = await this.getBlobMetadata({ blobId, signal });\n\n\t\tconst slivers = await this.getSlivers({ blobId, signal });\n\n\t\tconst bindings = await this.#wasmBindings();\n\n\t\tconst blobBytes = bindings.decodePrimarySlivers(\n\t\t\tblobId,\n\t\t\tnumShards,\n\t\t\tblobMetadata.metadata.V1.unencoded_length,\n\t\t\tslivers,\n\t\t);\n\n\t\tconst reconstructedBlobMetadata = bindings.computeMetadata(\n\t\t\tsystemState.committee.n_shards,\n\t\t\tblobBytes,\n\t\t);\n\n\t\tif (reconstructedBlobMetadata.blobId !== blobId) {\n\t\t\tthrow new InconsistentBlobError('The specified blob was encoded incorrectly.');\n\t\t}\n\n\t\treturn blobBytes;\n\t}\n\n\tasync computeBlobMetadata({ bytes, numShards }: ComputeBlobMetadataOptions) {\n\t\tlet shardCount: number | undefined;\n\t\tif (typeof numShards === 'number') {\n\t\t\tshardCount = numShards;\n\t\t} else {\n\t\t\tconst systemState = await this.systemState();\n\t\t\tshardCount = systemState.committee.n_shards;\n\t\t}\n\n\t\tconst bindings = await this.#wasmBindings();\n\t\tconst { blobId, metadata, rootHash } = bindings.computeMetadata(shardCount, bytes);\n\t\tlet sha256Hash: Promise<Uint8Array> | undefined;\n\t\tconst nonce = crypto.getRandomValues(new Uint8Array(32));\n\n\t\treturn {\n\t\t\trootHash,\n\t\t\tblobId,\n\t\t\tmetadata: {\n\t\t\t\tencodingType: metadata.V1.encoding_type,\n\t\t\t\thashes: Array.from(metadata.V1.hashes).map((hashes) => ({\n\t\t\t\t\tprimaryHash: hashes.primary_hash,\n\t\t\t\t\tsecondaryHash: hashes.secondary_hash,\n\t\t\t\t})),\n\t\t\t\tunencodedLength: metadata.V1.unencoded_length,\n\t\t\t},\n\t\t\tnonce,\n\t\t\tblobDigest: () => {\n\t\t\t\tif (!sha256Hash) {\n\t\t\t\t\tsha256Hash = crypto.subtle\n\t\t\t\t\t\t.digest('SHA-256', bytes as BufferSource)\n\t\t\t\t\t\t.then((hash) => new Uint8Array(hash));\n\t\t\t\t}\n\n\t\t\t\treturn sha256Hash;\n\t\t\t},\n\t\t};\n\t}\n\n\tasync getBlobMetadata({ blobId, signal }: GetBlobMetadataOptions) {\n\t\tconst committee = await this.#getReadCommittee({ blobId, signal });\n\t\tconst randomizedNodes = shuffle(committee.nodes);\n\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\n\t\tlet numNotFoundWeight = 0;\n\t\tlet numBlockedWeight = 0;\n\t\tlet totalErrorCount = 0;\n\t\tconst controller = new AbortController();\n\n\t\tconst metadataExecutors = randomizedNodes.map((node) => async () => {\n\t\t\ttry {\n\t\t\t\treturn await this.#storageNodeClient.getBlobMetadata(\n\t\t\t\t\t{ blobId },\n\t\t\t\t\t{\n\t\t\t\t\t\tnodeUrl: node.networkUrl,\n\t\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof NotFoundError) {\n\t\t\t\t\tnumNotFoundWeight += node.shardIndices.length;\n\t\t\t\t} else if (error instanceof LegallyUnavailableError) {\n\t\t\t\t\tnumBlockedWeight += node.shardIndices.length;\n\t\t\t\t}\n\n\t\t\t\ttotalErrorCount += 1;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t});\n\n\t\ttry {\n\t\t\tconst attemptGetMetadata = metadataExecutors.shift()!;\n\t\t\treturn await attemptGetMetadata();\n\t\t} catch (error) {\n\t\t\tconst chunkSize = Math.floor(metadataExecutors.length / this.#blobMetadataConcurrencyLimit);\n\t\t\tconst chunkedExecutors = chunk(metadataExecutors, chunkSize);\n\n\t\t\treturn await new Promise<BlobMetadataWithId>((resolve, reject) => {\n\t\t\t\tchunkedExecutors.forEach(async (executors) => {\n\t\t\t\t\tfor (const executor of executors) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst result = await executor();\n\t\t\t\t\t\t\tcontroller.abort('Blob metadata successfully retrieved.');\n\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tif (error instanceof UserAbortError) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t} else if (isQuorum(numBlockedWeight + numNotFoundWeight, numShards)) {\n\t\t\t\t\t\t\t\tconst abortError =\n\t\t\t\t\t\t\t\t\tnumNotFoundWeight > numBlockedWeight\n\t\t\t\t\t\t\t\t\t\t? new BlobNotCertifiedError(`The specified blob ${blobId} is not certified.`)\n\t\t\t\t\t\t\t\t\t\t: new BlobBlockedError(`The specified blob ${blobId} is blocked.`);\n\n\t\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (totalErrorCount === metadataExecutors.length) {\n\t\t\t\t\t\t\t\treject(\n\t\t\t\t\t\t\t\t\tnew NoBlobMetadataReceivedError(\n\t\t\t\t\t\t\t\t\t\t'No valid blob metadata could be retrieved from any storage node.',\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\tgetSecondarySliver = this.#retryOnPossibleEpochChange(this.internalGetSecondarySliver);\n\n\tasync internalGetSecondarySliver({ blobId, index, signal }: GetSecondarySliverOptions) {\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\t\tconst sliverPairIndex = sliverPairIndexFromSecondarySliverIndex(index, numShards);\n\t\tconst shardIndex = toShardIndex(sliverPairIndex, blobId, numShards);\n\t\tconst node = await this.#getNodeByShardIndex(committee, shardIndex);\n\n\t\tif (!node) {\n\t\t\tthrow new Error(`No node found for shard index ${shardIndex}`);\n\t\t}\n\n\t\tconst sliver = await this.#storageNodeClient.getSliver(\n\t\t\t{ blobId, sliverPairIndex, sliverType: 'secondary' },\n\t\t\t{\n\t\t\t\tnodeUrl: node.networkUrl,\n\t\t\t\tsignal,\n\t\t\t},\n\t\t);\n\n\t\treturn sliver;\n\t}\n\n\tasync getSlivers({ blobId, signal }: GetSliversOptions) {\n\t\tconst committee = await this.#getReadCommittee({ blobId, signal });\n\t\tconst randomizedNodes = weightedShuffle(\n\t\t\tcommittee.nodes.map((node) => ({\n\t\t\t\tvalue: node,\n\t\t\t\tweight: node.shardIndices.length,\n\t\t\t})),\n\t\t);\n\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\t\tconst { primarySymbols: minSymbols } = getSourceSymbols(numShards);\n\n\t\tconst sliverPairIndices = randomizedNodes.flatMap((node) =>\n\t\t\tnode.shardIndices.map((shardIndex) => ({\n\t\t\t\turl: node.networkUrl,\n\t\t\t\tsliverPairIndex: toPairIndex(shardIndex, blobId, numShards),\n\t\t\t})),\n\t\t);\n\n\t\tconst controller = new AbortController();\n\t\tconst chunkedSliverPairIndices = chunk(sliverPairIndices, minSymbols);\n\t\tconst slivers: GetSliverResponse[] = [];\n\t\tconst failedNodes = new Set<string>();\n\t\tlet numNotFoundWeight = 0;\n\t\tlet numBlockedWeight = 0;\n\t\tlet totalErrorCount = 0;\n\n\t\treturn new Promise<GetSliverResponse[]>((resolve, reject) => {\n\t\t\tchunkedSliverPairIndices[0].forEach(async (_, colIndex) => {\n\t\t\t\tfor (let rowIndex = 0; rowIndex < chunkedSliverPairIndices.length; rowIndex += 1) {\n\t\t\t\t\tconst value = chunkedSliverPairIndices.at(rowIndex)?.at(colIndex);\n\t\t\t\t\tif (!value) break;\n\n\t\t\t\t\tconst { url, sliverPairIndex } = value;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (failedNodes.has(url)) {\n\t\t\t\t\t\t\tthrow new Error(`Skipping node at ${url} due to previous failure.`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst sliver = await this.#storageNodeClient.getSliver(\n\t\t\t\t\t\t\t{ blobId, sliverPairIndex, sliverType: 'primary' },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnodeUrl: url,\n\t\t\t\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (slivers.length === minSymbols) {\n\t\t\t\t\t\t\tcontroller.abort('Enough slivers successfully retrieved.');\n\t\t\t\t\t\t\tresolve(slivers);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tslivers.push(sliver);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (error instanceof NotFoundError) {\n\t\t\t\t\t\t\tnumNotFoundWeight += 1;\n\t\t\t\t\t\t} else if (error instanceof LegallyUnavailableError) {\n\t\t\t\t\t\t\tnumBlockedWeight += 1;\n\t\t\t\t\t\t} else if (error instanceof UserAbortError) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isQuorum(numBlockedWeight + numNotFoundWeight, numShards)) {\n\t\t\t\t\t\t\tconst abortError =\n\t\t\t\t\t\t\t\tnumNotFoundWeight > numBlockedWeight\n\t\t\t\t\t\t\t\t\t? new BlobNotCertifiedError(`The specified blob ${blobId} is not certified.`)\n\t\t\t\t\t\t\t\t\t: new BlobBlockedError(`The specified blob ${blobId} is blocked.`);\n\n\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfailedNodes.add(url);\n\t\t\t\t\t\ttotalErrorCount += 1;\n\n\t\t\t\t\t\tconst remainingTasks = sliverPairIndices.length - (slivers.length + totalErrorCount);\n\t\t\t\t\t\tconst tooManyFailures = slivers.length + remainingTasks < minSymbols;\n\n\t\t\t\t\t\tif (tooManyFailures) {\n\t\t\t\t\t\t\tconst abortError = new NotEnoughSliversReceivedError(\n\t\t\t\t\t\t\t\t`Unable to retrieve enough slivers to decode blob ${blobId}.`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Gets the blob status from multiple storage nodes and returns the latest status that can be verified.\n\t */\n\tasync getVerifiedBlobStatus({ blobId, signal }: GetVerifiedBlobStatusOptions) {\n\t\t// Read from the latest committee because, during epoch change, it is the committee\n\t\t// that will have the most up-to-date information on old and newly certified blobs:\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\t\tconst controller = new AbortController();\n\n\t\tconst statuses = await new Promise<{ status: BlobStatus; weight: number }[]>(\n\t\t\t(resolve, reject) => {\n\t\t\t\tconst results: { status: BlobStatus; weight: number }[] = [];\n\t\t\t\tlet successWeight = 0;\n\t\t\t\tlet numNotFoundWeight = 0;\n\t\t\t\tlet settledCount = 0;\n\n\t\t\t\tcommittee.nodes.forEach(async (node) => {\n\t\t\t\t\tconst weight = node.shardIndices.length;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst status = await this.#storageNodeClient.getBlobStatus(\n\t\t\t\t\t\t\t{ blobId },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnodeUrl: node.networkUrl,\n\t\t\t\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (isQuorum(successWeight, numShards)) {\n\t\t\t\t\t\t\tcontroller.abort('Quorum of blob statuses retrieved successfully.');\n\t\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsuccessWeight += weight;\n\t\t\t\t\t\t\tresults.push({ status, weight });\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (error instanceof NotFoundError) {\n\t\t\t\t\t\t\tnumNotFoundWeight += weight;\n\t\t\t\t\t\t} else if (error instanceof UserAbortError) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isQuorum(numNotFoundWeight, numShards)) {\n\t\t\t\t\t\t\tconst abortError = new BlobNotCertifiedError('The blob does not exist.');\n\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsettledCount += 1;\n\t\t\t\t\t\tif (settledCount === committee.nodes.length) {\n\t\t\t\t\t\t\treject(\n\t\t\t\t\t\t\t\tnew NoBlobStatusReceivedError(\n\t\t\t\t\t\t\t\t\t'Not enough statuses were retrieved to achieve quorum.',\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\n\t\tconst aggregatedStatuses = statuses.reduce((accumulator, value) => {\n\t\t\tconst { status, weight } = value;\n\t\t\tconst key = JSON.stringify(status);\n\n\t\t\tconst existing = accumulator.get(key);\n\t\t\tif (existing) {\n\t\t\t\texisting.totalWeight += weight;\n\t\t\t} else {\n\t\t\t\taccumulator.set(key, { status, totalWeight: weight });\n\t\t\t}\n\n\t\t\treturn accumulator;\n\t\t}, new Map<string, { status: BlobStatus; totalWeight: number }>());\n\n\t\tconst uniqueStatuses = [...aggregatedStatuses.values()];\n\t\tconst sortedStatuses = uniqueStatuses.toSorted(\n\t\t\t(a, b) => statusLifecycleRank[b.status.type] - statusLifecycleRank[a.status.type],\n\t\t);\n\n\t\tfor (const value of sortedStatuses) {\n\t\t\t// TODO: We can check the chain via the `event` field as a fallback here.\n\t\t\tif (isAboveValidity(value.totalWeight, numShards)) {\n\t\t\t\treturn value.status;\n\t\t\t}\n\t\t}\n\n\t\tthrow new NoVerifiedBlobStatusReceivedError(\n\t\t\t`The blob status could not be verified for blob ${blobId},`,\n\t\t);\n\t}\n\n\tasync #getCertificationEpoch({ blobId, signal }: GetCertificationEpochOptions) {\n\t\tconst stakingState = await this.stakingState();\n\t\tconst currentEpoch = stakingState.epoch;\n\n\t\tif (stakingState.epoch_state.$kind === 'EpochChangeSync') {\n\t\t\tconst status = await this.getVerifiedBlobStatus({ blobId, signal });\n\t\t\tif (status.type === 'nonexistent' || status.type === 'invalid') {\n\t\t\t\tthrow new BlobNotCertifiedError(`The specified blob ${blobId} is ${status.type}.`);\n\t\t\t}\n\n\t\t\tif (typeof status.initialCertifiedEpoch !== 'number') {\n\t\t\t\tthrow new BlobNotCertifiedError(`The specified blob ${blobId} is not certified.`);\n\t\t\t}\n\n\t\t\tif (status.initialCertifiedEpoch > currentEpoch) {\n\t\t\t\tthrow new BehindCurrentEpochError(\n\t\t\t\t\t`The client is at epoch ${currentEpoch} while the specified blob was certified at epoch ${status.initialCertifiedEpoch}.`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn status.initialCertifiedEpoch;\n\t\t}\n\n\t\treturn currentEpoch;\n\t}\n\n\t/**\n\t * Retrieves the node committee responsible for serving reads.\n\t *\n\t * During an epoch change, reads should be served by the previous committee if the blob was\n\t * certified in an earlier epoch. This ensures that we read from nodes with the most accurate\n\t * information as nodes from the current committee might still be receiving transferred shards\n\t * from the previous committee.\n\t */\n\tasync #getReadCommittee(options: ReadBlobOptions) {\n\t\tif (!this.#readCommittee) {\n\t\t\tthis.#readCommittee = this.#forceGetReadCommittee(options);\n\t\t}\n\t\treturn this.#readCommittee;\n\t}\n\n\tasync #forceGetReadCommittee({ blobId, signal }: ReadBlobOptions) {\n\t\tconst stakingState = await this.stakingState();\n\t\tconst isTransitioning = stakingState.epoch_state.$kind === 'EpochChangeSync';\n\t\tconst certificationEpoch = await this.#getCertificationEpoch({ blobId, signal });\n\n\t\tif (isTransitioning && certificationEpoch < stakingState.epoch) {\n\t\t\treturn await this.#getCommittee(stakingState.previous_committee);\n\t\t}\n\t\treturn await this.#getActiveCommittee();\n\t}\n\n\t/**\n\t * Calculate the cost of storing a blob for a given a size and number of epochs.\n\t */\n\tasync storageCost(size: number, epochs: number) {\n\t\tconst systemState = await this.systemState();\n\t\tconst encodedSize = encodedBlobLength(size, systemState.committee.n_shards);\n\t\tconst storageUnits = storageUnitsFromSize(encodedSize);\n\t\tconst storageCost =\n\t\t\tBigInt(storageUnits) * BigInt(systemState.storage_price_per_unit_size) * BigInt(epochs);\n\t\tBigInt(epochs);\n\n\t\tconst writeCost = BigInt(storageUnits) * BigInt(systemState.write_price_per_unit_size);\n\n\t\treturn { storageCost, writeCost, totalCost: storageCost + writeCost };\n\t}\n\n\t/**\n\t * A utility for creating a storage object in a transaction.\n\t *\n\t * @usage\n\t * ```ts\n\t * tx.transferObjects([client.createStorage({ size: 1000, epochs: 3 })], owner);\n\t * ```\n\t */\n\tcreateStorage({ size, epochs, walCoin }: StorageWithSizeOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst systemObject = await this.systemObject();\n\t\t\tconst systemState = await this.systemState();\n\t\t\tconst encodedSize = encodedBlobLength(size, systemState.committee.n_shards);\n\t\t\tconst [{ storageCost }, walrusPackageId] = await Promise.all([\n\t\t\t\tthis.storageCost(size, epochs),\n\t\t\t\tthis.#getWalrusPackageId(),\n\t\t\t]);\n\n\t\t\treturn tx.add(\n\t\t\t\tthis.#withWal(storageCost, walCoin ?? null, (coin, tx) => {\n\t\t\t\t\treturn tx.add(\n\t\t\t\t\t\treserveSpace({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: systemObject.id.id,\n\t\t\t\t\t\t\t\tstorageAmount: encodedSize,\n\t\t\t\t\t\t\t\tepochsAhead: epochs,\n\t\t\t\t\t\t\t\tpayment: coin,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t#withWal<T extends TransactionResult | void>(\n\t\tamount: bigint,\n\t\tsource: TransactionObjectArgument | null,\n\t\tfn: (coin: TransactionObjectArgument, tx: Transaction) => T | Promise<T>,\n\t) {\n\t\treturn async (tx: Transaction): Promise<T> => {\n\t\t\tconst walType = await this.#walType();\n\t\t\tconst coin = source\n\t\t\t\t? tx.splitCoins(source, [amount])[0]\n\t\t\t\t: tx.add(\n\t\t\t\t\t\tcoinWithBalance({\n\t\t\t\t\t\t\tbalance: amount,\n\t\t\t\t\t\t\ttype: walType,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\n\t\t\tconst result = await fn(coin, tx);\n\n\t\t\ttx.moveCall({\n\t\t\t\ttarget: '0x2::coin::destroy_zero',\n\t\t\t\ttypeArguments: [walType],\n\t\t\t\targuments: [coin],\n\t\t\t});\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that creates a storage object\n\t *\n\t * @usage\n\t * ```ts\n\t * const tx = client.createStorageTransaction({ size: 1000, epochs: 3, owner: signer.toSuiAddress() });\n\t * ```\n\t */\n\tcreateStorageTransaction({\n\t\ttransaction = new Transaction(),\n\t\tsize,\n\t\tepochs,\n\t\towner,\n\t}: StorageWithSizeOptions & {\n\t\ttransaction?: Transaction;\n\t\t/** Address the storage resource should be transferred to */\n\t\towner: string;\n\t}) {\n\t\ttransaction.transferObjects([this.createStorage({ size, epochs })], owner);\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that creates a storage object\n\t *\n\t * @usage\n\t * ```ts\n\t * const { digest, storage } = await client.executeCreateStorageTransaction({ size: 1000, epochs: 3, signer });\n\t * ```\n\t */\n\tasync executeCreateStorageTransaction({\n\t\tsigner,\n\t\t...options\n\t}: StorageWithSizeOptions & { transaction?: Transaction; signer: Signer }) {\n\t\tconst transaction = this.createStorageTransaction({\n\t\t\t...options,\n\t\t\towner: options.transaction?.getData().sender ?? signer.toSuiAddress(),\n\t\t});\n\t\tconst blobType = await this.getBlobType();\n\n\t\tconst { digest, effects } = await this.#executeTransaction(\n\t\t\ttransaction,\n\t\t\tsigner,\n\t\t\t'create storage',\n\t\t);\n\n\t\tconst createdObjectIds = effects?.changedObjects\n\t\t\t.filter((object) => object.idOperation === 'Created')\n\t\t\t.map((object) => object.id);\n\n\t\tconst createdObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: createdObjectIds,\n\t\t});\n\n\t\tconst suiBlobObject = createdObjects.objects.find(\n\t\t\t(object) => !(object instanceof Error) && object.type === blobType,\n\t\t);\n\n\t\tif (suiBlobObject instanceof Error || !suiBlobObject) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Storage object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tdigest,\n\t\t\tstorage: Storage.parse(await suiBlobObject.content),\n\t\t};\n\t}\n\n\t/**\n\t * Register a blob in a transaction\n\t *\n\t * @usage\n\t * ```ts\n\t * tx.transferObjects([client.registerBlob({ size: 1000, epochs: 3, blobId, rootHash, deletable: true })], owner);\n\t * ```\n\t */\n\tregisterBlob({\n\t\tsize,\n\t\tepochs,\n\t\tblobId,\n\t\trootHash,\n\t\tdeletable,\n\t\twalCoin,\n\t\tattributes,\n\t}: RegisterBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst { writeCost } = await this.storageCost(size, epochs);\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\treturn tx.add(\n\t\t\t\tthis.#withWal(writeCost, walCoin ?? null, async (writeCoin, tx) => {\n\t\t\t\t\tconst blob = tx.add(\n\t\t\t\t\t\tregisterBlob({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: tx.object(this.#packageConfig.systemObjectId),\n\t\t\t\t\t\t\t\tstorage: this.createStorage({ size, epochs, walCoin }),\n\t\t\t\t\t\t\t\tblobId: blobIdToInt(blobId),\n\t\t\t\t\t\t\t\trootHash: BigInt(bcs.u256().parse(rootHash)),\n\t\t\t\t\t\t\t\tsize,\n\t\t\t\t\t\t\t\tencodingType: 1,\n\t\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t\t\twritePayment: writeCoin,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\n\t\t\t\t\tif (attributes) {\n\t\t\t\t\t\ttx.add(\n\t\t\t\t\t\t\tthis.#writeBlobAttributesForRef({\n\t\t\t\t\t\t\t\tattributes,\n\t\t\t\t\t\t\t\texistingAttributes: null,\n\t\t\t\t\t\t\t\tblob,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn blob;\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\taddAuthPayload({\n\t\tsize,\n\t\tblobDigest,\n\t\tnonce,\n\t}: {\n\t\tsize: number;\n\t\tblobDigest: Uint8Array | (() => Promise<Uint8Array>);\n\t\tnonce: Uint8Array;\n\t}) {\n\t\treturn async (transaction: Transaction) => {\n\t\t\tconst nonceDigest = await crypto.subtle.digest('SHA-256', nonce as BufferSource);\n\t\t\tconst lengthBytes = bcs.u64().serialize(size).toBytes();\n\t\t\tconst digest = typeof blobDigest === 'function' ? await blobDigest() : blobDigest;\n\t\t\tconst authPayload = new Uint8Array(\n\t\t\t\tnonceDigest.byteLength + digest.byteLength + lengthBytes.byteLength,\n\t\t\t);\n\n\t\t\tauthPayload.set(digest, 0);\n\t\t\tauthPayload.set(new Uint8Array(nonceDigest), digest.byteLength);\n\t\t\tauthPayload.set(lengthBytes, nonceDigest.byteLength + digest.byteLength);\n\t\t\ttransaction.pure(authPayload);\n\t\t};\n\t}\n\n\t#loadTipConfig() {\n\t\treturn this.#cache.read(['upload-relay-tip-config'], async () => {\n\t\t\tif (!this.#uploadRelayConfig?.sendTip || !this.#uploadRelayClient) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ('kind' in this.#uploadRelayConfig.sendTip) {\n\t\t\t\treturn this.#uploadRelayConfig.sendTip;\n\t\t\t}\n\n\t\t\tconst tipConfig = await this.#uploadRelayClient.tipConfig();\n\n\t\t\tif (!tipConfig) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...tipConfig,\n\t\t\t\tmax: this.#uploadRelayConfig.sendTip.max,\n\t\t\t};\n\t\t});\n\t}\n\n\tasync calculateUploadRelayTip(options: { size: number }) {\n\t\tconst systemState = await this.systemState();\n\t\tconst encodedSize = encodedBlobLength(options.size, systemState.committee.n_shards);\n\t\tconst tipConfig = await this.#loadTipConfig();\n\n\t\tif (!tipConfig) {\n\t\t\treturn 0n;\n\t\t}\n\n\t\tconst { max, kind } = tipConfig;\n\n\t\tconst amount =\n\t\t\t'const' in kind\n\t\t\t\t? kind.const\n\t\t\t\t: BigInt(kind.linear.base) +\n\t\t\t\t\tBigInt(kind.linear.perEncodedKib) * ((BigInt(encodedSize) + 1023n) / 1024n); // Compute the ceiling of the division.\n\n\t\tif (max != null && amount > max) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Tip amount (${amount}) exceeds the maximum allowed tip (${max})`,\n\t\t\t);\n\t\t}\n\n\t\treturn amount;\n\t}\n\n\tsendUploadRelayTip({\n\t\tsize,\n\t\tblobDigest,\n\t\tnonce,\n\t}: {\n\t\tsize: number;\n\t\tblobDigest: Uint8Array | (() => Promise<Uint8Array>);\n\t\tnonce: Uint8Array;\n\t}) {\n\t\treturn async (transaction: Transaction) => {\n\t\t\tconst tipConfig = await this.#loadTipConfig();\n\n\t\t\tif (tipConfig) {\n\t\t\t\ttransaction.add(this.addAuthPayload({ size, blobDigest, nonce }));\n\t\t\t\tconst amount = await this.calculateUploadRelayTip({ size });\n\t\t\t\tconst { address } = tipConfig;\n\t\t\t\ttransaction.transferObjects(\n\t\t\t\t\t[\n\t\t\t\t\t\tcoinWithBalance({\n\t\t\t\t\t\t\tbalance: amount,\n\t\t\t\t\t\t}),\n\t\t\t\t\t],\n\t\t\t\t\taddress,\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that registers a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const tx = client.registerBlobTransaction({ size: 1000, epochs: 3, blobId, rootHash, deletable: true });\n\t * ```\n\t */\n\tregisterBlobTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: RegisterBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\t/** Address the blob should be transferred to */\n\t\towner: string;\n\t}) {\n\t\tconst registration = transaction.add(this.registerBlob(options));\n\n\t\ttransaction.transferObjects([registration], options.owner);\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that registers a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const { digest, blob } = await client.executeRegisterBlobTransaction({ size: 1000, epochs: 3, signer });\n\t * ```\n\t */\n\tasync executeRegisterBlobTransaction({\n\t\tsigner,\n\t\t...options\n\t}: RegisterBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\tsigner: Signer;\n\t\t/** Address the blob should be transferred to */\n\t\towner?: string;\n\t}): Promise<{\n\t\tblob: (typeof Blob)['$inferType'];\n\t\tdigest: string;\n\t}> {\n\t\tconst transaction = this.registerBlobTransaction({\n\t\t\t...options,\n\t\t\towner: options.owner ?? options.transaction?.getData().sender ?? signer.toSuiAddress(),\n\t\t});\n\t\tconst blobType = await this.getBlobType();\n\t\tconst { digest, effects } = await this.#executeTransaction(\n\t\t\ttransaction,\n\t\t\tsigner,\n\t\t\t'register blob',\n\t\t);\n\n\t\tconst createdObjectIds = effects?.changedObjects\n\t\t\t.filter((object) => object.idOperation === 'Created')\n\t\t\t.map((object) => object.id);\n\n\t\tconst createdObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: createdObjectIds,\n\t\t});\n\n\t\tconst suiBlobObject = createdObjects.objects.find(\n\t\t\t(object) => !(object instanceof Error) && object.type === blobType,\n\t\t);\n\n\t\tif (suiBlobObject instanceof Error || !suiBlobObject) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Blob object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tdigest,\n\t\t\tblob: Blob.parse(await suiBlobObject.content),\n\t\t};\n\t}\n\n\tasync #getCreatedBlob(digest: string) {\n\t\tconst blobType = await this.getBlobType();\n\t\tconst {\n\t\t\ttransaction: { effects },\n\t\t} = await this.#suiClient.core.waitForTransaction({\n\t\t\tdigest,\n\t\t});\n\n\t\tconst createdObjectIds = effects?.changedObjects\n\t\t\t.filter((object) => object.idOperation === 'Created')\n\t\t\t.map((object) => object.id);\n\n\t\tconst createdObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: createdObjectIds,\n\t\t});\n\n\t\tconst suiBlobObject = createdObjects.objects.find(\n\t\t\t(object) => !(object instanceof Error) && object.type === blobType,\n\t\t);\n\n\t\tif (suiBlobObject instanceof Error || !suiBlobObject) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Blob object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\treturn Blob.parse(await suiBlobObject.content);\n\t}\n\n\tasync certificateFromConfirmations({\n\t\tconfirmations,\n\t\tblobId,\n\t\tdeletable,\n\t\tblobObjectId,\n\t}: Extract<\n\t\tCertifyBlobOptions,\n\t\t{ confirmations: unknown[] }\n\t>): Promise<ProtocolMessageCertificate> {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tif (confirmations.length !== systemState.committee.members.length) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t'Invalid number of confirmations. Confirmations array must contain an entry for each node',\n\t\t\t);\n\t\t}\n\n\t\tconst confirmationMessage = StorageConfirmation.serialize({\n\t\t\tintent: IntentType.BLOB_CERT_MSG,\n\t\t\tepoch: systemState.committee.epoch,\n\t\t\tmessageContents: {\n\t\t\t\tblobId,\n\t\t\t\tblobType: deletable\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tDeletable: {\n\t\t\t\t\t\t\t\tobjectId: blobObjectId,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tPermanent: null,\n\t\t\t\t\t\t},\n\t\t\t},\n\t\t}).toBase64();\n\n\t\tconst bindings = await this.#wasmBindings();\n\t\tconst verifySignature = bindings.getVerifySignature();\n\n\t\tconst filteredConfirmations = confirmations\n\t\t\t.map((confirmation, index) => {\n\t\t\t\tconst isValid =\n\t\t\t\t\tconfirmation?.serializedMessage === confirmationMessage &&\n\t\t\t\t\tverifySignature(\n\t\t\t\t\t\tconfirmation,\n\t\t\t\t\t\tnew Uint8Array(committee.nodes[index].info.public_key.bytes),\n\t\t\t\t\t);\n\n\t\t\t\treturn isValid\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\t...confirmation,\n\t\t\t\t\t\t}\n\t\t\t\t\t: null;\n\t\t\t})\n\t\t\t.filter((confirmation) => confirmation !== null);\n\n\t\tif (!isQuorum(filteredConfirmations.length, systemState.committee.members.length)) {\n\t\t\tthrow new NotEnoughBlobConfirmationsError(\n\t\t\t\t`Too many invalid confirmations received for blob (${filteredConfirmations.length} of ${systemState.committee.members.length})`,\n\t\t\t);\n\t\t}\n\n\t\treturn bindings.combineSignatures(\n\t\t\tfilteredConfirmations,\n\t\t\tfilteredConfirmations.map(({ index }) => index),\n\t\t);\n\t}\n\n\t/**\n\t * Certify a blob in a transaction\n\t *\n\t * @usage\n\t * ```ts\n\t * tx.add(client.certifyBlob({ blobId, blobObjectId, confirmations }));\n\t * ```\n\t */\n\tcertifyBlob({ blobId, blobObjectId, confirmations, certificate, deletable }: CertifyBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst systemState = await this.systemState();\n\t\t\tconst combinedSignature =\n\t\t\t\tcertificate ??\n\t\t\t\t(await this.certificateFromConfirmations({\n\t\t\t\t\tconfirmations,\n\t\t\t\t\tblobId,\n\t\t\t\t\tdeletable,\n\t\t\t\t\tblobObjectId,\n\t\t\t\t}));\n\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\ttx.add(\n\t\t\t\tcertifyBlob({\n\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\targuments: {\n\t\t\t\t\t\tself: this.#packageConfig.systemObjectId,\n\t\t\t\t\t\tblob: blobObjectId,\n\t\t\t\t\t\tsignature: tx.pure.vector('u8', combinedSignature.signature),\n\t\t\t\t\t\tsignersBitmap: tx.pure.vector(\n\t\t\t\t\t\t\t'u8',\n\t\t\t\t\t\t\tsignersToBitmap(combinedSignature.signers, systemState.committee.members.length),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tmessage: tx.pure.vector('u8', combinedSignature.serializedMessage),\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that certifies a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const tx = client.certifyBlobTransaction({ blobId, blobObjectId, confirmations });\n\t * ```\n\t */\n\tcertifyBlobTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: CertifyBlobOptions & {\n\t\ttransaction?: Transaction;\n\t}) {\n\t\ttransaction.add(this.certifyBlob(options));\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that certifies a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const { digest } = await client.executeCertifyBlobTransaction({ blobId, blobObjectId, confirmations, signer });\n\t * ```\n\t */\n\tasync executeCertifyBlobTransaction({\n\t\tsigner,\n\t\t...options\n\t}: CertifyBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\tsigner: Signer;\n\t}) {\n\t\tconst transaction = this.certifyBlobTransaction(options);\n\n\t\tconst { digest } = await this.#executeTransaction(transaction, signer, 'certify blob');\n\n\t\treturn { digest };\n\t}\n\n\t/**\n\t * Delete a blob in a transaction\n\t *\n\t * @usage\n\t * ```ts\n\t * const storage = await client.deleteBlob({ blobObjectId });\n\t * tx.transferObjects([storage], owner);\n\t * ```\n\t */\n\tdeleteBlob({ blobObjectId }: DeleteBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\t\t\tconst storage = tx.add(\n\t\t\t\tdeleteBlob({\n\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\targuments: {\n\t\t\t\t\t\tself: this.#packageConfig.systemObjectId,\n\t\t\t\t\t\tblob: blobObjectId,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\treturn storage;\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that deletes a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const tx = client.deleteBlobTransaction({ blobObjectId, owner });\n\t * ```\n\t */\n\tdeleteBlobTransaction({\n\t\towner,\n\t\tblobObjectId,\n\t\ttransaction = new Transaction(),\n\t}: DeleteBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\t/** Address the storage resource should be returned to */\n\t\towner: string;\n\t}) {\n\t\tconst storage = transaction.add(this.deleteBlob({ blobObjectId }));\n\t\ttransaction.transferObjects([storage], owner);\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that deletes a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const { digest } = await client.executeDeleteBlobTransaction({ blobObjectId, signer });\n\t * ```\n\t */\n\tasync executeDeleteBlobTransaction({\n\t\tsigner,\n\t\ttransaction = new Transaction(),\n\t\tblobObjectId,\n\t}: DeleteBlobOptions & { signer: Signer; transaction?: Transaction }) {\n\t\tconst { digest } = await this.#executeTransaction(\n\t\t\tthis.deleteBlobTransaction({\n\t\t\t\tblobObjectId,\n\t\t\t\ttransaction,\n\t\t\t\towner: transaction.getData().sender ?? signer.toSuiAddress(),\n\t\t\t}),\n\t\t\tsigner,\n\t\t\t'delete blob',\n\t\t);\n\n\t\treturn { digest };\n\t}\n\n\t/**\n\t * Extend a blob in a transaction\n\t *\n\t * @usage\n\t * ```ts\n\t * const tx = client.extendBlobTransaction({ blobObjectId, epochs });\n\t * ```\n\t */\n\textendBlob({ blobObjectId, epochs, endEpoch, walCoin }: ExtendBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst blob = await this.#objectLoader.load(blobObjectId, Blob);\n\t\t\tconst numEpochs = typeof epochs === 'number' ? epochs : endEpoch - blob.storage.end_epoch;\n\n\t\t\tif (numEpochs <= 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { storageCost } = await this.storageCost(Number(blob.storage.storage_size), numEpochs);\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\treturn tx.add(\n\t\t\t\tthis.#withWal(storageCost, walCoin ?? null, async (coin, tx) => {\n\t\t\t\t\ttx.add(\n\t\t\t\t\t\textendBlob({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: this.#packageConfig.systemObjectId,\n\t\t\t\t\t\t\t\tblob: blobObjectId,\n\t\t\t\t\t\t\t\textendedEpochs: numEpochs,\n\t\t\t\t\t\t\t\tpayment: coin,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that extends a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const tx = client.extendBlobTransaction({ blobObjectId, epochs });\n\t * ```\n\t */\n\tasync extendBlobTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: ExtendBlobOptions & { transaction?: Transaction }) {\n\t\ttransaction.add(this.extendBlob(options));\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that extends a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const { digest } = await client.executeExtendBlobTransaction({ blobObjectId, signer });\n\t * ```\n\t */\n\tasync executeExtendBlobTransaction({\n\t\tsigner,\n\t\t...options\n\t}: ExtendBlobOptions & { signer: Signer; transaction?: Transaction }) {\n\t\tconst { digest } = await this.#executeTransaction(\n\t\t\tawait this.extendBlobTransaction(options),\n\t\t\tsigner,\n\t\t\t'extend blob',\n\t\t);\n\n\t\treturn { digest };\n\t}\n\n\tasync readBlobAttributes({\n\t\tblobObjectId,\n\t}: {\n\t\tblobObjectId: string;\n\t}): Promise<Record<string, string> | null> {\n\t\tconst response = await this.#suiClient.core.getDynamicField({\n\t\t\tparentId: blobObjectId,\n\t\t\tname: {\n\t\t\t\ttype: 'vector<u8>',\n\t\t\t\tbcs: bcs.string().serialize('metadata').toBytes(),\n\t\t\t},\n\t\t});\n\n\t\tconst parsedMetadata = metadata.Metadata.parse(response.dynamicField.value.bcs);\n\n\t\treturn Object.fromEntries(\n\t\t\tparsedMetadata.metadata.contents.map(({ key, value }) => [key, value]),\n\t\t);\n\t}\n\n\t#writeBlobAttributesForRef({\n\t\tattributes,\n\t\texistingAttributes,\n\t\tblob,\n\t}: {\n\t\tattributes: Record<string, string | null>;\n\t\texistingAttributes: Record<string, string> | null;\n\t\tblob: TransactionObjectArgument;\n\t}) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\tif (!existingAttributes) {\n\t\t\t\ttx.add(\n\t\t\t\t\taddMetadata({\n\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\tself: blob,\n\t\t\t\t\t\t\tmetadata: metadata._new({\n\t\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tObject.keys(attributes).forEach((key) => {\n\t\t\t\tconst value = attributes[key];\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\tif (existingAttributes && key in existingAttributes) {\n\t\t\t\t\t\ttx.add(\n\t\t\t\t\t\t\tremoveMetadataPair({\n\t\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\t\tself: blob,\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttx.add(\n\t\t\t\t\t\tinsertOrUpdateMetadataPair({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: blob,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t}\n\n\t/**\n\t * Write attributes to a blob\n\t *\n\t * If attributes already exists, their previous values will be overwritten\n\t * If an attribute is set to `null`, it will be removed from the blob\n\t *\n\t * @usage\n\t * ```ts\n\t * tx.add(client.writeBlobAttributes({ blobObjectId, attributes: { key: 'value', keyToRemove: null } }));\n\t * ```\n\t */\n\twriteBlobAttributes({ blobObject, blobObjectId, attributes }: WriteBlobAttributesOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst existingAttributes = blobObjectId\n\t\t\t\t? await this.readBlobAttributes({ blobObjectId })\n\t\t\t\t: null;\n\t\t\tconst blob = blobObject ?? tx.object(blobObjectId);\n\n\t\t\ttx.add(\n\t\t\t\tthis.#writeBlobAttributesForRef({\n\t\t\t\t\tattributes,\n\t\t\t\t\texistingAttributes,\n\t\t\t\t\tblob,\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that writes attributes to a blob\n\t *\n\t * If attributes already exists, their previous values will be overwritten\n\t * If an attribute is set to `null`, it will be removed from the blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const tx = client.writeBlobAttributesTransaction({ blobObjectId, attributes: { key: 'value', keyToRemove: null } });\n\t * ```\n\t */\n\tasync writeBlobAttributesTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: WriteBlobAttributesOptions & { transaction?: Transaction }) {\n\t\ttransaction.add(await this.writeBlobAttributes(options));\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that writes attributes to a blob\n\t *\n\t * If attributes already exists, their previous values will be overwritten\n\t * If an attribute is set to `null`, it will be removed from the blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const { digest } = await client.executeWriteBlobAttributesTransaction({ blobObjectId, signer });\n\t * ```\n\t */\n\tasync executeWriteBlobAttributesTransaction({\n\t\tsigner,\n\t\t...options\n\t}: WriteBlobAttributesOptions & { signer: Signer; transaction?: Transaction }) {\n\t\tconst { digest } = await this.#executeTransaction(\n\t\t\tawait this.writeBlobAttributesTransaction(options),\n\t\t\tsigner,\n\t\t\t'write blob attributes',\n\t\t);\n\t\treturn { digest };\n\t}\n\n\t/**\n\t * Write a sliver to a storage node\n\t *\n\t * @usage\n\t * ```ts\n\t * const res = await client.writeSliver({ blobId, sliverPairIndex, sliverType, sliver });\n\t * ```\n\t */\n\tasync writeSliver({ blobId, sliverPairIndex, sliverType, sliver, signal }: WriteSliverOptions) {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tconst shardIndex = toShardIndex(sliverPairIndex, blobId, systemState.committee.n_shards);\n\t\tconst node = await this.#getNodeByShardIndex(committee, shardIndex);\n\n\t\treturn this.#storageNodeClient.storeSliver(\n\t\t\t{ blobId, sliverPairIndex, sliverType, sliver },\n\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t);\n\t}\n\n\t/**\n\t * Write metadata to a storage node\n\t *\n\t * @usage\n\t * ```ts\n\t * const res = await client.writeMetadataToNode({ nodeIndex, blobId, metadata });\n\t * ```\n\t */\n\tasync writeMetadataToNode({ nodeIndex, blobId, metadata, signal }: WriteMetadataOptions) {\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst node = committee.nodes[nodeIndex];\n\n\t\treturn retry(\n\t\t\t() =>\n\t\t\t\tthis.#storageNodeClient.storeBlobMetadata(\n\t\t\t\t\t{ blobId, metadata },\n\t\t\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t\t\t),\n\t\t\t{\n\t\t\t\tcount: 3,\n\t\t\t\tdelay: 1000,\n\t\t\t\tcondition: (error) => error instanceof BlobNotRegisteredError,\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Get a storage confirmation from a storage node\n\t *\n\t * @usage\n\t * ```ts\n\t * const confirmation = await client.getStorageConfirmationFromNode({ nodeIndex, blobId, deletable, objectId });\n\t * ```\n\t */\n\tasync getStorageConfirmationFromNode({\n\t\tnodeIndex,\n\t\tblobId,\n\t\tdeletable,\n\t\tobjectId,\n\t\tsignal,\n\t}: GetStorageConfirmationOptions) {\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst node = committee.nodes[nodeIndex];\n\n\t\tconst result = deletable\n\t\t\t? await this.#storageNodeClient.getDeletableBlobConfirmation(\n\t\t\t\t\t{ blobId, objectId },\n\t\t\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t\t\t)\n\t\t\t: await this.#storageNodeClient.getPermanentBlobConfirmation(\n\t\t\t\t\t{ blobId },\n\t\t\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t\t\t);\n\n\t\treturn result?.success?.data?.signed ?? null;\n\t}\n\n\t/**\n\t * Encode a blob into slivers for each node\n\t *\n\t * @usage\n\t * ```ts\n\t * const { blobId, metadata, sliversByNode, rootHash } = await client.encodeBlob(blob);\n\t * ```\n\t */\n\tasync encodeBlob(blob: Uint8Array) {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tconst numShards = systemState.committee.n_shards;\n\t\tconst bindings = await this.#wasmBindings();\n\t\tconst { blobId, metadata, sliverPairs, rootHash } = bindings.encodeBlob(numShards, blob);\n\n\t\tconst sliversByNodeMap = new Map<number, SliversForNode>();\n\n\t\twhile (sliverPairs.length > 0) {\n\t\t\t// remove from list so we don't preserve references to the original data\n\t\t\tconst { primary, secondary } = sliverPairs.pop()!;\n\t\t\tconst sliverPairIndex = primary.index;\n\n\t\t\tconst shardIndex = toShardIndex(sliverPairIndex, blobId, numShards);\n\t\t\tconst node = await this.#getNodeByShardIndex(committee, shardIndex);\n\n\t\t\tif (!sliversByNodeMap.has(node.nodeIndex)) {\n\t\t\t\tsliversByNodeMap.set(node.nodeIndex, { primary: [], secondary: [] });\n\t\t\t}\n\n\t\t\tsliversByNodeMap.get(node.nodeIndex)!.primary.push({\n\t\t\t\tsliverIndex: primary.index,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tshardIndex,\n\t\t\t\tsliver: SliverData.serialize(primary).toBytes(),\n\t\t\t});\n\n\t\t\tsliversByNodeMap.get(node.nodeIndex)!.secondary.push({\n\t\t\t\tsliverIndex: secondary.index,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tshardIndex,\n\t\t\t\tsliver: SliverData.serialize(secondary).toBytes(),\n\t\t\t});\n\t\t}\n\n\t\tconst sliversByNode = new Array<SliversForNode>();\n\n\t\tfor (let i = 0; i < systemState.committee.members.length; i++) {\n\t\t\tsliversByNode.push(sliversByNodeMap.get(i) ?? { primary: [], secondary: [] });\n\t\t}\n\n\t\treturn { blobId, metadata, rootHash, sliversByNode };\n\t}\n\n\t/**\n\t * Write slivers to a storage node\n\t *\n\t * @usage\n\t * ```ts\n\t * await client.writeSliversToNode({ blobId, slivers, signal });\n\t * ```\n\t */\n\tasync writeSliversToNode({ blobId, slivers, signal }: WriteSliversToNodeOptions) {\n\t\tconst controller = new AbortController();\n\t\tconst combinedSignal = signal\n\t\t\t? AbortSignal.any([controller.signal, signal])\n\t\t\t: controller.signal;\n\n\t\tconst primarySliverWrites = slivers.primary.map(({ sliverPairIndex, sliver }) => {\n\t\t\treturn this.writeSliver({\n\t\t\t\tblobId,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tsliverType: 'primary',\n\t\t\t\tsliver,\n\t\t\t\tsignal: combinedSignal,\n\t\t\t});\n\t\t});\n\n\t\tconst secondarySliverWrites = slivers.secondary.map(({ sliverPairIndex, sliver }) => {\n\t\t\treturn this.writeSliver({\n\t\t\t\tblobId,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tsliverType: 'secondary',\n\t\t\t\tsliver,\n\t\t\t\tsignal: combinedSignal,\n\t\t\t});\n\t\t});\n\n\t\tawait Promise.all([...primarySliverWrites, ...secondarySliverWrites]).catch((error) => {\n\t\t\tcontroller.abort(error);\n\t\t\tthrow error;\n\t\t});\n\t}\n\n\t/**\n\t * Write a blob to all storage nodes\n\t *\n\t * @usage\n\t * ```ts\n\t * await client.writeEncodedBlobToNodes({ blob, deletable, epochs, signer });\n\t * ```\n\t */\n\tasync writeEncodedBlobToNodes({\n\t\tblobId,\n\t\tmetadata,\n\t\tsliversByNode,\n\t\tsignal,\n\t\t...options\n\t}: WriteEncodedBlobToNodesOptions) {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tconst controller = new AbortController();\n\t\tlet failures = 0;\n\n\t\tconst confirmations = await Promise.all(\n\t\t\tsliversByNode.map((slivers, nodeIndex) => {\n\t\t\t\treturn this.writeEncodedBlobToNode({\n\t\t\t\t\tblobId,\n\t\t\t\t\tnodeIndex,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tslivers,\n\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t...options,\n\t\t\t\t}).catch(() => {\n\t\t\t\t\tfailures += committee.nodes[nodeIndex].shardIndices.length;\n\n\t\t\t\t\tif (isAboveValidity(failures, systemState.committee.n_shards)) {\n\t\t\t\t\t\tconst error = new NotEnoughBlobConfirmationsError(\n\t\t\t\t\t\t\t`Too many failures while writing blob ${blobId} to nodes`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontroller.abort(error);\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t});\n\t\t\t}),\n\t\t);\n\n\t\treturn confirmations;\n\t}\n\n\t/**\n\t * Writes a blob to to an upload relay\n\t *\n\t * @usage\n\t * ```ts\n\t * await client.writeBlobToUploadRelay({ blob, deletable, epochs, signer });\n\t * ```\n\t */\n\tasync writeBlobToUploadRelay(options: WriteBlobToUploadRelayOptions): Promise<{\n\t\tblobId: string;\n\t\tcertificate: ProtocolMessageCertificate;\n\t}> {\n\t\tif (!this.#uploadRelayClient) {\n\t\t\tthrow new WalrusClientError('Upload relay not configured');\n\t\t}\n\n\t\treturn this.#uploadRelayClient.writeBlob({\n\t\t\t...options,\n\t\t\trequiresTip: !!this.#uploadRelayConfig?.sendTip,\n\t\t});\n\t}\n\n\t/**\n\t * Write encoded blob to a storage node\n\t *\n\t * @usage\n\t * ```ts\n\t * const res = await client.writeEncodedBlobToNode({ nodeIndex, blobId, metadata, slivers });\n\t * ```\n\t */\n\tasync writeEncodedBlobToNode({\n\t\tnodeIndex,\n\t\tblobId,\n\t\tmetadata,\n\t\tslivers,\n\t\tsignal,\n\t\t...options\n\t}: WriteEncodedBlobOptions) {\n\t\tawait this.writeMetadataToNode({\n\t\t\tnodeIndex,\n\t\t\tblobId,\n\t\t\tmetadata,\n\t\t\tsignal,\n\t\t});\n\n\t\tawait this.writeSliversToNode({ blobId, slivers, signal, nodeIndex });\n\n\t\treturn this.getStorageConfirmationFromNode({\n\t\t\tnodeIndex,\n\t\t\tblobId,\n\t\t\t...options,\n\t\t});\n\t}\n\n\t/**\n\t * Write a blob to all storage nodes\n\t *\n\t * @usage\n\t * ```ts\n\t * const { blobId, blobObject } = await client.writeBlob({ blob, deletable, epochs, signer });\n\t * ```\n\t */\n\tasync writeBlob({\n\t\tblob,\n\t\tdeletable,\n\t\tepochs,\n\t\tsigner,\n\t\tsignal,\n\t\towner,\n\t\tattributes,\n\t}: WriteBlobOptions) {\n\t\tif (!this.#uploadRelayConfig) {\n\t\t\tconst encoded = await this.encodeBlob(blob);\n\t\t\tconst blobId = encoded.blobId;\n\t\t\tconst { sliversByNode, metadata, rootHash } = encoded;\n\n\t\t\tconst suiBlobObject = await this.executeRegisterBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\tsize: blob.length,\n\t\t\t\tepochs,\n\t\t\t\tblobId,\n\t\t\t\trootHash,\n\t\t\t\tdeletable,\n\t\t\t\towner: owner ?? signer.toSuiAddress(),\n\t\t\t\tattributes,\n\t\t\t});\n\n\t\t\tconst blobObjectId = suiBlobObject.blob.id.id;\n\n\t\t\tconst confirmations = await this.writeEncodedBlobToNodes({\n\t\t\t\tblobId,\n\t\t\t\tmetadata,\n\t\t\t\tsliversByNode,\n\t\t\t\tdeletable,\n\t\t\t\tobjectId: blobObjectId,\n\t\t\t\tsignal,\n\t\t\t});\n\n\t\t\tawait this.executeCertifyBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\tblobId,\n\t\t\t\tblobObjectId,\n\t\t\t\tconfirmations,\n\t\t\t\tdeletable,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tblobId,\n\t\t\t\tblobObject: await this.#objectLoader.load(blobObjectId, Blob),\n\t\t\t};\n\t\t} else {\n\t\t\tconst metadata = await this.computeBlobMetadata({\n\t\t\t\tbytes: blob,\n\t\t\t});\n\t\t\tconst blobId = metadata.blobId;\n\n\t\t\tconst transaction = new Transaction();\n\n\t\t\ttransaction.add(\n\t\t\t\tthis.sendUploadRelayTip({\n\t\t\t\t\tsize: blob.length,\n\t\t\t\t\tblobDigest: metadata.blobDigest,\n\t\t\t\t\tnonce: metadata.nonce,\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tconst registerResult = await this.executeRegisterBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\ttransaction,\n\t\t\t\tsize: blob.length,\n\t\t\t\tepochs,\n\t\t\t\tblobId: metadata.blobId,\n\t\t\t\trootHash: metadata.rootHash,\n\t\t\t\tdeletable,\n\t\t\t\towner: owner ?? signer.toSuiAddress(),\n\t\t\t\tattributes,\n\t\t\t});\n\n\t\t\tawait this.#suiClient.core.waitForTransaction({\n\t\t\t\tdigest: registerResult.digest,\n\t\t\t});\n\n\t\t\tconst result = await this.writeBlobToUploadRelay({\n\t\t\t\tblobId,\n\t\t\t\tblob,\n\t\t\t\tnonce: metadata.nonce,\n\t\t\t\ttxDigest: registerResult.digest,\n\t\t\t\tsignal,\n\t\t\t\tdeletable,\n\t\t\t\tblobObjectId: registerResult.blob.id.id,\n\t\t\t\tencodingType: metadata.metadata.encodingType as EncodingType,\n\t\t\t});\n\n\t\t\tconst certificate = result.certificate;\n\t\t\tconst blobObjectId = registerResult.blob.id.id;\n\n\t\t\tawait this.executeCertifyBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\tblobId,\n\t\t\t\tblobObjectId,\n\t\t\t\tcertificate,\n\t\t\t\tdeletable,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tblobId,\n\t\t\t\tblobObject: await this.#objectLoader.load(blobObjectId, Blob),\n\t\t\t};\n\t\t}\n\t}\n\n\tasync writeQuilt({ blobs, ...options }: WriteQuiltOptions) {\n\t\tconst encoded = await this.encodeQuilt({ blobs });\n\t\tconst result = await this.writeBlob({\n\t\t\tblob: encoded.quilt,\n\t\t\t...options,\n\t\t});\n\n\t\treturn {\n\t\t\t...result,\n\t\t\tindex: {\n\t\t\t\t...encoded.index,\n\t\t\t\tpatches: encoded.index.patches.map((patch) => ({\n\t\t\t\t\t...patch,\n\t\t\t\t\tpatchId: encodeQuiltPatchId({\n\t\t\t\t\t\tquiltId: result.blobId,\n\t\t\t\t\t\tpatchId: {\n\t\t\t\t\t\t\tversion: 1,\n\t\t\t\t\t\t\tstartIndex: patch.startIndex,\n\t\t\t\t\t\t\tendIndex: patch.endIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t})),\n\t\t\t},\n\t\t};\n\t}\n\n\tasync encodeQuilt({\n\t\tblobs,\n\t}: {\n\t\tblobs: {\n\t\t\tcontents: Uint8Array;\n\t\t\tidentifier: string;\n\t\t\ttags?: Record<string, string>;\n\t\t}[];\n\t}) {\n\t\tconst systemState = await this.systemState();\n\t\tconst encoded = encodeQuilt({\n\t\t\tblobs,\n\t\t\tnumShards: systemState.committee.n_shards,\n\t\t});\n\n\t\treturn encoded;\n\t}\n\n\tasync #executeTransaction(transaction: Transaction, signer: Signer, action: string) {\n\t\ttransaction.setSenderIfNotSet(signer.toSuiAddress());\n\n\t\tconst { digest, effects } = await signer.signAndExecuteTransaction({\n\t\t\ttransaction,\n\t\t\tclient: this.#suiClient,\n\t\t});\n\n\t\tif (effects?.status.error) {\n\t\t\tthrow new WalrusClientError(`Failed to ${action} (${digest}): ${effects?.status.error}`);\n\t\t}\n\n\t\tawait this.#suiClient.core.waitForTransaction({\n\t\t\tdigest,\n\t\t});\n\n\t\treturn { digest, effects };\n\t}\n\n\tasync #getCommittee(committee: InferBcsType<typeof Committee>) {\n\t\tconst stakingPool = await this.#stakingPool(committee);\n\t\tconst shardIndicesByNodeId = getShardIndicesByNodeId(committee);\n\n\t\tconst byShardIndex = new Map<number, StorageNode>();\n\t\tconst nodes = stakingPool.map(({ node_info }, nodeIndex) => {\n\t\t\tconst shardIndices = shardIndicesByNodeId.get(node_info.node_id) ?? [];\n\t\t\tconst node: StorageNode = {\n\t\t\t\tid: node_info.node_id,\n\t\t\t\tinfo: node_info,\n\t\t\t\tnetworkUrl: `https://${node_info.network_address}`,\n\t\t\t\tshardIndices,\n\t\t\t\tnodeIndex,\n\t\t\t};\n\n\t\t\tfor (const shardIndex of shardIndices) {\n\t\t\t\tbyShardIndex.set(shardIndex, node);\n\t\t\t}\n\n\t\t\treturn node;\n\t\t});\n\n\t\treturn {\n\t\t\tbyShardIndex,\n\t\t\tnodes,\n\t\t};\n\t}\n\n\t#getActiveCommittee() {\n\t\treturn this.#cache.read(['getActiveCommittee'], async () => {\n\t\t\tconst stakingState = await this.stakingState();\n\t\t\treturn this.#getCommittee(stakingState.committee);\n\t\t});\n\t}\n\n\tasync #stakingPool(committee: InferBcsType<typeof Committee>) {\n\t\tconst nodeIds = committee[0].contents.map((node) => node.key);\n\t\treturn this.#objectLoader.loadManyOrThrow(nodeIds, StakingPool);\n\t}\n\n\tasync #getNodeByShardIndex(committeeInfo: CommitteeInfo, index: number) {\n\t\tconst node = committeeInfo.byShardIndex.get(index);\n\t\tif (!node) {\n\t\t\tthrow new WalrusClientError(`Node for shard index ${index} not found`);\n\t\t}\n\t\treturn node;\n\t}\n\n\t/**\n\t * Reset cached data in the client\n\t *\n\t * @usage\n\t * ```ts\n\t * client.reset();\n\t * ```\n\t */\n\treset() {\n\t\tthis.#objectLoader.clearAll();\n\t\tthis.#cache.clear();\n\t}\n\n\t#retryOnPossibleEpochChange<T extends (...args: any[]) => Promise<any>>(fn: T): T {\n\t\treturn (async (...args: Parameters<T>) => {\n\t\t\ttry {\n\t\t\t\treturn await fn.apply(this, args);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof RetryableWalrusClientError) {\n\t\t\t\t\tthis.reset();\n\t\t\t\t\treturn await fn.apply(this, args);\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}) as T;\n\t}\n\n\tasync getBlob({ blobId }: { blobId: string }) {\n\t\treturn new WalrusBlob({\n\t\t\treader: new BlobReader({\n\t\t\t\tclient: this,\n\t\t\t\tblobId,\n\t\t\t\tnumShards: (await this.systemState()).committee.n_shards,\n\t\t\t}),\n\t\t\tclient: this,\n\t\t});\n\t}\n\n\tasync getFiles({ ids }: { ids: string[] }) {\n\t\tconst readersByBlobId = new Map<string, BlobReader>();\n\t\tconst quiltReadersByBlobId = new Map<string, QuiltReader>();\n\t\tconst parsedIds = ids.map((id) => parseWalrusId(id));\n\t\tconst numShards = (await this.systemState()).committee.n_shards;\n\n\t\tfor (const id of parsedIds) {\n\t\t\tconst blobId = id.kind === 'blob' ? id.id : id.id.quiltId;\n\t\t\tif (!readersByBlobId.has(blobId)) {\n\t\t\t\treadersByBlobId.set(\n\t\t\t\t\tblobId,\n\t\t\t\t\tnew BlobReader({\n\t\t\t\t\t\tclient: this,\n\t\t\t\t\t\tblobId,\n\t\t\t\t\t\tnumShards,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (id.kind === 'quiltPatch') {\n\t\t\t\tif (!quiltReadersByBlobId.has(blobId)) {\n\t\t\t\t\tquiltReadersByBlobId.set(\n\t\t\t\t\t\tblobId,\n\t\t\t\t\t\tnew QuiltReader({\n\t\t\t\t\t\t\tblob: readersByBlobId.get(blobId)!,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn parsedIds.map((id) => {\n\t\t\tif (id.kind === 'blob') {\n\t\t\t\treturn new WalrusFile({\n\t\t\t\t\treader: readersByBlobId.get(id.id)!,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new WalrusFile({\n\t\t\t\treader: new QuiltFileReader({\n\t\t\t\t\tquilt: quiltReadersByBlobId.get(id.id.quiltId)!,\n\t\t\t\t\tsliverIndex: id.id.patchId.startIndex,\n\t\t\t\t}),\n\t\t\t});\n\t\t});\n\t}\n\n\tasync writeFiles({ files, ...options }: WriteFilesOptions) {\n\t\tconst { blobId, index, blobObject } = await this.writeQuilt({\n\t\t\t...options,\n\t\t\tblobs: await Promise.all(\n\t\t\t\tfiles.map(async (file, i) => ({\n\t\t\t\t\tcontents: await file.bytes(),\n\t\t\t\t\tidentifier: (await file.getIdentifier()) ?? `file-${i}`,\n\t\t\t\t\ttags: (await file.getTags()) ?? {},\n\t\t\t\t})),\n\t\t\t),\n\t\t});\n\n\t\treturn index.patches.map((patch) => ({\n\t\t\tid: patch.patchId,\n\t\t\tblobId,\n\t\t\tblobObject,\n\t\t}));\n\t}\n\n\twriteFilesFlow({ files }: WriteFilesFlowOptions): WriteFilesFlow {\n\t\tconst encode = async () => {\n\t\t\tconst { quilt, index } = await this.encodeQuilt({\n\t\t\t\tblobs: await Promise.all(\n\t\t\t\t\tfiles.map(async (file, i) => ({\n\t\t\t\t\t\tcontents: await file.bytes(),\n\t\t\t\t\t\tidentifier: (await file.getIdentifier()) ?? `file-${i}`,\n\t\t\t\t\t\ttags: (await file.getTags()) ?? {},\n\t\t\t\t\t})),\n\t\t\t\t),\n\t\t\t});\n\t\t\tconst metadata = this.#uploadRelayClient\n\t\t\t\t? await this.computeBlobMetadata({\n\t\t\t\t\t\tbytes: quilt,\n\t\t\t\t\t})\n\t\t\t\t: await this.encodeBlob(quilt);\n\n\t\t\treturn {\n\t\t\t\tmetadata,\n\t\t\t\tsize: quilt.length,\n\t\t\t\tdata: this.#uploadRelayClient ? quilt : undefined,\n\t\t\t\tindex,\n\t\t\t};\n\t\t};\n\n\t\tconst register = (\n\t\t\t{ data, metadata, index, size }: Awaited<ReturnType<typeof encode>>,\n\t\t\t{ epochs, deletable, owner, attributes }: WriteFilesFlowRegisterOptions,\n\t\t) => {\n\t\t\tconst transaction = new Transaction();\n\t\t\ttransaction.setSenderIfNotSet(owner);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\ttransaction.add(\n\t\t\t\t\tthis.sendUploadRelayTip({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tblobDigest: meta.blobDigest,\n\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttransaction.transferObjects(\n\t\t\t\t[\n\t\t\t\t\tthis.registerBlob({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tepochs,\n\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\trootHash: metadata.rootHash,\n\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\towner,\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tregisterTransaction: transaction,\n\t\t\t\tindex,\n\t\t\t\tdata,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t};\n\t\t};\n\n\t\tconst upload = async (\n\t\t\t{ index, data, metadata, deletable }: Awaited<ReturnType<typeof register>>,\n\t\t\t{ digest }: WriteFilesFlowUploadOptions,\n\t\t) => {\n\t\t\tconst blobObject = await this.#getCreatedBlob(digest);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\treturn {\n\t\t\t\t\tindex,\n\t\t\t\t\tblobObject,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tdeletable,\n\t\t\t\t\tcertificate: (\n\t\t\t\t\t\tawait this.writeBlobToUploadRelay({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblob: data!,\n\t\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t\t\ttxDigest: digest,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t\tencodingType: meta.metadata.encodingType as EncodingType,\n\t\t\t\t\t\t})\n\t\t\t\t\t).certificate,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.encodeBlob>>;\n\n\t\t\treturn {\n\t\t\t\tindex,\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t\tconfirmations: await this.writeEncodedBlobToNodes({\n\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\tobjectId: blobObject.id.id,\n\t\t\t\t\tmetadata: meta.metadata,\n\t\t\t\t\tsliversByNode: meta.sliversByNode,\n\t\t\t\t\tdeletable,\n\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tconst certify = ({\n\t\t\tindex,\n\t\t\tmetadata,\n\t\t\tconfirmations,\n\t\t\tcertificate,\n\t\t\tblobObject,\n\t\t\tdeletable,\n\t\t}: Awaited<ReturnType<typeof upload>>) => {\n\t\t\treturn {\n\t\t\t\tindex,\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\ttransaction: confirmations\n\t\t\t\t\t? this.certifyBlobTransaction({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tconfirmations,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t})\n\t\t\t\t\t: this.certifyBlobTransaction({\n\t\t\t\t\t\t\tcertificate,\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tasync function listFiles({ index, blobObject, metadata }: Awaited<ReturnType<typeof certify>>) {\n\t\t\treturn index.patches.map((patch) => ({\n\t\t\t\tid: encodeQuiltPatchId({\n\t\t\t\t\tquiltId: metadata.blobId,\n\t\t\t\t\tpatchId: {\n\t\t\t\t\t\tversion: 1,\n\t\t\t\t\t\tstartIndex: patch.startIndex,\n\t\t\t\t\t\tendIndex: patch.endIndex,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t\tblobId: metadata.blobId,\n\t\t\t\tblobObject,\n\t\t\t}));\n\t\t}\n\n\t\tconst stepResults: {\n\t\t\tencode?: Awaited<ReturnType<typeof encode>>;\n\t\t\tregister?: Awaited<ReturnType<typeof register>>;\n\t\t\tupload?: Awaited<ReturnType<typeof upload>>;\n\t\t\tcertify?: Awaited<ReturnType<typeof certify>>;\n\t\t\tlistFiles?: never;\n\t\t} = {};\n\n\t\tfunction getResults<T extends keyof typeof stepResults>(\n\t\t\tstep: T,\n\t\t\tcurrent: keyof typeof stepResults,\n\t\t): NonNullable<(typeof stepResults)[T]> {\n\t\t\tif (!stepResults[step]) {\n\t\t\t\tthrow new Error(`${step} must be executed before calling ${current}`);\n\t\t\t}\n\t\t\treturn stepResults[step];\n\t\t}\n\n\t\treturn {\n\t\t\tencode: async () => {\n\t\t\t\tif (!stepResults.encode) {\n\t\t\t\t\tstepResults.encode = await encode();\n\t\t\t\t}\n\t\t\t},\n\t\t\tregister: (options: WriteFilesFlowRegisterOptions) => {\n\t\t\t\tstepResults.register = register(getResults('encode', 'register'), options);\n\t\t\t\treturn stepResults.register.registerTransaction;\n\t\t\t},\n\t\t\tupload: async (options: WriteFilesFlowUploadOptions) => {\n\t\t\t\tstepResults.upload = await upload(getResults('register', 'upload'), options);\n\t\t\t},\n\t\t\tcertify: () => {\n\t\t\t\tstepResults.certify = certify(getResults('upload', 'certify'));\n\t\t\t\treturn stepResults.certify.transaction;\n\t\t\t},\n\t\t\tlistFiles: async () => {\n\t\t\t\treturn listFiles(getResults('certify', 'listFiles'));\n\t\t\t},\n\t\t};\n\t}\n\n\twriteBlobFlow({ blob }: WriteBlobFlowOptions): WriteBlobFlow {\n\t\tconst encode = async () => {\n\t\t\tconst metadata = this.#uploadRelayClient\n\t\t\t\t? await this.computeBlobMetadata({\n\t\t\t\t\t\tbytes: blob,\n\t\t\t\t\t})\n\t\t\t\t: await this.encodeBlob(blob);\n\n\t\t\treturn {\n\t\t\t\tmetadata,\n\t\t\t\tsize: blob.length,\n\t\t\t\tdata: this.#uploadRelayClient ? blob : undefined,\n\t\t\t};\n\t\t};\n\n\t\tconst register = (\n\t\t\t{ data, metadata, size }: Awaited<ReturnType<typeof encode>>,\n\t\t\t{ epochs, deletable, owner, attributes }: WriteBlobFlowRegisterOptions,\n\t\t) => {\n\t\t\tconst transaction = new Transaction();\n\t\t\ttransaction.setSenderIfNotSet(owner);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\ttransaction.add(\n\t\t\t\t\tthis.sendUploadRelayTip({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tblobDigest: meta.blobDigest,\n\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttransaction.transferObjects(\n\t\t\t\t[\n\t\t\t\t\tthis.registerBlob({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tepochs,\n\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\trootHash: metadata.rootHash,\n\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\towner,\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tregisterTransaction: transaction,\n\t\t\t\tdata,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t};\n\t\t};\n\n\t\tconst upload = async (\n\t\t\t{ data, metadata, deletable }: Awaited<ReturnType<typeof register>>,\n\t\t\t{ digest }: WriteBlobFlowUploadOptions,\n\t\t) => {\n\t\t\tconst blobObject = await this.#getCreatedBlob(digest);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\treturn {\n\t\t\t\t\tblobObject,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tdeletable,\n\t\t\t\t\tcertificate: (\n\t\t\t\t\t\tawait this.writeBlobToUploadRelay({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblob: data!,\n\t\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t\t\ttxDigest: digest,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t\tencodingType: meta.metadata.encodingType as EncodingType,\n\t\t\t\t\t\t})\n\t\t\t\t\t).certificate,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.encodeBlob>>;\n\n\t\t\treturn {\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t\tconfirmations: await this.writeEncodedBlobToNodes({\n\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\tobjectId: blobObject.id.id,\n\t\t\t\t\tmetadata: meta.metadata,\n\t\t\t\t\tsliversByNode: meta.sliversByNode,\n\t\t\t\t\tdeletable,\n\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tconst certify = ({\n\t\t\tmetadata,\n\t\t\tconfirmations,\n\t\t\tcertificate,\n\t\t\tblobObject,\n\t\t\tdeletable,\n\t\t}: Awaited<ReturnType<typeof upload>>) => {\n\t\t\treturn {\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\ttransaction: confirmations\n\t\t\t\t\t? this.certifyBlobTransaction({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tconfirmations,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t})\n\t\t\t\t\t: this.certifyBlobTransaction({\n\t\t\t\t\t\t\tcertificate,\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tasync function getBlob({ blobObject, metadata }: Awaited<ReturnType<typeof certify>>) {\n\t\t\treturn {\n\t\t\t\tblobId: metadata.blobId,\n\t\t\t\tblobObject,\n\t\t\t};\n\t\t}\n\n\t\tconst stepResults: {\n\t\t\tencode?: Awaited<ReturnType<typeof encode>>;\n\t\t\tregister?: Awaited<ReturnType<typeof register>>;\n\t\t\tupload?: Awaited<ReturnType<typeof upload>>;\n\t\t\tcertify?: Awaited<ReturnType<typeof certify>>;\n\t\t\tgetBlob?: never;\n\t\t} = {};\n\n\t\tfunction getResults<T extends keyof typeof stepResults>(\n\t\t\tstep: T,\n\t\t\tcurrent: keyof typeof stepResults,\n\t\t): NonNullable<(typeof stepResults)[T]> {\n\t\t\tif (!stepResults[step]) {\n\t\t\t\tthrow new Error(`${step} must be executed before calling ${current}`);\n\t\t\t}\n\t\t\treturn stepResults[step];\n\t\t}\n\n\t\treturn {\n\t\t\tencode: async () => {\n\t\t\t\tif (!stepResults.encode) {\n\t\t\t\t\tstepResults.encode = await encode();\n\t\t\t\t}\n\t\t\t},\n\t\t\tregister: (options: WriteBlobFlowRegisterOptions) => {\n\t\t\t\tstepResults.register = register(getResults('encode', 'register'), options);\n\t\t\t\treturn stepResults.register.registerTransaction;\n\t\t\t},\n\t\t\tupload: async (options: WriteBlobFlowUploadOptions) => {\n\t\t\t\tstepResults.upload = await upload(getResults('register', 'upload'), options);\n\t\t\t},\n\t\t\tcertify: () => {\n\t\t\t\tstepResults.certify = certify(getResults('upload', 'certify'));\n\t\t\t\treturn stepResults.certify.transaction;\n\t\t\t},\n\t\t\tgetBlob: async () => {\n\t\t\t\treturn getBlob(getResults('certify', 'getBlob'));\n\t\t\t},\n\t\t};\n\t}\n}\n"],
  "mappings": "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",
  "names": ["metadata", "error", "tx", "meta"]
}

import { bcs } from "@mysten/sui/bcs";
const MerkleNode = bcs.enum("MerkleNode", {
  Empty: null,
  Digest: bcs.bytes(32)
});
const SliverPairMetadata = bcs.struct("SliverPairMetadata", {
  primary_hash: MerkleNode,
  secondary_hash: MerkleNode
});
const EncodingType = bcs.enum("EncodingType", {
  RedStuff: null,
  RS2: null
}).transform({
  input: (encodingType) => typeof encodingType === "string" ? { [encodingType]: null } : encodingType,
  output: (encodingType) => encodingType
});
const BlobMetadataV1 = bcs.struct("BlobMetadataV1", {
  encoding_type: EncodingType,
  unencoded_length: bcs.u64(),
  hashes: bcs.vector(SliverPairMetadata)
});
const BlobMetadata = bcs.enum("BlobMetadata", {
  V1: BlobMetadataV1
});
const BlobId = bcs.u256().transform({
  input: (blobId) => typeof blobId === "string" ? blobIdToInt(blobId) : blobId,
  output: (id) => blobIdFromInt(id)
});
function blobIdFromInt(blobId) {
  return bcs.u256().serialize(blobId).toBase64().replace(/=*$/, "").replaceAll("+", "-").replaceAll("/", "_");
}
function blobIdFromBytes(blobId) {
  return blobIdFromInt(bcs.u256().parse(blobId));
}
function blobIdToInt(blobId) {
  return BigInt(bcs.u256().fromBase64(blobId.replaceAll("-", "+").replaceAll("_", "/")));
}
const BlobMetadataWithId = bcs.struct("BlobMetadataWithId", {
  blobId: BlobId,
  metadata: BlobMetadata
});
const Symbols = bcs.struct("Symbols", {
  data: bcs.vector(bcs.u8()),
  symbol_size: bcs.u16()
});
const SliverData = bcs.struct("SliverData", {
  symbols: Symbols,
  index: bcs.u16()
});
const Sliver = bcs.enum("Sliver", {
  Primary: SliverData,
  Secondary: SliverData
});
const SliverPair = bcs.struct("SliverPair", {
  primary: SliverData,
  secondary: SliverData
});
var IntentType = /* @__PURE__ */ ((IntentType2) => {
  IntentType2[IntentType2["PROOF_OF_POSSESSION_MSG"] = 0] = "PROOF_OF_POSSESSION_MSG";
  IntentType2[IntentType2["BLOB_CERT_MSG"] = 1] = "BLOB_CERT_MSG";
  IntentType2[IntentType2["INVALID_BLOB_ID_MSG"] = 2] = "INVALID_BLOB_ID_MSG";
  IntentType2[IntentType2["SYNC_SHARD_MSG"] = 3] = "SYNC_SHARD_MSG";
  return IntentType2;
})(IntentType || {});
const Intent = bcs.struct("Intent", {
  type: bcs.u8().transform({
    input: (type) => type,
    output: (type) => type
  }),
  version: bcs.u8(),
  appId: bcs.u8()
}).transform({
  input: (intent) => ({
    type: intent,
    version: 0,
    appId: 3
  }),
  output: (intent) => intent.type
});
function ProtocolMessage(messageContents) {
  return bcs.struct(`ProtocolMessage<${messageContents.name}>`, {
    intent: Intent,
    epoch: bcs.u32(),
    messageContents
  });
}
const BlobPersistenceType = bcs.enum("BlobPersistenceType", {
  Permanent: null,
  Deletable: bcs.struct("Deletable", {
    objectId: bcs.Address
  })
});
const StorageConfirmationBody = bcs.struct("StorageConfirmationBody", {
  blobId: BlobId,
  blobType: BlobPersistenceType
});
const StorageConfirmation = ProtocolMessage(StorageConfirmationBody);
function Field(...typeParameters) {
  return bcs.struct("Field", {
    id: bcs.Address,
    name: typeParameters[0],
    value: typeParameters[1]
  });
}
const QuiltPatchTags = bcs.map(bcs.string(), bcs.string()).transform({
  // tags is a BTreeMap, so we need to sort entries before serializing
  input: (tags) => new Map(
    [...tags instanceof Map ? tags : Object.entries(tags)].sort(
      ([a], [b]) => (
        // TODO: sorting for map keys should be moved into @mysten/bcs
        compareBcsBytes(bcs.string().serialize(a).toBytes(), bcs.string().serialize(b).toBytes())
      )
    )
  ),
  output: (tags) => Object.fromEntries(tags)
});
const QuiltPatchV1 = bcs.struct("QuiltPatchV1", {
  endIndex: bcs.u16(),
  identifier: bcs.string(),
  tags: QuiltPatchTags
});
function compareBcsBytes(a, b) {
  if (a.length !== b.length) {
    return a.length - b.length;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return a[i] - b[i];
    }
  }
  return 0;
}
const QuiltIndexV1 = bcs.struct("QuiltIndexV1", {
  patches: bcs.vector(QuiltPatchV1)
});
const QuiltPatchId = bcs.struct("QuiltPatchId", {
  quiltId: BlobId,
  patchId: bcs.struct("InternalQuiltPatchId", {
    version: bcs.u8(),
    startIndex: bcs.u16(),
    endIndex: bcs.u16()
  })
});
const QuiltPatchBlobHeader = bcs.struct("QuiltPatchBlobHeader", {
  version: bcs.u8(),
  length: bcs.u32(),
  mask: bcs.u8()
});
export {
  BlobId,
  BlobMetadata,
  BlobMetadataV1,
  BlobMetadataWithId,
  BlobPersistenceType,
  EncodingType,
  Field,
  Intent,
  IntentType,
  ProtocolMessage,
  QuiltIndexV1,
  QuiltPatchBlobHeader,
  QuiltPatchId,
  QuiltPatchTags,
  QuiltPatchV1,
  Sliver,
  SliverData,
  SliverPair,
  StorageConfirmation,
  StorageConfirmationBody,
  blobIdFromBytes,
  blobIdFromInt,
  blobIdToInt
};
//# sourceMappingURL=bcs.js.map

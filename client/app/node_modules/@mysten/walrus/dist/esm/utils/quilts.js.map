{
  "version": 3,
  "sources": ["../../../src/utils/quilts.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\nimport type { EncodingType } from '../types.js';\nimport type { QuiltPatchV1 } from './bcs.js';\nimport { QuiltIndexV1, QuiltPatchBlobHeader, QuiltPatchId, QuiltPatchTags } from './bcs.js';\nimport {\n\tfromUrlSafeBase64,\n\tgetSourceSymbols,\n\tMAX_SYMBOL_SIZE_BY_ENCODING_TYPE,\n\tREQUIRED_ALIGNMENT_BY_ENCODING_TYPE,\n\turlSafeBase64,\n} from './index.js';\n\nexport const QUILT_INDEX_SIZE_BYTES_LENGTH = 4;\nexport const QUILT_VERSION_BYTES_LENGTH = 1;\nexport const QUILT_INDEX_PREFIX_SIZE = QUILT_VERSION_BYTES_LENGTH + QUILT_INDEX_SIZE_BYTES_LENGTH;\nexport const QUILT_PATCH_BLOB_HEADER_SIZE = 1 + 4 + 1; // bcs length of QuiltPatchBlobHeader\n\nexport const BLOB_IDENTIFIER_SIZE_BYTES_LENGTH = 2;\nexport const TAGS_SIZE_BYTES_LENGTH = 2;\nexport const MAX_BLOB_IDENTIFIER_BYTES_LENGTH = (1 << (8 * BLOB_IDENTIFIER_SIZE_BYTES_LENGTH)) - 1;\nexport const MAX_NUM_SLIVERS_FOR_QUILT_INDEX = 10;\n\nexport const HAS_TAGS_FLAG = 1 << 0;\n\n/**\n * Finds the minimum symbol size needed to store blobs in a fixed number of columns.\n * Each blob must be stored in consecutive columns exclusively.\n *\n * A binary search is used to find the minimum symbol size:\n * 1. Compute the upper and lower bounds for the symbol size.\n * 2. Check if the all the blobs can be fit into the quilt with the current symbol size.\n * 3. Adjust the bounds based on the result and repeat until the symbol size is found.\n *\n * @param blobsSizes - Slice of blob lengths, including the index size as the first element.\n *   Note that the len of the blob_size should be between 1 and n_columns.\n * @param nColumns - Number of columns available.\n * @param nRows - Number of rows available.\n * @param maxNumColumnsForQuiltIndex - The maximum number of columns that can be used to\n *   store the quilt index.\n * @param encodingType - The encoding type to use.\n *\n * @returns The minimum symbol size needed.\n **/\nexport function computeSymbolSize(\n\tblobsSizes: number[],\n\tnColumns: number,\n\tnRows: number,\n\tmaxNumColumnsForQuiltIndex: number,\n\tencodingType: EncodingType = 'RS2',\n): number {\n\tif (blobsSizes.length > nColumns) {\n\t\tthrow new Error('Too many blobs, the number of blobs must be less than the number of columns');\n\t}\n\n\tif (blobsSizes.length === 0) {\n\t\tthrow new Error('No blobs provided');\n\t}\n\n\tlet minVal = Math.max(\n\t\tblobsSizes.reduce((acc, size) => acc + size, 0) / (nColumns * nRows),\n\t\tblobsSizes[0] / (nRows * maxNumColumnsForQuiltIndex),\n\t\tMath.ceil(QUILT_INDEX_PREFIX_SIZE / nRows),\n\t);\n\n\tlet maxVal = Math.ceil((Math.max(...blobsSizes) / (nColumns / blobsSizes.length)) * nRows);\n\n\twhile (minVal < maxVal) {\n\t\tconst mid = (minVal + maxVal) / 2;\n\t\tif (canBlobsFitIntoMatrix(blobsSizes, nColumns, mid * nRows)) {\n\t\t\tmaxVal = mid;\n\t\t} else {\n\t\t\tminVal = mid + 1;\n\t\t}\n\t}\n\n\tconst symbolSize =\n\t\tMath.ceil(minVal / REQUIRED_ALIGNMENT_BY_ENCODING_TYPE[encodingType]) *\n\t\tREQUIRED_ALIGNMENT_BY_ENCODING_TYPE[encodingType];\n\n\tif (!canBlobsFitIntoMatrix(blobsSizes, nColumns, symbolSize * nRows)) {\n\t\tthrow new Error('Quilt oversize');\n\t}\n\n\tif (symbolSize > MAX_SYMBOL_SIZE_BY_ENCODING_TYPE[encodingType]) {\n\t\tthrow new Error(\n\t\t\t`Quilt oversize: the resulting symbol size ${symbolSize} is larger than the maximum symbol size ${MAX_SYMBOL_SIZE_BY_ENCODING_TYPE[encodingType]}; remove some blobs`,\n\t\t);\n\t}\n\n\treturn symbolSize;\n}\n\nfunction canBlobsFitIntoMatrix(\n\tblobsSizes: number[],\n\tnColumns: number,\n\tcolumnSize: number,\n): boolean {\n\treturn blobsSizes.reduce((acc, size) => acc + Math.ceil(size / columnSize), 0) <= nColumns;\n}\n\nexport function parseQuiltPatchId(id: string) {\n\treturn QuiltPatchId.parse(fromUrlSafeBase64(id));\n}\n\nexport function encodeQuiltPatchId(id: typeof QuiltPatchId.$inferInput) {\n\treturn urlSafeBase64(QuiltPatchId.serialize(id).toBytes());\n}\n\nexport function parseWalrusId(id: string) {\n\tconst bytes = fromUrlSafeBase64(id);\n\n\tif (bytes.length === 32) {\n\t\treturn {\n\t\t\tkind: 'blob' as const,\n\t\t\tid,\n\t\t};\n\t}\n\n\treturn {\n\t\tkind: 'quiltPatch' as const,\n\t\tid: parseQuiltPatchId(id),\n\t};\n}\n\nexport interface EncodeQuiltOptions {\n\tblobs: {\n\t\tcontents: Uint8Array;\n\t\tidentifier: string;\n\t\ttags?: Record<string, string>;\n\t}[];\n\tnumShards: number;\n\tencodingType?: EncodingType;\n}\n\nexport function encodeQuilt({ blobs, numShards, encodingType }: EncodeQuiltOptions) {\n\tconst { primarySymbols: nRows, secondarySymbols: nCols } = getSourceSymbols(\n\t\tnumShards,\n\t\tencodingType,\n\t);\n\n\tconst sortedBlobs = blobs.sort((a, b) => (a.identifier < b.identifier ? -1 : 1));\n\tconst identifiers = new Set<string>();\n\tconst index = {\n\t\tpatches: [] as (typeof QuiltPatchV1.$inferInput & { startIndex: number })[],\n\t};\n\tconst tags = sortedBlobs.map((blob) =>\n\t\tblob.tags && Object.keys(blob.tags).length > 0\n\t\t\t? QuiltPatchTags.serialize(blob.tags).toBytes()\n\t\t\t: null,\n\t);\n\n\tfor (const blob of sortedBlobs) {\n\t\tif (identifiers.has(blob.identifier)) {\n\t\t\tthrow new Error(`Duplicate blob identifier: ${blob.identifier}`);\n\t\t}\n\t\tidentifiers.add(blob.identifier);\n\t\tindex.patches.push({\n\t\t\tstartIndex: 0,\n\t\t\tendIndex: 0,\n\t\t\tidentifier: blob.identifier,\n\t\t\ttags: blob.tags ?? {},\n\t\t});\n\t}\n\n\tconst indexSize = QUILT_INDEX_PREFIX_SIZE + QuiltIndexV1.serialize(index).toBytes().length;\n\tconst blobMetadata = sortedBlobs.map((blob, i) => {\n\t\tconst identifierBytes = bcs.string().serialize(blob.identifier).toBytes();\n\t\tlet metadataSize =\n\t\t\tQUILT_PATCH_BLOB_HEADER_SIZE + BLOB_IDENTIFIER_SIZE_BYTES_LENGTH + identifierBytes.length;\n\n\t\tlet mask = 0;\n\t\tlet offset = 0;\n\n\t\tif (tags[i]) {\n\t\t\tmetadataSize += TAGS_SIZE_BYTES_LENGTH + tags[i].length;\n\t\t\tmask |= HAS_TAGS_FLAG << 0;\n\t\t}\n\n\t\tconst metadata = new Uint8Array(metadataSize);\n\t\tconst metadataView = new DataView(metadata.buffer);\n\n\t\tconst header = QuiltPatchBlobHeader.serialize({\n\t\t\tversion: 1,\n\t\t\tlength: metadataSize - QUILT_PATCH_BLOB_HEADER_SIZE + blob.contents.length,\n\t\t\tmask,\n\t\t}).toBytes();\n\n\t\tmetadata.set(header, offset);\n\t\toffset += header.length;\n\n\t\tmetadataView.setUint16(offset, identifierBytes.length, true);\n\t\toffset += BLOB_IDENTIFIER_SIZE_BYTES_LENGTH;\n\t\tmetadata.set(identifierBytes, offset);\n\t\toffset += identifierBytes.length;\n\n\t\tif (tags[i]) {\n\t\t\tmetadataView.setUint16(offset, tags[i].length, true);\n\t\t\toffset += TAGS_SIZE_BYTES_LENGTH;\n\t\t\tmetadata.set(tags[i], offset);\n\t\t\toffset += tags[i].length;\n\t\t}\n\n\t\treturn metadata;\n\t});\n\n\tconst blobSizes = [\n\t\tindexSize,\n\t\t...sortedBlobs.map((blob, i) => {\n\t\t\tif (blob.identifier.length > MAX_BLOB_IDENTIFIER_BYTES_LENGTH) {\n\t\t\t\tthrow new Error(`Blob identifier too long: ${blob.identifier}`);\n\t\t\t}\n\n\t\t\treturn blobMetadata[i].length + blob.contents.length;\n\t\t}),\n\t];\n\n\tconst symbolSize = computeSymbolSize(\n\t\tblobSizes,\n\t\tnCols,\n\t\tnRows,\n\t\tMAX_NUM_SLIVERS_FOR_QUILT_INDEX,\n\t\tencodingType,\n\t);\n\n\tconst rowSize = symbolSize * nCols;\n\tconst columnSize = symbolSize * nRows;\n\tconst indexColumnsNeeded = Math.ceil(indexSize / columnSize);\n\n\tif (indexColumnsNeeded > MAX_NUM_SLIVERS_FOR_QUILT_INDEX) {\n\t\tthrow new Error('Index too large');\n\t}\n\n\tconst quilt = new Uint8Array(rowSize * nRows);\n\tlet currentColumn = indexColumnsNeeded;\n\n\tfor (let i = 0; i < sortedBlobs.length; i++) {\n\t\tconst blob = sortedBlobs[i];\n\t\tindex.patches[i].startIndex = currentColumn;\n\t\tcurrentColumn += writeBlobToQuilt(\n\t\t\tquilt,\n\t\t\tblob.contents,\n\t\t\trowSize,\n\t\t\tcolumnSize,\n\t\t\tsymbolSize,\n\t\t\tcurrentColumn,\n\t\t\tblobMetadata[i],\n\t\t);\n\t\tindex.patches[i].endIndex = currentColumn;\n\t}\n\n\tconst indexBytes = QuiltIndexV1.serialize(index).toBytes();\n\tconst quiltIndex = new Uint8Array(QUILT_INDEX_PREFIX_SIZE + indexBytes.length);\n\tconst view = new DataView(quiltIndex.buffer);\n\tview.setUint8(0, 1);\n\tview.setUint32(1, indexBytes.length, true);\n\tquiltIndex.set(indexBytes, QUILT_INDEX_PREFIX_SIZE);\n\n\twriteBlobToQuilt(quilt, quiltIndex, rowSize, columnSize, symbolSize, 0);\n\n\treturn { quilt, index };\n}\n\nfunction writeBlobToQuilt(\n\tquilt: Uint8Array,\n\tblob: Uint8Array,\n\trowSize: number,\n\tcolumnSize: number,\n\tsymbolSize: number,\n\tstartColumn: number,\n\tprefix?: Uint8Array,\n) {\n\tconst nRows = columnSize / symbolSize;\n\tlet bytesWritten = 0;\n\n\tif (rowSize % symbolSize !== 0) {\n\t\tthrow new Error('Row size must be divisible by symbol size');\n\t}\n\n\tif (columnSize % symbolSize !== 0) {\n\t\tthrow new Error('Column size must be divisible by symbol size');\n\t}\n\n\tif (prefix) {\n\t\twriteBytes(prefix);\n\t}\n\n\twriteBytes(blob);\n\n\treturn Math.ceil(bytesWritten / columnSize);\n\n\tfunction writeBytes(bytes: Uint8Array) {\n\t\tconst offset = bytesWritten;\n\t\tconst symbolsToSkip = Math.floor(offset / symbolSize);\n\t\tlet remainingOffset = offset % symbolSize;\n\t\tlet currentCol = startColumn + Math.floor(symbolsToSkip / nRows);\n\t\tlet currentRow = symbolsToSkip % nRows;\n\n\t\tlet index = 0;\n\t\twhile (index < bytes.length) {\n\t\t\tconst baseIndex = currentRow * rowSize + currentCol * symbolSize;\n\t\t\tconst startIndex = baseIndex + remainingOffset;\n\t\t\tconst len = Math.min(symbolSize - remainingOffset, bytes.length - index);\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tquilt[startIndex + i] = bytes[index + i];\n\t\t\t}\n\t\t\tindex += len;\n\t\t\tremainingOffset = 0;\n\t\t\tcurrentRow = (currentRow + 1) % nRows;\n\t\t\tif (currentRow === 0) {\n\t\t\t\tcurrentCol++;\n\t\t\t}\n\t\t}\n\n\t\tbytesWritten += bytes.length;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}

import { fromBase64, toBase64 } from "@mysten/bcs";
import { BlobId } from "./bcs.js";
const DIGEST_LEN = 32;
const BLOB_ID_LEN = 32;
const REQUIRED_ALIGNMENT_BY_ENCODING_TYPE = {
  RS2: 2,
  RedStuff: 2
};
const MAX_SYMBOL_SIZE_BY_ENCODING_TYPE = {
  RS2: 2 ** 16 - 1,
  RedStuff: 2 ** 16 - 1
};
function encodedBlobLength(unencodedLength, nShards, encodingType = "RS2") {
  const sliverSize = encodedSliverSize(unencodedLength, nShards, encodingType);
  const metadata = nShards * DIGEST_LEN * 2 + BLOB_ID_LEN;
  return nShards * metadata + sliverSize;
}
function encodedSliverSize(unencodedLength, nShards, encodingType = "RS2") {
  const { primarySymbols, secondarySymbols } = getSourceSymbols(nShards, encodingType);
  let symbolSize = Math.floor((Math.max(unencodedLength, 1) - 1) / (primarySymbols * secondarySymbols)) + 1;
  if (encodingType === "RS2" && symbolSize % 2 === 1) {
    symbolSize = symbolSize + 1;
  }
  const singleShardSize = (primarySymbols + secondarySymbols) * symbolSize;
  return singleShardSize * nShards;
}
function getSourceSymbols(nShards, encodingType = "RS2") {
  const safetyLimit = decodingSafetyLimit(nShards, encodingType);
  const maxFaulty = getMaxFaultyNodes(nShards);
  const minCorrect = nShards - maxFaulty;
  return {
    primarySymbols: minCorrect - maxFaulty - safetyLimit,
    secondarySymbols: minCorrect - safetyLimit
  };
}
function isQuorum(size, nShards) {
  const maxFaulty = getMaxFaultyNodes(nShards);
  return size > 2 * maxFaulty;
}
function isAboveValidity(size, nShards) {
  const maxFaulty = getMaxFaultyNodes(nShards);
  return size > maxFaulty;
}
function getMaxFaultyNodes(nShards) {
  return Math.floor((nShards - 1) / 3);
}
function decodingSafetyLimit(nShards, encodingType) {
  switch (encodingType) {
    case "RedStuff":
      return Math.min(5, Math.floor(getMaxFaultyNodes(nShards) / 5));
    case "RS2":
      return 0;
    default:
      throw new Error(`Encountered unknown encoding type of ${encodingType}`);
  }
}
const BYTES_PER_UNIT_SIZE = 1024 * 1024;
function storageUnitsFromSize(size) {
  return Math.ceil(size / BYTES_PER_UNIT_SIZE);
}
function rotationOffset(bytes, modulus) {
  return bytes.reduce((acc, byte) => (acc * 256 + byte) % modulus, 0);
}
function toShardIndex(sliverPairIndex, blobId, numShards) {
  const offset = rotationOffset(BlobId.serialize(blobId).toBytes(), numShards);
  return (sliverPairIndex + offset) % numShards;
}
function sliverPairIndexFromSecondarySliverIndex(sliverIndex, numShards) {
  return numShards - sliverIndex - 1;
}
function shardIndexFromSecondarySliverIndex(sliverIndex, blobId, numShards) {
  const sliverPairIndex = sliverPairIndexFromSecondarySliverIndex(sliverIndex, numShards);
  return toShardIndex(sliverPairIndex, blobId, numShards);
}
function toPairIndex(shardIndex, blobId, numShards) {
  const offset = rotationOffset(BlobId.serialize(blobId).toBytes(), numShards);
  return (numShards + shardIndex - offset) % numShards;
}
function signersToBitmap(signers, committeeSize) {
  const bitmapSize = Math.ceil(committeeSize / 8);
  const bitmap = new Uint8Array(bitmapSize);
  for (const signer of signers) {
    const byteIndex = Math.floor(signer / 8);
    const bitIndex = signer % 8;
    bitmap[byteIndex] |= 1 << bitIndex;
  }
  return bitmap;
}
function getShardIndicesByNodeId(committee) {
  const shardIndicesByNodeId = /* @__PURE__ */ new Map();
  for (const node of committee[0].contents) {
    if (!shardIndicesByNodeId.has(node.key)) {
      shardIndicesByNodeId.set(node.key, []);
    }
    shardIndicesByNodeId.get(node.key).push(...node.value);
  }
  return shardIndicesByNodeId;
}
function nodesByShardIndex(committee) {
  const nodesByShardIndex2 = /* @__PURE__ */ new Map();
  for (const node of committee[0].contents) {
    for (const shardIndex of node.value) {
      nodesByShardIndex2.set(shardIndex, node.key);
    }
  }
  return nodesByShardIndex2;
}
function toTypeString(type) {
  if (typeof type === "string") {
    switch (type) {
      case "Address":
        return "address";
      case "Bool":
        return "bool";
      case "U8":
        return "u8";
      case "U16":
        return "u16";
      case "U32":
        return "u32";
      case "U64":
        return "u64";
      case "U128":
        return "u128";
      case "U256":
        return "u256";
      default:
        throw new Error(`Unexpected type ${type}`);
    }
  }
  if ("Vector" in type) {
    return `vector<${toTypeString(type.Vector)}>`;
  }
  if ("Struct" in type) {
    if (type.Struct.typeArguments.length > 0) {
      return `${type.Struct.address}::${type.Struct.module}::${type.Struct.name}<${type.Struct.typeArguments.map(toTypeString).join(",")}>`;
    } else {
      return `${type.Struct.address}::${type.Struct.module}::${type.Struct.name}`;
    }
  }
  if ("TypeParameter" in type) {
    throw new Error(`Type parameters can't be converted to type strings`);
  }
  if ("Reference" in type) {
    return toTypeString(type.Reference);
  }
  if ("MutableReference" in type) {
    return toTypeString(type.MutableReference);
  }
  throw new Error(`Unexpected type ${JSON.stringify(type)}`);
}
function urlSafeBase64(bytes) {
  return toBase64(bytes).replace(/=*$/, "").replaceAll("+", "-").replaceAll("/", "_");
}
function fromUrlSafeBase64(base64) {
  return fromBase64(base64.replaceAll("-", "+").replaceAll("_", "/"));
}
function getSizes(blobSize, numShards) {
  const encodedBlobSize = encodedSliverSize(blobSize, numShards);
  const { primarySymbols, secondarySymbols } = getSourceSymbols(numShards);
  const totalSymbols = (primarySymbols + secondarySymbols) * numShards;
  if (encodedBlobSize % totalSymbols !== 0) {
    throw new Error("encoded blob size should be divisible by total symbols");
  }
  const symbolSize = encodedBlobSize / totalSymbols;
  if (encodedBlobSize % totalSymbols !== 0) {
    throw new Error("blob length should be divisible by total symbols");
  }
  const rowSize = symbolSize * secondarySymbols;
  const columnSize = symbolSize * primarySymbols;
  return {
    symbolSize,
    rowSize,
    columnSize,
    blobSize
  };
}
export {
  MAX_SYMBOL_SIZE_BY_ENCODING_TYPE,
  REQUIRED_ALIGNMENT_BY_ENCODING_TYPE,
  encodedBlobLength,
  encodedSliverSize,
  fromUrlSafeBase64,
  getMaxFaultyNodes,
  getShardIndicesByNodeId,
  getSizes,
  getSourceSymbols,
  isAboveValidity,
  isQuorum,
  nodesByShardIndex,
  shardIndexFromSecondarySliverIndex,
  signersToBitmap,
  sliverPairIndexFromSecondarySliverIndex,
  storageUnitsFromSize,
  toPairIndex,
  toShardIndex,
  toTypeString,
  urlSafeBase64
};
//# sourceMappingURL=index.js.map

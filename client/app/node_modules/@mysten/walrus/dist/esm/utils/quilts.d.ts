import type { EncodingType } from '../types.js';
import type { QuiltPatchV1 } from './bcs.js';
import { QuiltPatchId } from './bcs.js';
export declare const QUILT_INDEX_SIZE_BYTES_LENGTH = 4;
export declare const QUILT_VERSION_BYTES_LENGTH = 1;
export declare const QUILT_INDEX_PREFIX_SIZE: number;
export declare const QUILT_PATCH_BLOB_HEADER_SIZE: number;
export declare const BLOB_IDENTIFIER_SIZE_BYTES_LENGTH = 2;
export declare const TAGS_SIZE_BYTES_LENGTH = 2;
export declare const MAX_BLOB_IDENTIFIER_BYTES_LENGTH: number;
export declare const MAX_NUM_SLIVERS_FOR_QUILT_INDEX = 10;
export declare const HAS_TAGS_FLAG: number;
/**
 * Finds the minimum symbol size needed to store blobs in a fixed number of columns.
 * Each blob must be stored in consecutive columns exclusively.
 *
 * A binary search is used to find the minimum symbol size:
 * 1. Compute the upper and lower bounds for the symbol size.
 * 2. Check if the all the blobs can be fit into the quilt with the current symbol size.
 * 3. Adjust the bounds based on the result and repeat until the symbol size is found.
 *
 * @param blobsSizes - Slice of blob lengths, including the index size as the first element.
 *   Note that the len of the blob_size should be between 1 and n_columns.
 * @param nColumns - Number of columns available.
 * @param nRows - Number of rows available.
 * @param maxNumColumnsForQuiltIndex - The maximum number of columns that can be used to
 *   store the quilt index.
 * @param encodingType - The encoding type to use.
 *
 * @returns The minimum symbol size needed.
 **/
export declare function computeSymbolSize(blobsSizes: number[], nColumns: number, nRows: number, maxNumColumnsForQuiltIndex: number, encodingType?: EncodingType): number;
export declare function parseQuiltPatchId(id: string): {
    quiltId: string;
    patchId: {
        version: number;
        startIndex: number;
        endIndex: number;
    };
};
export declare function encodeQuiltPatchId(id: typeof QuiltPatchId.$inferInput): string;
export declare function parseWalrusId(id: string): {
    kind: "blob";
    id: string;
} | {
    kind: "quiltPatch";
    id: {
        quiltId: string;
        patchId: {
            version: number;
            startIndex: number;
            endIndex: number;
        };
    };
};
export interface EncodeQuiltOptions {
    blobs: {
        contents: Uint8Array;
        identifier: string;
        tags?: Record<string, string>;
    }[];
    numShards: number;
    encodingType?: EncodingType;
}
export declare function encodeQuilt({ blobs, numShards, encodingType }: EncodeQuiltOptions): {
    quilt: Uint8Array<ArrayBuffer>;
    index: {
        patches: (typeof QuiltPatchV1.$inferInput & {
            startIndex: number;
        })[];
    };
};

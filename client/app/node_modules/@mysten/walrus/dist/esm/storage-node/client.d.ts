import type { GetBlobMetadataRequestInput, GetBlobMetadataResponse, GetBlobStatusRequestInput, GetBlobStatusResponse, GetDeletableBlobConfirmationRequestInput, GetDeletableBlobConfirmationResponse, GetPermanentBlobConfirmationRequestInput, GetPermanentBlobConfirmationResponse, GetSliverRequestInput, GetSliverResponse, StoreBlobMetadataRequestInput, StoreBlobMetadataResponse, StoreSliverRequestInput, StoreSliverResponse } from './types.js';
import { mergeHeaders } from './utils.js';
export type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;
export type StorageNodeClientOptions = {
    /**
     * An optional custom fetch function.
     *
     * If not provided, defaults to the global `fetch` function (`globalThis.fetch`).
     *
     * @default globalThis.fetch
     */
    fetch?: Fetch;
    /**
     * An optional timeout for requests.
     * @default 30_000ms (30 seconds)
     */
    timeout?: number;
    /**
     * Callback for individual network errors.
     */
    onError?: (error: Error) => void;
};
export type RequestOptions = {
    nodeUrl: string;
    timeout?: number;
    headers?: ReturnType<typeof mergeHeaders>;
} & Omit<RequestInit, 'headers'>;
export declare class StorageNodeClient {
    #private;
    constructor({ fetch: overriddenFetch, timeout, onError }?: StorageNodeClientOptions);
    /**
     * Gets the metadata associated with a Walrus blob.
     */
    getBlobMetadata({ blobId }: GetBlobMetadataRequestInput, options: RequestOptions): Promise<GetBlobMetadataResponse>;
    /**
     * Gets the status associated with a Walrus blob.
     */
    getBlobStatus({ blobId }: GetBlobStatusRequestInput, options: RequestOptions): Promise<GetBlobStatusResponse>;
    /**
     * Stores the metadata associated with a registered Walrus blob at this storage
     * node. This is a pre-requisite for storing the encoded slivers of the blob. The
     * ID of the blob must first be registered on Sui, after which storing the metadata
     * becomes possible.
     *
     * This endpoint may return an error if the node has not yet received the
     * registration event from the chain.
     */
    storeBlobMetadata({ blobId, metadata }: StoreBlobMetadataRequestInput, options: RequestOptions): Promise<StoreBlobMetadataResponse>;
    /**
     * Gets the primary or secondary sliver identified by the specified blob ID and
     * index. The index should represent a sliver that is assigned to be stored at one
     * of the shards managed by this storage node during this epoch.
     */
    getSliver({ blobId, sliverPairIndex, sliverType }: GetSliverRequestInput, options: RequestOptions): Promise<GetSliverResponse>;
    /**
     * Stores a primary or secondary blob sliver at the storage node.
     */
    storeSliver({ blobId, sliverPairIndex, sliverType, sliver }: StoreSliverRequestInput, options: RequestOptions): Promise<StoreSliverResponse>;
    /**
     * Gets a signed storage confirmation from this storage node, indicating that all shards
     * assigned to this storage node for the current epoch have stored their respective slivers.
     */
    getDeletableBlobConfirmation({ blobId, objectId }: GetDeletableBlobConfirmationRequestInput, options: RequestOptions): Promise<GetDeletableBlobConfirmationResponse>;
    /**
     * Gets a signed storage confirmation from this storage node, indicating that all shards
     * assigned to this storage node for the current epoch have stored their respective slivers.
     */
    getPermanentBlobConfirmation({ blobId }: GetPermanentBlobConfirmationRequestInput, options: RequestOptions): Promise<GetPermanentBlobConfirmationResponse>;
}

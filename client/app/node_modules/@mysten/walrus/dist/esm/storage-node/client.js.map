{
  "version": 3,
  "sources": ["../../../src/storage-node/client.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { BlobMetadata, BlobMetadataWithId, SliverData } from '../utils/bcs.js';\nimport {\n\tConnectionTimeoutError,\n\tStorageNodeAPIError,\n\tStorageNodeError,\n\tUserAbortError,\n} from './error.js';\nimport type {\n\tGetBlobMetadataRequestInput,\n\tGetBlobMetadataResponse,\n\tGetBlobStatusRequestInput,\n\tGetBlobStatusResponse,\n\tGetDeletableBlobConfirmationRequestInput,\n\tGetDeletableBlobConfirmationResponse,\n\tGetPermanentBlobConfirmationRequestInput,\n\tGetPermanentBlobConfirmationResponse,\n\tGetSliverRequestInput,\n\tGetSliverResponse,\n\tRawGetBlobStatusResponse,\n\tStoreBlobMetadataRequestInput,\n\tStoreBlobMetadataResponse,\n\tStoreSliverRequestInput,\n\tStoreSliverResponse,\n} from './types.js';\nimport { mergeHeaders } from './utils.js';\n\nexport type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;\n\nexport type StorageNodeClientOptions = {\n\t/**\n\t * An optional custom fetch function.\n\t *\n\t * If not provided, defaults to the global `fetch` function (`globalThis.fetch`).\n\t *\n\t * @default globalThis.fetch\n\t */\n\tfetch?: Fetch;\n\n\t/**\n\t * An optional timeout for requests.\n\t * @default 30_000ms (30 seconds)\n\t */\n\ttimeout?: number;\n\n\t/**\n\t * Callback for individual network errors.\n\t */\n\tonError?: (error: Error) => void;\n};\n\nexport type RequestOptions = {\n\tnodeUrl: string;\n\ttimeout?: number;\n\theaders?: ReturnType<typeof mergeHeaders>;\n} & Omit<RequestInit, 'headers'>;\n\nexport class StorageNodeClient {\n\t#fetch: Fetch;\n\t#timeout: number;\n\t#onError?: (error: Error) => void;\n\tconstructor({ fetch: overriddenFetch, timeout, onError }: StorageNodeClientOptions = {}) {\n\t\tthis.#fetch = overriddenFetch ?? globalThis.fetch;\n\t\tthis.#timeout = timeout ?? 30_000;\n\t\tthis.#onError = onError;\n\t}\n\n\t/**\n\t * Gets the metadata associated with a Walrus blob.\n\t */\n\tasync getBlobMetadata(\n\t\t{ blobId }: GetBlobMetadataRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetBlobMetadataResponse> {\n\t\tconst response = await this.#request(`/v1/blobs/${blobId}/metadata`, {\n\t\t\t...options,\n\t\t\theaders: mergeHeaders({ Accept: 'application/octet-stream' }, options.headers),\n\t\t});\n\n\t\tconst bcsBytes = await response.arrayBuffer();\n\t\treturn BlobMetadataWithId.parse(new Uint8Array(bcsBytes));\n\t}\n\n\t/**\n\t * Gets the status associated with a Walrus blob.\n\t */\n\tasync getBlobStatus(\n\t\t{ blobId }: GetBlobStatusRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetBlobStatusResponse> {\n\t\tconst response = await this.#request(`/v1/blobs/${blobId}/status`, options);\n\n\t\tconst json: RawGetBlobStatusResponse = await response.json();\n\t\tconst blobStatus = json.success.data;\n\n\t\tif (blobStatus === 'nonexistent') {\n\t\t\treturn { type: 'nonexistent' };\n\t\t}\n\n\t\tif ('invalid' in blobStatus) {\n\t\t\treturn {\n\t\t\t\ttype: 'invalid',\n\t\t\t\t...blobStatus.invalid,\n\t\t\t};\n\t\t}\n\n\t\tif ('permanent' in blobStatus) {\n\t\t\treturn {\n\t\t\t\ttype: 'permanent',\n\t\t\t\t...blobStatus.permanent,\n\t\t\t};\n\t\t}\n\n\t\tif ('deletable' in blobStatus) {\n\t\t\treturn {\n\t\t\t\ttype: 'deletable',\n\t\t\t\t...blobStatus.deletable,\n\t\t\t};\n\t\t}\n\n\t\tthrow new StorageNodeError(`Unknown blob status received: ${blobStatus}`);\n\t}\n\n\t/**\n\t * Stores the metadata associated with a registered Walrus blob at this storage\n\t * node. This is a pre-requisite for storing the encoded slivers of the blob. The\n\t * ID of the blob must first be registered on Sui, after which storing the metadata\n\t * becomes possible.\n\t *\n\t * This endpoint may return an error if the node has not yet received the\n\t * registration event from the chain.\n\t */\n\tasync storeBlobMetadata(\n\t\t{ blobId, metadata }: StoreBlobMetadataRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<StoreBlobMetadataResponse> {\n\t\tconst isBcsInput = typeof metadata === 'object' && 'V1' in metadata;\n\t\tconst body = isBcsInput ? BlobMetadata.serialize(metadata).toBytes() : metadata;\n\n\t\tconst response = await this.#request(`/v1/blobs/${blobId}/metadata`, {\n\t\t\t...options,\n\t\t\tmethod: 'PUT',\n\t\t\tbody: body as Uint8Array<ArrayBuffer>,\n\t\t\theaders: mergeHeaders({ 'Content-Type': 'application/octet-stream' }, options.headers),\n\t\t});\n\n\t\tconst json: StoreBlobMetadataResponse = await response.json();\n\t\treturn json;\n\t}\n\n\t/**\n\t * Gets the primary or secondary sliver identified by the specified blob ID and\n\t * index. The index should represent a sliver that is assigned to be stored at one\n\t * of the shards managed by this storage node during this epoch.\n\t */\n\tasync getSliver(\n\t\t{ blobId, sliverPairIndex, sliverType }: GetSliverRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetSliverResponse> {\n\t\tconst response = await this.#request(\n\t\t\t`/v1/blobs/${blobId}/slivers/${sliverPairIndex}/${sliverType}`,\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\theaders: mergeHeaders({ Accept: 'application/octet-stream' }, options.headers),\n\t\t\t},\n\t\t);\n\n\t\tconst bcsBytes = await response.arrayBuffer();\n\t\treturn SliverData.parse(new Uint8Array(bcsBytes));\n\t}\n\n\t/**\n\t * Stores a primary or secondary blob sliver at the storage node.\n\t */\n\tasync storeSliver(\n\t\t{ blobId, sliverPairIndex, sliverType, sliver }: StoreSliverRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<StoreSliverResponse> {\n\t\tconst isBcsInput = typeof sliver === 'object' && 'symbols' in sliver;\n\t\tconst body = isBcsInput ? SliverData.serialize(sliver).toBytes() : sliver;\n\n\t\tconst response = await this.#request(\n\t\t\t`/v1/blobs/${blobId}/slivers/${sliverPairIndex}/${sliverType}`,\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\tmethod: 'PUT',\n\t\t\t\tbody: body as Uint8Array<ArrayBuffer>,\n\t\t\t\theaders: mergeHeaders({ 'Content-Type': 'application/octet-stream' }, options.headers),\n\t\t\t},\n\t\t);\n\n\t\tconst json: StoreSliverResponse = await response.json();\n\t\treturn json;\n\t}\n\n\t/**\n\t * Gets a signed storage confirmation from this storage node, indicating that all shards\n\t * assigned to this storage node for the current epoch have stored their respective slivers.\n\t */\n\tasync getDeletableBlobConfirmation(\n\t\t{ blobId, objectId }: GetDeletableBlobConfirmationRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetDeletableBlobConfirmationResponse> {\n\t\tconst response = await this.#request(\n\t\t\t`/v1/blobs/${blobId}/confirmation/deletable/${objectId}`,\n\t\t\toptions,\n\t\t);\n\n\t\tconst json: GetDeletableBlobConfirmationResponse = await response.json();\n\t\treturn json;\n\t}\n\n\t/**\n\t * Gets a signed storage confirmation from this storage node, indicating that all shards\n\t * assigned to this storage node for the current epoch have stored their respective slivers.\n\t */\n\tasync getPermanentBlobConfirmation(\n\t\t{ blobId }: GetPermanentBlobConfirmationRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetPermanentBlobConfirmationResponse> {\n\t\tconst response = await this.#request(`/v1/blobs/${blobId}/confirmation/permanent`, options);\n\n\t\tconst json: GetPermanentBlobConfirmationResponse = await response.json();\n\t\treturn json;\n\t}\n\n\tasync #request(path: string, options: RequestOptions) {\n\t\tconst { nodeUrl, signal, timeout, ...init } = options;\n\n\t\tif (signal?.aborted) {\n\t\t\tthrow new UserAbortError();\n\t\t}\n\n\t\tconst timeoutSignal = AbortSignal.timeout(timeout ?? this.#timeout);\n\n\t\tlet response: Response | undefined;\n\n\t\ttry {\n\t\t\tresponse = await (0, this.#fetch)(`${nodeUrl}${path}`, {\n\t\t\t\t...init,\n\t\t\t\tsignal: signal ? AbortSignal.any([timeoutSignal, signal]) : timeoutSignal,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (signal?.aborted) {\n\t\t\t\tthrow new UserAbortError();\n\t\t\t}\n\n\t\t\tif (error instanceof Error && error.name === 'AbortError') {\n\t\t\t\tconst error = new ConnectionTimeoutError();\n\t\t\t\tthis.#onError?.(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tthis.#onError?.(error as Error);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!response.ok) {\n\t\t\tconst errorText = await response.text().catch((reason) => reason);\n\t\t\tconst errorJSON = safeParseJSON(errorText);\n\t\t\tconst errorMessage = errorJSON ? undefined : errorText;\n\t\t\tconst error = StorageNodeAPIError.generate(response.status, errorJSON, errorMessage);\n\t\t\tthis.#onError?.(error);\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn response;\n\t}\n}\n\nfunction safeParseJSON(value: string) {\n\ttry {\n\t\treturn JSON.parse(value);\n\t} catch {\n\t\treturn undefined;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["error"]
}

/**
 * Module to manage Walrus contract upgrades.
 *
 * This allows upgrading the contract with a quorum of storage nodes or using an
 * emergency upgrade capability.
 *
 * Requiring a quorum instead of a simple majority guarantees that (i) a majority
 * of honest nodes (by weight) have voted for the upgrade, and (ii) that an upgrade
 * cannot be blocked solely by byzantine nodes.
 */
import { MoveTuple, MoveStruct } from '../utils/index.js';
import type { RawTransactionArgument } from '../utils/index.js';
import type { Transaction } from '@mysten/sui/transactions';
export declare const PackageDigest: MoveTuple<import("@mysten/sui/bcs").BcsType<number[], Iterable<number> & {
    length: number;
}, string>[], "@local-pkg/walrus::upgrade::PackageDigest">;
export declare const UpgradeProposal: MoveStruct<{
    /**
     * The epoch in which the proposal was created. The upgrade must be performed in
     * the same epoch.
     */
    epoch: import("@mysten/sui/bcs").BcsType<number, number, "u32">;
    /** The digest of the package to upgrade to. */
    digest: MoveTuple<import("@mysten/sui/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>[], "@local-pkg/walrus::upgrade::PackageDigest">;
    /**
     * The version of the package to upgrade to. This allows to easily clean up old
     * proposals.
     */
    version: import("@mysten/sui/bcs").BcsType<string, string | number | bigint, "u64">;
    /** The voting weight of the proposal. */
    voting_weight: import("@mysten/sui/bcs").BcsType<number, number, "u16">;
    /**
     * The node IDs that have voted for this proposal. Note: the number of nodes in the
     * committee is capped, so we can use a VecSet.
     */
    voters: MoveStruct<{
        contents: import("@mysten/sui/bcs").BcsType<string[], Iterable<string | Uint8Array<ArrayBufferLike>> & {
            length: number;
        }, string>;
    }, "0x2::vec_set::VecSet<bytes[32]>">;
}, "@local-pkg/walrus::upgrade::UpgradeProposal">;
export declare const UpgradeManager: MoveStruct<{
    id: MoveStruct<{
        id: import("@mysten/sui/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    cap: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/sui/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        package: import("@mysten/sui/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        version: import("@mysten/sui/bcs").BcsType<string, string | number | bigint, "u64">;
        policy: import("@mysten/sui/bcs").BcsType<number, number, "u8">;
    }, "0x2::package::UpgradeCap">;
    upgrade_proposals: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/sui/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        size: import("@mysten/sui/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "0x2::table::Table">;
}, "@local-pkg/walrus::upgrade::UpgradeManager">;
export declare const EmergencyUpgradeCap: MoveStruct<{
    id: MoveStruct<{
        id: import("@mysten/sui/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    upgrade_manager_id: import("@mysten/sui/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/walrus::upgrade::EmergencyUpgradeCap">;
export interface VoteForUpgradeArguments {
    self: RawTransactionArgument<string>;
    staking: RawTransactionArgument<string>;
    auth: RawTransactionArgument<string>;
    nodeId: RawTransactionArgument<string>;
    digest: RawTransactionArgument<number[]>;
}
export interface VoteForUpgradeOptions {
    package?: string;
    arguments: VoteForUpgradeArguments | [
        self: RawTransactionArgument<string>,
        staking: RawTransactionArgument<string>,
        auth: RawTransactionArgument<string>,
        nodeId: RawTransactionArgument<string>,
        digest: RawTransactionArgument<number[]>
    ];
}
/**
 * Vote for an upgrade given the digest of the package to upgrade to.
 *
 * This will create a new upgrade proposal if none exists for the given digest.
 */
export declare function voteForUpgrade(options: VoteForUpgradeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AuthorizeUpgradeArguments {
    self: RawTransactionArgument<string>;
    staking: RawTransactionArgument<string>;
    digest: RawTransactionArgument<number[]>;
}
export interface AuthorizeUpgradeOptions {
    package?: string;
    arguments: AuthorizeUpgradeArguments | [
        self: RawTransactionArgument<string>,
        staking: RawTransactionArgument<string>,
        digest: RawTransactionArgument<number[]>
    ];
}
/** Authorizes an upgrade that has reached quorum. */
export declare function authorizeUpgrade(options: AuthorizeUpgradeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AuthorizeEmergencyUpgradeArguments {
    upgradeManager: RawTransactionArgument<string>;
    emergencyUpgradeCap: RawTransactionArgument<string>;
    digest: RawTransactionArgument<number[]>;
}
export interface AuthorizeEmergencyUpgradeOptions {
    package?: string;
    arguments: AuthorizeEmergencyUpgradeArguments | [
        upgradeManager: RawTransactionArgument<string>,
        emergencyUpgradeCap: RawTransactionArgument<string>,
        digest: RawTransactionArgument<number[]>
    ];
}
/**
 * Authorizes an upgrade using the emergency upgrade cap.
 *
 * This should be used sparingly and once walrus has a healthy community and
 * governance, the EmergencyUpgradeCap should be burned.
 */
export declare function authorizeEmergencyUpgrade(options: AuthorizeEmergencyUpgradeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CommitUpgradeArguments {
    upgradeManager: RawTransactionArgument<string>;
    staking: RawTransactionArgument<string>;
    system: RawTransactionArgument<string>;
    receipt: RawTransactionArgument<string>;
}
export interface CommitUpgradeOptions {
    package?: string;
    arguments: CommitUpgradeArguments | [
        upgradeManager: RawTransactionArgument<string>,
        staking: RawTransactionArgument<string>,
        system: RawTransactionArgument<string>,
        receipt: RawTransactionArgument<string>
    ];
}
/**
 * Commits an upgrade and sets the new package id in the staking and system
 * objects.
 *
 * After committing an upgrade, the staking and system objects should be migrated
 * using the [`package::migrate`] function to emit an event that informs all
 * storage nodes and prevent previous package versions from being used.
 */
export declare function commitUpgrade(options: CommitUpgradeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CleanupUpgradeProposalsArguments {
    self: RawTransactionArgument<string>;
    staking: RawTransactionArgument<string>;
    proposals: RawTransactionArgument<number[][]>;
}
export interface CleanupUpgradeProposalsOptions {
    package?: string;
    arguments: CleanupUpgradeProposalsArguments | [
        self: RawTransactionArgument<string>,
        staking: RawTransactionArgument<string>,
        proposals: RawTransactionArgument<number[][]>
    ];
}
/**
 * Cleans up the upgrade proposals table.
 *
 * Deletes all proposals from past epochs and versions that are lower than the
 * current version.
 */
export declare function cleanupUpgradeProposals(options: CleanupUpgradeProposalsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface BurnEmergencyUpgradeCapArguments {
    emergencyUpgradeCap: RawTransactionArgument<string>;
}
export interface BurnEmergencyUpgradeCapOptions {
    package?: string;
    arguments: BurnEmergencyUpgradeCapArguments | [emergencyUpgradeCap: RawTransactionArgument<string>];
}
/**
 * Burns the emergency upgrade cap.
 *
 * This will prevent any further upgrades using the `EmergencyUpgradeCap` and will
 * make upgrades fully reliant on quorum-based governance.
 */
export declare function burnEmergencyUpgradeCap(options: BurnEmergencyUpgradeCapOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;

{
  "version": 3,
  "sources": ["../../../../src/contracts/walrus/upgrade.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Module to manage Walrus contract upgrades.\n *\n * This allows upgrading the contract with a quorum of storage nodes or using an\n * emergency upgrade capability.\n *\n * Requiring a quorum instead of a simple majority guarantees that (i) a majority\n * of honest nodes (by weight) have voted for the upgrade, and (ii) that an upgrade\n * cannot be blocked solely by byzantine nodes.\n */\n\nimport { MoveTuple, MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as vec_set from './deps/sui/vec_set.js';\nimport * as object from './deps/sui/object.js';\nimport * as _package from './deps/sui/package.js';\nimport * as table from './deps/sui/table.js';\nconst $moduleName = '@local-pkg/walrus::upgrade';\nexport const PackageDigest = new MoveTuple({\n\tname: `${$moduleName}::PackageDigest`,\n\tfields: [bcs.vector(bcs.u8())],\n});\nexport const UpgradeProposal = new MoveStruct({\n\tname: `${$moduleName}::UpgradeProposal`,\n\tfields: {\n\t\t/**\n\t\t * The epoch in which the proposal was created. The upgrade must be performed in\n\t\t * the same epoch.\n\t\t */\n\t\tepoch: bcs.u32(),\n\t\t/** The digest of the package to upgrade to. */\n\t\tdigest: PackageDigest,\n\t\t/**\n\t\t * The version of the package to upgrade to. This allows to easily clean up old\n\t\t * proposals.\n\t\t */\n\t\tversion: bcs.u64(),\n\t\t/** The voting weight of the proposal. */\n\t\tvoting_weight: bcs.u16(),\n\t\t/**\n\t\t * The node IDs that have voted for this proposal. Note: the number of nodes in the\n\t\t * committee is capped, so we can use a VecSet.\n\t\t */\n\t\tvoters: vec_set.VecSet(bcs.Address),\n\t},\n});\nexport const UpgradeManager = new MoveStruct({\n\tname: `${$moduleName}::UpgradeManager`,\n\tfields: {\n\t\tid: object.UID,\n\t\tcap: _package.UpgradeCap,\n\t\tupgrade_proposals: table.Table,\n\t},\n});\nexport const EmergencyUpgradeCap = new MoveStruct({\n\tname: `${$moduleName}::EmergencyUpgradeCap`,\n\tfields: {\n\t\tid: object.UID,\n\t\tupgrade_manager_id: bcs.Address,\n\t},\n});\nexport interface VoteForUpgradeArguments {\n\tself: RawTransactionArgument<string>;\n\tstaking: RawTransactionArgument<string>;\n\tauth: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n\tdigest: RawTransactionArgument<number[]>;\n}\nexport interface VoteForUpgradeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| VoteForUpgradeArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tauth: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t\t\tdigest: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/**\n * Vote for an upgrade given the digest of the package to upgrade to.\n *\n * This will create a new upgrade proposal if none exists for the given digest.\n */\nexport function voteForUpgrade(options: VoteForUpgradeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::upgrade::UpgradeManager`,\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::auth::Authenticated`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'staking', 'auth', 'nodeId', 'digest'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'upgrade',\n\t\t\tfunction: 'vote_for_upgrade',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AuthorizeUpgradeArguments {\n\tself: RawTransactionArgument<string>;\n\tstaking: RawTransactionArgument<string>;\n\tdigest: RawTransactionArgument<number[]>;\n}\nexport interface AuthorizeUpgradeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AuthorizeUpgradeArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tdigest: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Authorizes an upgrade that has reached quorum. */\nexport function authorizeUpgrade(options: AuthorizeUpgradeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::upgrade::UpgradeManager`,\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'staking', 'digest'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'upgrade',\n\t\t\tfunction: 'authorize_upgrade',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AuthorizeEmergencyUpgradeArguments {\n\tupgradeManager: RawTransactionArgument<string>;\n\temergencyUpgradeCap: RawTransactionArgument<string>;\n\tdigest: RawTransactionArgument<number[]>;\n}\nexport interface AuthorizeEmergencyUpgradeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AuthorizeEmergencyUpgradeArguments\n\t\t| [\n\t\t\t\tupgradeManager: RawTransactionArgument<string>,\n\t\t\t\temergencyUpgradeCap: RawTransactionArgument<string>,\n\t\t\t\tdigest: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/**\n * Authorizes an upgrade using the emergency upgrade cap.\n *\n * This should be used sparingly and once walrus has a healthy community and\n * governance, the EmergencyUpgradeCap should be burned.\n */\nexport function authorizeEmergencyUpgrade(options: AuthorizeEmergencyUpgradeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::upgrade::UpgradeManager`,\n\t\t`${packageAddress}::upgrade::EmergencyUpgradeCap`,\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['upgradeManager', 'emergencyUpgradeCap', 'digest'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'upgrade',\n\t\t\tfunction: 'authorize_emergency_upgrade',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CommitUpgradeArguments {\n\tupgradeManager: RawTransactionArgument<string>;\n\tstaking: RawTransactionArgument<string>;\n\tsystem: RawTransactionArgument<string>;\n\treceipt: RawTransactionArgument<string>;\n}\nexport interface CommitUpgradeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CommitUpgradeArguments\n\t\t| [\n\t\t\t\tupgradeManager: RawTransactionArgument<string>,\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tsystem: RawTransactionArgument<string>,\n\t\t\t\treceipt: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Commits an upgrade and sets the new package id in the staking and system\n * objects.\n *\n * After committing an upgrade, the staking and system objects should be migrated\n * using the [`package::migrate`] function to emit an event that informs all\n * storage nodes and prevent previous package versions from being used.\n */\nexport function commitUpgrade(options: CommitUpgradeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::upgrade::UpgradeManager`,\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::system::System`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::package::UpgradeReceipt',\n\t] satisfies string[];\n\tconst parameterNames = ['upgradeManager', 'staking', 'system', 'receipt'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'upgrade',\n\t\t\tfunction: 'commit_upgrade',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CleanupUpgradeProposalsArguments {\n\tself: RawTransactionArgument<string>;\n\tstaking: RawTransactionArgument<string>;\n\tproposals: RawTransactionArgument<number[][]>;\n}\nexport interface CleanupUpgradeProposalsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CleanupUpgradeProposalsArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tproposals: RawTransactionArgument<number[][]>,\n\t\t  ];\n}\n/**\n * Cleans up the upgrade proposals table.\n *\n * Deletes all proposals from past epochs and versions that are lower than the\n * current version.\n */\nexport function cleanupUpgradeProposals(options: CleanupUpgradeProposalsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::upgrade::UpgradeManager`,\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'vector<vector<u8>>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'staking', 'proposals'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'upgrade',\n\t\t\tfunction: 'cleanup_upgrade_proposals',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface BurnEmergencyUpgradeCapArguments {\n\temergencyUpgradeCap: RawTransactionArgument<string>;\n}\nexport interface BurnEmergencyUpgradeCapOptions {\n\tpackage?: string;\n\targuments:\n\t\t| BurnEmergencyUpgradeCapArguments\n\t\t| [emergencyUpgradeCap: RawTransactionArgument<string>];\n}\n/**\n * Burns the emergency upgrade cap.\n *\n * This will prevent any further upgrades using the `EmergencyUpgradeCap` and will\n * make upgrades fully reliant on quorum-based governance.\n */\nexport function burnEmergencyUpgradeCap(options: BurnEmergencyUpgradeCapOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::upgrade::EmergencyUpgradeCap`] satisfies string[];\n\tconst parameterNames = ['emergencyUpgradeCap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'upgrade',\n\t\t\tfunction: 'burn_emergency_upgrade_cap',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n"],
  "mappings": "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",
  "names": []
}

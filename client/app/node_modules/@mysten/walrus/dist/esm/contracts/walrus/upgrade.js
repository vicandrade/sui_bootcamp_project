import { MoveTuple, MoveStruct, normalizeMoveArguments } from "../utils/index.js";
import { bcs } from "@mysten/sui/bcs";
import * as vec_set from "./deps/sui/vec_set.js";
import * as object from "./deps/sui/object.js";
import * as _package from "./deps/sui/package.js";
import * as table from "./deps/sui/table.js";
const $moduleName = "@local-pkg/walrus::upgrade";
const PackageDigest = new MoveTuple({
  name: `${$moduleName}::PackageDigest`,
  fields: [bcs.vector(bcs.u8())]
});
const UpgradeProposal = new MoveStruct({
  name: `${$moduleName}::UpgradeProposal`,
  fields: {
    /**
     * The epoch in which the proposal was created. The upgrade must be performed in
     * the same epoch.
     */
    epoch: bcs.u32(),
    /** The digest of the package to upgrade to. */
    digest: PackageDigest,
    /**
     * The version of the package to upgrade to. This allows to easily clean up old
     * proposals.
     */
    version: bcs.u64(),
    /** The voting weight of the proposal. */
    voting_weight: bcs.u16(),
    /**
     * The node IDs that have voted for this proposal. Note: the number of nodes in the
     * committee is capped, so we can use a VecSet.
     */
    voters: vec_set.VecSet(bcs.Address)
  }
});
const UpgradeManager = new MoveStruct({
  name: `${$moduleName}::UpgradeManager`,
  fields: {
    id: object.UID,
    cap: _package.UpgradeCap,
    upgrade_proposals: table.Table
  }
});
const EmergencyUpgradeCap = new MoveStruct({
  name: `${$moduleName}::EmergencyUpgradeCap`,
  fields: {
    id: object.UID,
    upgrade_manager_id: bcs.Address
  }
});
function voteForUpgrade(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [
    `${packageAddress}::upgrade::UpgradeManager`,
    `${packageAddress}::staking::Staking`,
    `${packageAddress}::auth::Authenticated`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID",
    "vector<u8>"
  ];
  const parameterNames = ["self", "staking", "auth", "nodeId", "digest"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "upgrade",
    function: "vote_for_upgrade",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function authorizeUpgrade(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [
    `${packageAddress}::upgrade::UpgradeManager`,
    `${packageAddress}::staking::Staking`,
    "vector<u8>"
  ];
  const parameterNames = ["self", "staking", "digest"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "upgrade",
    function: "authorize_upgrade",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function authorizeEmergencyUpgrade(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [
    `${packageAddress}::upgrade::UpgradeManager`,
    `${packageAddress}::upgrade::EmergencyUpgradeCap`,
    "vector<u8>"
  ];
  const parameterNames = ["upgradeManager", "emergencyUpgradeCap", "digest"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "upgrade",
    function: "authorize_emergency_upgrade",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function commitUpgrade(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [
    `${packageAddress}::upgrade::UpgradeManager`,
    `${packageAddress}::staking::Staking`,
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::package::UpgradeReceipt"
  ];
  const parameterNames = ["upgradeManager", "staking", "system", "receipt"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "upgrade",
    function: "commit_upgrade",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function cleanupUpgradeProposals(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [
    `${packageAddress}::upgrade::UpgradeManager`,
    `${packageAddress}::staking::Staking`,
    "vector<vector<u8>>"
  ];
  const parameterNames = ["self", "staking", "proposals"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "upgrade",
    function: "cleanup_upgrade_proposals",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function burnEmergencyUpgradeCap(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [`${packageAddress}::upgrade::EmergencyUpgradeCap`];
  const parameterNames = ["emergencyUpgradeCap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "upgrade",
    function: "burn_emergency_upgrade_cap",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
export {
  EmergencyUpgradeCap,
  PackageDigest,
  UpgradeManager,
  UpgradeProposal,
  authorizeEmergencyUpgrade,
  authorizeUpgrade,
  burnEmergencyUpgradeCap,
  cleanupUpgradeProposals,
  commitUpgrade,
  voteForUpgrade
};
//# sourceMappingURL=upgrade.js.map

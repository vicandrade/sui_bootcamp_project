import { MoveStruct, normalizeMoveArguments } from "../utils/index.js";
import { bcs } from "@mysten/sui/bcs";
import * as group_ops from "./deps/sui/group_ops.js";
import * as extended_field from "./extended_field.js";
import * as object from "./deps/sui/object.js";
import * as event_blob from "./event_blob.js";
const $moduleName = "@local-pkg/walrus::storage_node";
const StorageNodeInfo = new MoveStruct({
  name: `${$moduleName}::StorageNodeInfo`,
  fields: {
    name: bcs.string(),
    node_id: bcs.Address,
    network_address: bcs.string(),
    public_key: group_ops.Element,
    next_epoch_public_key: bcs.option(group_ops.Element),
    network_public_key: bcs.vector(bcs.u8()),
    metadata: extended_field.ExtendedField
  }
});
const StorageNodeCap = new MoveStruct({
  name: `${$moduleName}::StorageNodeCap`,
  fields: {
    id: object.UID,
    node_id: bcs.Address,
    last_epoch_sync_done: bcs.u32(),
    last_event_blob_attestation: bcs.option(event_blob.EventBlobAttestation),
    /** Stores the Merkle root of the deny list for the storage node. */
    deny_list_root: bcs.u256(),
    /** Stores the sequence number of the deny list for the storage node. */
    deny_list_sequence: bcs.u64(),
    /** Stores the size of the deny list for the storage node. */
    deny_list_size: bcs.u64()
  }
});
function id(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [`${packageAddress}::storage_node::StorageNodeInfo`];
  const parameterNames = ["cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "storage_node",
    function: "id",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function nodeId(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`];
  const parameterNames = ["cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "storage_node",
    function: "node_id",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function lastEpochSyncDone(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`];
  const parameterNames = ["cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "storage_node",
    function: "last_epoch_sync_done",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function lastEventBlobAttestation(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`];
  const parameterNames = ["cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "storage_node",
    function: "last_event_blob_attestation",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function denyListRoot(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`];
  const parameterNames = ["cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "storage_node",
    function: "deny_list_root",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function denyListSequence(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`];
  const parameterNames = ["cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "storage_node",
    function: "deny_list_sequence",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
export {
  StorageNodeCap,
  StorageNodeInfo,
  denyListRoot,
  denyListSequence,
  id,
  lastEpochSyncDone,
  lastEventBlobAttestation,
  nodeId
};
//# sourceMappingURL=storage_node.js.map

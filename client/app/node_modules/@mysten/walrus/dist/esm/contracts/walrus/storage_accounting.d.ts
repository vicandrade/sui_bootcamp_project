import { MoveStruct } from '../utils/index.js';
import type { RawTransactionArgument } from '../utils/index.js';
import type { Transaction } from '@mysten/sui/transactions';
export declare const FutureAccounting: MoveStruct<{
    epoch: import("@mysten/sui/bcs").BcsType<number, number, "u32">;
    /**
     * This field stores `used_capacity` for the epoch. Currently, impossible to rename
     * due to package upgrade limitations.
     */
    used_capacity: import("@mysten/sui/bcs").BcsType<string, string | number | bigint, "u64">;
    rewards_to_distribute: MoveStruct<{
        value: import("@mysten/sui/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "0x2::balance::Balance">;
}, "@local-pkg/walrus::storage_accounting::FutureAccounting">;
export declare const FutureAccountingRingBuffer: MoveStruct<{
    current_index: import("@mysten/sui/bcs").BcsType<number, number, "u32">;
    length: import("@mysten/sui/bcs").BcsType<number, number, "u32">;
    ring_buffer: import("@mysten/sui/bcs").BcsType<{
        epoch: number;
        used_capacity: string;
        rewards_to_distribute: {
            value: string;
        };
    }[], Iterable<{
        epoch: number;
        used_capacity: string | number | bigint;
        rewards_to_distribute: {
            value: string | number | bigint;
        };
    }> & {
        length: number;
    }, string>;
}, "@local-pkg/walrus::storage_accounting::FutureAccountingRingBuffer">;
export interface MaxEpochsAheadArguments {
    self: RawTransactionArgument<string>;
}
export interface MaxEpochsAheadOptions {
    package?: string;
    arguments: MaxEpochsAheadArguments | [self: RawTransactionArgument<string>];
}
/** The maximum number of epochs for which we can use `self`. */
export declare function maxEpochsAhead(options: MaxEpochsAheadOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RingLookupArguments {
    self: RawTransactionArgument<string>;
    epochsInFuture: RawTransactionArgument<number>;
}
export interface RingLookupOptions {
    package?: string;
    arguments: RingLookupArguments | [self: RawTransactionArgument<string>, epochsInFuture: RawTransactionArgument<number>];
}
/** Read-only lookup for an element in the `FutureAccountingRingBuffer` */
export declare function ringLookup(options: RingLookupOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface EpochArguments {
    accounting: RawTransactionArgument<string>;
}
export interface EpochOptions {
    package?: string;
    arguments: EpochArguments | [accounting: RawTransactionArgument<string>];
}
/** Accessor for epoch, read-only. */
export declare function epoch(options: EpochOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface UsedCapacityArguments {
    accounting: RawTransactionArgument<string>;
}
export interface UsedCapacityOptions {
    package?: string;
    arguments: UsedCapacityArguments | [accounting: RawTransactionArgument<string>];
}
/** Accessor for used_capacity, read-only. */
export declare function usedCapacity(options: UsedCapacityOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RewardsArguments {
    accounting: RawTransactionArgument<string>;
}
export interface RewardsOptions {
    package?: string;
    arguments: RewardsArguments | [accounting: RawTransactionArgument<string>];
}
/** Accessor for rewards, read-only. */
export declare function rewards(options: RewardsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;

import { MoveStruct, normalizeMoveArguments } from "../utils/index.js";
import { bcs } from "@mysten/sui/bcs";
import * as balance from "./deps/sui/balance.js";
const $moduleName = "@local-pkg/walrus::storage_accounting";
const FutureAccounting = new MoveStruct({
  name: `${$moduleName}::FutureAccounting`,
  fields: {
    epoch: bcs.u32(),
    /**
     * This field stores `used_capacity` for the epoch. Currently, impossible to rename
     * due to package upgrade limitations.
     */
    used_capacity: bcs.u64(),
    rewards_to_distribute: balance.Balance
  }
});
const FutureAccountingRingBuffer = new MoveStruct({
  name: `${$moduleName}::FutureAccountingRingBuffer`,
  fields: {
    current_index: bcs.u32(),
    length: bcs.u32(),
    ring_buffer: bcs.vector(FutureAccounting)
  }
});
function maxEpochsAhead(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [
    `${packageAddress}::storage_accounting::FutureAccountingRingBuffer`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "storage_accounting",
    function: "max_epochs_ahead",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function ringLookup(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [
    `${packageAddress}::storage_accounting::FutureAccountingRingBuffer`,
    "u32"
  ];
  const parameterNames = ["self", "epochsInFuture"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "storage_accounting",
    function: "ring_lookup",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function epoch(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [
    `${packageAddress}::storage_accounting::FutureAccounting`
  ];
  const parameterNames = ["accounting"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "storage_accounting",
    function: "epoch",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function usedCapacity(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [
    `${packageAddress}::storage_accounting::FutureAccounting`
  ];
  const parameterNames = ["accounting"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "storage_accounting",
    function: "used_capacity",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function rewards(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [
    `${packageAddress}::storage_accounting::FutureAccounting`
  ];
  const parameterNames = ["accounting"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "storage_accounting",
    function: "rewards",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
export {
  FutureAccounting,
  FutureAccountingRingBuffer,
  epoch,
  maxEpochsAhead,
  rewards,
  ringLookup,
  usedCapacity
};
//# sourceMappingURL=storage_accounting.js.map

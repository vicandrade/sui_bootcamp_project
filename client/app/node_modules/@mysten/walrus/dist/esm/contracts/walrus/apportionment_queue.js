import { bcs } from "@mysten/sui/bcs";
import { MoveStruct, normalizeMoveArguments } from "../utils/index.js";
import * as uq64_64 from "./deps/std/uq64_64.js";
const $moduleName = "@local-pkg/walrus::apportionment_queue";
function Entry(...typeParameters) {
  return new MoveStruct({
    name: `${$moduleName}::Entry<${typeParameters[0].name}>`,
    fields: {
      priority: uq64_64.UQ64_64,
      tie_breaker: bcs.u64(),
      value: typeParameters[0]
    }
  });
}
function ApportionmentQueue(...typeParameters) {
  return new MoveStruct({
    name: `${$moduleName}::ApportionmentQueue<${typeParameters[0].name}>`,
    fields: {
      /**
       * The `entries` vector contains a max heap, where the children of the node at
       * index `i` are at indices `2 * i + 1` and `2 * i + 2`. INV: The parent node's
       * priority is always higher or equal to its child nodes' priorities.
       */
      entries: bcs.vector(Entry(typeParameters[0]))
    }
  });
}
function _new(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "apportionment_queue",
    function: "new",
    typeArguments: options.typeArguments
  });
}
function popMax(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [
    `${packageAddress}::apportionment_queue::ApportionmentQueue<${options.typeArguments[0]}>`
  ];
  const parameterNames = ["pq"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "apportionment_queue",
    function: "pop_max",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function insert(options) {
  const packageAddress = options.package ?? "@local-pkg/walrus";
  const argumentsTypes = [
    `${packageAddress}::apportionment_queue::ApportionmentQueue<${options.typeArguments[0]}>`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::uq64_64::UQ64_64",
    "u64",
    `${options.typeArguments[0]}`
  ];
  const parameterNames = ["pq", "priority", "tieBreaker", "value"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "apportionment_queue",
    function: "insert",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
export {
  ApportionmentQueue,
  Entry,
  _new,
  insert,
  popMax
};
//# sourceMappingURL=apportionment_queue.js.map

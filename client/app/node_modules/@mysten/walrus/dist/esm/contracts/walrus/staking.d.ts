/** Module: staking */
import { MoveStruct } from '../utils/index.js';
import type { RawTransactionArgument } from '../utils/index.js';
import type { Transaction } from '@mysten/sui/transactions';
export declare const Staking: MoveStruct<{
    id: MoveStruct<{
        id: import("@mysten/sui/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    version: import("@mysten/sui/bcs").BcsType<string, string | number | bigint, "u64">;
    package_id: import("@mysten/sui/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    new_package_id: import("@mysten/sui/bcs").BcsType<string | null, string | Uint8Array<ArrayBufferLike> | null | undefined, "Option<bytes[32]>">;
}, "@local-pkg/walrus::staking::Staking">;
export interface RegisterCandidateArguments {
    staking: RawTransactionArgument<string>;
    name: RawTransactionArgument<string>;
    networkAddress: RawTransactionArgument<string>;
    metadata: RawTransactionArgument<string>;
    publicKey: RawTransactionArgument<number[]>;
    networkPublicKey: RawTransactionArgument<number[]>;
    proofOfPossession: RawTransactionArgument<number[]>;
    commissionRate: RawTransactionArgument<number>;
    storagePrice: RawTransactionArgument<number | bigint>;
    writePrice: RawTransactionArgument<number | bigint>;
    nodeCapacity: RawTransactionArgument<number | bigint>;
}
export interface RegisterCandidateOptions {
    package?: string;
    arguments: RegisterCandidateArguments | [
        staking: RawTransactionArgument<string>,
        name: RawTransactionArgument<string>,
        networkAddress: RawTransactionArgument<string>,
        metadata: RawTransactionArgument<string>,
        publicKey: RawTransactionArgument<number[]>,
        networkPublicKey: RawTransactionArgument<number[]>,
        proofOfPossession: RawTransactionArgument<number[]>,
        commissionRate: RawTransactionArgument<number>,
        storagePrice: RawTransactionArgument<number | bigint>,
        writePrice: RawTransactionArgument<number | bigint>,
        nodeCapacity: RawTransactionArgument<number | bigint>
    ];
}
/**
 * Creates a staking pool for the candidate, registers the candidate as a storage
 * node.
 */
export declare function registerCandidate(options: RegisterCandidateOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNextCommissionArguments {
    staking: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    commissionRate: RawTransactionArgument<number>;
}
export interface SetNextCommissionOptions {
    package?: string;
    arguments: SetNextCommissionArguments | [
        staking: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        commissionRate: RawTransactionArgument<number>
    ];
}
/**
 * Sets next_commission in the staking pool, which will then take effect as
 * commission rate one epoch after setting the value (to allow stakers to react to
 * setting this).
 */
export declare function setNextCommission(options: SetNextCommissionOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CollectCommissionArguments {
    staking: RawTransactionArgument<string>;
    nodeId: RawTransactionArgument<string>;
    auth: RawTransactionArgument<string>;
}
export interface CollectCommissionOptions {
    package?: string;
    arguments: CollectCommissionArguments | [
        staking: RawTransactionArgument<string>,
        nodeId: RawTransactionArgument<string>,
        auth: RawTransactionArgument<string>
    ];
}
/**
 * Collects the commission for the node. Transaction sender must be the
 * `CommissionReceiver` for the `StakingPool`.
 */
export declare function collectCommission(options: CollectCommissionOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetCommissionReceiverArguments {
    staking: RawTransactionArgument<string>;
    nodeId: RawTransactionArgument<string>;
    auth: RawTransactionArgument<string>;
    receiver: RawTransactionArgument<string>;
}
export interface SetCommissionReceiverOptions {
    package?: string;
    arguments: SetCommissionReceiverArguments | [
        staking: RawTransactionArgument<string>,
        nodeId: RawTransactionArgument<string>,
        auth: RawTransactionArgument<string>,
        receiver: RawTransactionArgument<string>
    ];
}
/** Sets the commission receiver for the node. */
export declare function setCommissionReceiver(options: SetCommissionReceiverOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetGovernanceAuthorizedArguments {
    staking: RawTransactionArgument<string>;
    nodeId: RawTransactionArgument<string>;
    auth: RawTransactionArgument<string>;
    authorized: RawTransactionArgument<string>;
}
export interface SetGovernanceAuthorizedOptions {
    package?: string;
    arguments: SetGovernanceAuthorizedArguments | [
        staking: RawTransactionArgument<string>,
        nodeId: RawTransactionArgument<string>,
        auth: RawTransactionArgument<string>,
        authorized: RawTransactionArgument<string>
    ];
}
/** Sets the governance authorized object for the pool. */
export declare function setGovernanceAuthorized(options: SetGovernanceAuthorizedOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CommitteeArguments {
    staking: RawTransactionArgument<string>;
}
export interface CommitteeOptions {
    package?: string;
    arguments: CommitteeArguments | [staking: RawTransactionArgument<string>];
}
/** Get the current committee. */
export declare function committee(options: CommitteeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ComputeNextCommitteeArguments {
    staking: RawTransactionArgument<string>;
}
export interface ComputeNextCommitteeOptions {
    package?: string;
    arguments: ComputeNextCommitteeArguments | [staking: RawTransactionArgument<string>];
}
/** Computes the committee for the next epoch. */
export declare function computeNextCommittee(options: ComputeNextCommitteeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetStoragePriceVoteArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    storagePrice: RawTransactionArgument<number | bigint>;
}
export interface SetStoragePriceVoteOptions {
    package?: string;
    arguments: SetStoragePriceVoteArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        storagePrice: RawTransactionArgument<number | bigint>
    ];
}
/** Sets the storage price vote for the pool. */
export declare function setStoragePriceVote(options: SetStoragePriceVoteOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetWritePriceVoteArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    writePrice: RawTransactionArgument<number | bigint>;
}
export interface SetWritePriceVoteOptions {
    package?: string;
    arguments: SetWritePriceVoteArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        writePrice: RawTransactionArgument<number | bigint>
    ];
}
/** Sets the write price vote for the pool. */
export declare function setWritePriceVote(options: SetWritePriceVoteOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNodeCapacityVoteArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    nodeCapacity: RawTransactionArgument<number | bigint>;
}
export interface SetNodeCapacityVoteOptions {
    package?: string;
    arguments: SetNodeCapacityVoteArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        nodeCapacity: RawTransactionArgument<number | bigint>
    ];
}
/** Sets the node capacity vote for the pool. */
export declare function setNodeCapacityVote(options: SetNodeCapacityVoteOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface NodeMetadataArguments {
    self: RawTransactionArgument<string>;
    nodeId: RawTransactionArgument<string>;
}
export interface NodeMetadataOptions {
    package?: string;
    arguments: NodeMetadataArguments | [self: RawTransactionArgument<string>, nodeId: RawTransactionArgument<string>];
}
/** Get `NodeMetadata` for the given node. */
export declare function nodeMetadata(options: NodeMetadataOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNextPublicKeyArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    publicKey: RawTransactionArgument<number[]>;
    proofOfPossession: RawTransactionArgument<number[]>;
}
export interface SetNextPublicKeyOptions {
    package?: string;
    arguments: SetNextPublicKeyArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        publicKey: RawTransactionArgument<number[]>,
        proofOfPossession: RawTransactionArgument<number[]>
    ];
}
/**
 * Sets the public key of a node to be used starting from the next epoch for which
 * the node is selected.
 */
export declare function setNextPublicKey(options: SetNextPublicKeyOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNameArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    name: RawTransactionArgument<string>;
}
export interface SetNameOptions {
    package?: string;
    arguments: SetNameArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        name: RawTransactionArgument<string>
    ];
}
/** Sets the name of a storage node. */
export declare function setName(options: SetNameOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNetworkAddressArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    networkAddress: RawTransactionArgument<string>;
}
export interface SetNetworkAddressOptions {
    package?: string;
    arguments: SetNetworkAddressArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        networkAddress: RawTransactionArgument<string>
    ];
}
/** Sets the network address or host of a storage node. */
export declare function setNetworkAddress(options: SetNetworkAddressOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNetworkPublicKeyArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    networkPublicKey: RawTransactionArgument<number[]>;
}
export interface SetNetworkPublicKeyOptions {
    package?: string;
    arguments: SetNetworkPublicKeyArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        networkPublicKey: RawTransactionArgument<number[]>
    ];
}
/** Sets the public key used for TLS communication for a node. */
export declare function setNetworkPublicKey(options: SetNetworkPublicKeyOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNodeMetadataArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    metadata: RawTransactionArgument<string>;
}
export interface SetNodeMetadataOptions {
    package?: string;
    arguments: SetNodeMetadataArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        metadata: RawTransactionArgument<string>
    ];
}
/** Sets the metadata of a storage node. */
export declare function setNodeMetadata(options: SetNodeMetadataOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface VotingEndArguments {
    staking: RawTransactionArgument<string>;
}
export interface VotingEndOptions {
    package?: string;
    arguments: VotingEndArguments | [staking: RawTransactionArgument<string>];
}
/**
 * Ends the voting period and runs the apportionment if the current time allows.
 *
 * This function is permissionless and can be called by anyone. Emits the
 * `EpochParametersSelected` event.
 */
export declare function votingEnd(options: VotingEndOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface InitiateEpochChangeArguments {
    staking: RawTransactionArgument<string>;
    system: RawTransactionArgument<string>;
}
export interface InitiateEpochChangeOptions {
    package?: string;
    arguments: InitiateEpochChangeArguments | [staking: RawTransactionArgument<string>, system: RawTransactionArgument<string>];
}
/**
 * Initiates the epoch change if the current time allows.
 *
 * Emits the `EpochChangeStart` event.
 */
export declare function initiateEpochChange(options: InitiateEpochChangeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface EpochSyncDoneArguments {
    staking: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    epoch: RawTransactionArgument<number>;
}
export interface EpochSyncDoneOptions {
    package?: string;
    arguments: EpochSyncDoneArguments | [
        staking: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        epoch: RawTransactionArgument<number>
    ];
}
/**
 * Signals to the contract that the node has received all its shards for the new
 * epoch.
 */
export declare function epochSyncDone(options: EpochSyncDoneOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface StakeWithPoolArguments {
    staking: RawTransactionArgument<string>;
    toStake: RawTransactionArgument<string>;
    nodeId: RawTransactionArgument<string>;
}
export interface StakeWithPoolOptions {
    package?: string;
    arguments: StakeWithPoolArguments | [
        staking: RawTransactionArgument<string>,
        toStake: RawTransactionArgument<string>,
        nodeId: RawTransactionArgument<string>
    ];
}
/** Stake `Coin` with the staking pool. */
export declare function stakeWithPool(options: StakeWithPoolOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RequestWithdrawStakeArguments {
    staking: RawTransactionArgument<string>;
    stakedWal: RawTransactionArgument<string>;
}
export interface RequestWithdrawStakeOptions {
    package?: string;
    arguments: RequestWithdrawStakeArguments | [staking: RawTransactionArgument<string>, stakedWal: RawTransactionArgument<string>];
}
/**
 * Marks the amount as a withdrawal to be processed and removes it from the stake
 * weight of the node.
 *
 * Allows the user to call `withdraw_stake` after the epoch change to the next
 * epoch and shard transfer is done.
 */
export declare function requestWithdrawStake(options: RequestWithdrawStakeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface WithdrawStakeArguments {
    staking: RawTransactionArgument<string>;
    stakedWal: RawTransactionArgument<string>;
}
export interface WithdrawStakeOptions {
    package?: string;
    arguments: WithdrawStakeArguments | [staking: RawTransactionArgument<string>, stakedWal: RawTransactionArgument<string>];
}
/** Withdraws the staked amount from the staking pool. */
export declare function withdrawStake(options: WithdrawStakeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface TryJoinActiveSetArguments {
    staking: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface TryJoinActiveSetOptions {
    package?: string;
    arguments: TryJoinActiveSetArguments | [staking: RawTransactionArgument<string>, cap: RawTransactionArgument<string>];
}
/**
 * Allows a node to join the active set if it has sufficient stake.
 *
 * This can be useful if another node in the active set had its stake reduced below
 * that of the current node. In that case, the current node will be added to the
 * active set either the next time stake is added or by calling this function.
 */
export declare function tryJoinActiveSet(options: TryJoinActiveSetOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AddCommissionToPoolsArguments {
    staking: RawTransactionArgument<string>;
    nodeIds: RawTransactionArgument<string[]>;
    commissions: RawTransactionArgument<string[]>;
}
export interface AddCommissionToPoolsOptions {
    package?: string;
    arguments: AddCommissionToPoolsArguments | [
        staking: RawTransactionArgument<string>,
        nodeIds: RawTransactionArgument<string[]>,
        commissions: RawTransactionArgument<string[]>
    ];
}
/** Adds `commissions[i]` to the commission of pool `node_ids[i]`. */
export declare function addCommissionToPools(options: AddCommissionToPoolsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface EpochArguments {
    staking: RawTransactionArgument<string>;
}
export interface EpochOptions {
    package?: string;
    arguments: EpochArguments | [staking: RawTransactionArgument<string>];
}
/** Returns the current epoch of the staking object. */
export declare function epoch(options: EpochOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CalculateRewardsArguments {
    staking: RawTransactionArgument<string>;
    nodeId: RawTransactionArgument<string>;
    stakedPrincipal: RawTransactionArgument<number | bigint>;
    activationEpoch: RawTransactionArgument<number>;
    withdrawEpoch: RawTransactionArgument<number>;
}
export interface CalculateRewardsOptions {
    package?: string;
    arguments: CalculateRewardsArguments | [
        staking: RawTransactionArgument<string>,
        nodeId: RawTransactionArgument<string>,
        stakedPrincipal: RawTransactionArgument<number | bigint>,
        activationEpoch: RawTransactionArgument<number>,
        withdrawEpoch: RawTransactionArgument<number>
    ];
}
/**
 * Calculates the rewards for an amount with value `staked_principal`, staked in
 * the pool with the given `node_id` between `activation_epoch` and
 * `withdraw_epoch`.
 *
 * This function can be used with `dev_inspect` to calculate the expected rewards
 * for a `StakedWal` object or, more generally, the returns provided by a given
 * node over a given period.
 */
export declare function calculateRewards(options: CalculateRewardsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CanWithdrawStakedWalEarlyArguments {
    staking: RawTransactionArgument<string>;
    stakedWal: RawTransactionArgument<string>;
}
export interface CanWithdrawStakedWalEarlyOptions {
    package?: string;
    arguments: CanWithdrawStakedWalEarlyArguments | [staking: RawTransactionArgument<string>, stakedWal: RawTransactionArgument<string>];
}
/**
 * Call `staked_wal::can_withdraw_early` to allow calling this method in
 * applications.
 */
export declare function canWithdrawStakedWalEarly(options: CanWithdrawStakedWalEarlyOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetMigrationEpochArguments {
    staking: RawTransactionArgument<string>;
}
export interface SetMigrationEpochOptions {
    package?: string;
    arguments: SetMigrationEpochArguments | [staking: RawTransactionArgument<string>];
}
/**
 * Sets the epoch in which the staking and system objects can be migrated after an
 * upgrade.
 */
export declare function setMigrationEpoch(options: SetMigrationEpochOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;

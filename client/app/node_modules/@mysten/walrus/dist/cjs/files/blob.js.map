{
  "version": 3,
  "sources": ["../../../src/files/blob.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { WalrusClient } from '../client.js';\nimport type { BlobReader } from './readers/blob.js';\nimport { WalrusFile } from './file.js';\nimport { ClientCache } from '@mysten/sui/experimental';\n\nexport class WalrusBlob {\n\t#reader: BlobReader;\n\t#client: WalrusClient;\n\t#cache = new ClientCache();\n\n\tconstructor({ reader, client }: { reader: BlobReader; client: WalrusClient }) {\n\t\tthis.#reader = reader;\n\t\tthis.#client = client;\n\t}\n\n\t// Get the blob as a file (i.e. do not use Quilt encoding)\n\tasFile() {\n\t\treturn new WalrusFile({ reader: this.#reader });\n\t}\n\n\tasync blobId(): Promise<string | null> {\n\t\treturn this.#reader.blobId;\n\t}\n\n\t// Gets quilt-based files associated with this blob.\n\tasync files(\n\t\tfilters: {\n\t\t\tids?: string[];\n\t\t\ttags?: { [tagName: string]: string }[];\n\t\t\tidentifiers?: string[];\n\t\t} = {},\n\t) {\n\t\tconst quiltReader = await this.#reader.getQuiltReader();\n\t\tconst index = await quiltReader.readIndex();\n\n\t\tconst files = [];\n\n\t\tfor (const patch of index) {\n\t\t\tif (filters.ids && !filters.ids.includes(patch.patchId)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (filters.identifiers && !filters.identifiers.includes(patch.identifier)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tfilters.tags &&\n\t\t\t\t!filters.tags.some((tags) =>\n\t\t\t\t\tObject.entries(tags).every(([tagName, tagValue]) => patch.tags[tagName] === tagValue),\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfiles.push(new WalrusFile({ reader: quiltReader.readerForPatchId(patch.patchId) }));\n\t\t}\n\n\t\treturn files;\n\t}\n\n\tasync #blobStatus() {\n\t\treturn this.#cache.read(['blobStatus', this.#reader.blobId], () =>\n\t\t\tthis.#client.getVerifiedBlobStatus({ blobId: this.#reader.blobId }),\n\t\t);\n\t}\n\n\tasync exists() {\n\t\tconst status = await this.#blobStatus();\n\t\treturn status.type === 'permanent' || status.type === 'deletable';\n\t}\n\n\tasync storedUntil() {\n\t\tconst status = await this.#blobStatus();\n\n\t\tif (status.type === 'permanent') {\n\t\t\treturn status.endEpoch;\n\t\t}\n\n\t\treturn null;\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,kBAA2B;AAC3B,0BAA4B;AAN5B;AAQO,MAAM,WAAW;AAAA,EAKvB,YAAY,EAAE,QAAQ,OAAO,GAAiD;AALxE;AACN;AACA;AACA,+BAAS,IAAI,gCAAY;AAGxB,uBAAK,SAAU;AACf,uBAAK,SAAU;AAAA,EAChB;AAAA;AAAA,EAGA,SAAS;AACR,WAAO,IAAI,uBAAW,EAAE,QAAQ,mBAAK,SAAQ,CAAC;AAAA,EAC/C;AAAA,EAEA,MAAM,SAAiC;AACtC,WAAO,mBAAK,SAAQ;AAAA,EACrB;AAAA;AAAA,EAGA,MAAM,MACL,UAII,CAAC,GACJ;AACD,UAAM,cAAc,MAAM,mBAAK,SAAQ,eAAe;AACtD,UAAM,QAAQ,MAAM,YAAY,UAAU;AAE1C,UAAM,QAAQ,CAAC;AAEf,eAAW,SAAS,OAAO;AAC1B,UAAI,QAAQ,OAAO,CAAC,QAAQ,IAAI,SAAS,MAAM,OAAO,GAAG;AACxD;AAAA,MACD;AAEA,UAAI,QAAQ,eAAe,CAAC,QAAQ,YAAY,SAAS,MAAM,UAAU,GAAG;AAC3E;AAAA,MACD;AAEA,UACC,QAAQ,QACR,CAAC,QAAQ,KAAK;AAAA,QAAK,CAAC,SACnB,OAAO,QAAQ,IAAI,EAAE,MAAM,CAAC,CAAC,SAAS,QAAQ,MAAM,MAAM,KAAK,OAAO,MAAM,QAAQ;AAAA,MACrF,GACC;AACD;AAAA,MACD;AAEA,YAAM,KAAK,IAAI,uBAAW,EAAE,QAAQ,YAAY,iBAAiB,MAAM,OAAO,EAAE,CAAC,CAAC;AAAA,IACnF;AAEA,WAAO;AAAA,EACR;AAAA,EAQA,MAAM,SAAS;AACd,UAAM,SAAS,MAAM,sBAAK,sCAAL;AACrB,WAAO,OAAO,SAAS,eAAe,OAAO,SAAS;AAAA,EACvD;AAAA,EAEA,MAAM,cAAc;AACnB,UAAM,SAAS,MAAM,sBAAK,sCAAL;AAErB,QAAI,OAAO,SAAS,aAAa;AAChC,aAAO,OAAO;AAAA,IACf;AAEA,WAAO;AAAA,EACR;AACD;AA3EC;AACA;AACA;AAHM;AAwDA,gBAAW,iBAAG;AACnB,SAAO,mBAAK,QAAO;AAAA,IAAK,CAAC,cAAc,mBAAK,SAAQ,MAAM;AAAA,IAAG,MAC5D,mBAAK,SAAQ,sBAAsB,EAAE,QAAQ,mBAAK,SAAQ,OAAO,CAAC;AAAA,EACnE;AACD;",
  "names": []
}

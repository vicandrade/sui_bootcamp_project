"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var quilt_exports = {};
__export(quilt_exports, {
  QuiltReader: () => QuiltReader
});
module.exports = __toCommonJS(quilt_exports);
var import_experimental = require("@mysten/sui/experimental");
var import_bcs = require("../../utils/bcs.js");
var import_quilts = require("../../utils/quilts.js");
var import_bcs2 = require("@mysten/bcs");
var import_bcs3 = require("../../utils/bcs.js");
var import_bcs4 = require("../../utils/bcs.js");
var import_utils = require("../../utils/index.js");
var import_quilt_file = require("./quilt-file.js");
var _blob, _cache, _QuiltReader_instances, readBytesFromSlivers_fn, readBytesFromBlob_fn, readBytes_fn;
class QuiltReader {
  constructor({ blob }) {
    __privateAdd(this, _QuiltReader_instances);
    __privateAdd(this, _blob);
    __privateAdd(this, _cache, new import_experimental.ClientCache());
    __privateSet(this, _blob, blob);
  }
  async getBlobHeader(sliverIndex) {
    return __privateGet(this, _cache).read(["getBlobHeader", sliverIndex.toString()], async () => {
      const blobHeader = import_bcs.QuiltPatchBlobHeader.parse(
        await __privateMethod(this, _QuiltReader_instances, readBytes_fn).call(this, sliverIndex, import_quilts.QUILT_PATCH_BLOB_HEADER_SIZE)
      );
      let offset = import_quilts.QUILT_PATCH_BLOB_HEADER_SIZE;
      let blobSize = blobHeader.length;
      const identifierLength = new DataView(
        (await __privateMethod(this, _QuiltReader_instances, readBytes_fn).call(this, sliverIndex, 2, offset)).buffer
      ).getUint16(0, true);
      blobSize -= 2 + identifierLength;
      offset += 2;
      const identifier = import_bcs2.bcs.string().parse(await __privateMethod(this, _QuiltReader_instances, readBytes_fn).call(this, sliverIndex, identifierLength, offset));
      offset += identifierLength;
      let tags = null;
      if (blobHeader.mask & import_quilts.HAS_TAGS_FLAG) {
        const tagsSize = new DataView(
          (await __privateMethod(this, _QuiltReader_instances, readBytes_fn).call(this, sliverIndex, 2, offset)).buffer
        ).getUint16(0, true);
        offset += 2;
        tags = import_bcs3.QuiltPatchTags.parse(await __privateMethod(this, _QuiltReader_instances, readBytes_fn).call(this, sliverIndex, tagsSize, offset));
        blobSize -= tagsSize + 2;
        offset += tagsSize;
      }
      return {
        identifier,
        tags,
        blobSize,
        contentOffset: offset
      };
    });
  }
  async readBlob(sliverIndex) {
    const { identifier, tags, blobSize, contentOffset } = await this.getBlobHeader(sliverIndex);
    const blobContents = await __privateMethod(this, _QuiltReader_instances, readBytes_fn).call(this, sliverIndex, blobSize, contentOffset);
    return {
      identifier,
      tags,
      blobContents
    };
  }
  readerForPatchId(id) {
    const { quiltId, patchId } = (0, import_quilts.parseQuiltPatchId)(id);
    if (quiltId !== __privateGet(this, _blob).blobId) {
      throw new Error(
        `The requested patch ${patchId} is not part of the quilt ${__privateGet(this, _blob).blobId}`
      );
    }
    return new import_quilt_file.QuiltFileReader({ quilt: this, sliverIndex: patchId.startIndex });
  }
  async readIndex() {
    const header = new DataView((await __privateMethod(this, _QuiltReader_instances, readBytes_fn).call(this, 0, 5)).buffer);
    const version = header.getUint8(0);
    if (version !== 1) {
      throw new Error(`Unsupported quilt version ${version}`);
    }
    const indexSize = header.getUint32(1, true);
    const indexBytes = await __privateMethod(this, _QuiltReader_instances, readBytes_fn).call(this, 0, indexSize, 5);
    const columnSize = await __privateGet(this, _blob).getColumnSize();
    const indexSlivers = Math.ceil(indexSize / columnSize);
    const index = import_bcs4.QuiltIndexV1.parse(indexBytes);
    return index.patches.map((patch, i) => {
      const startIndex = i === 0 ? indexSlivers : index.patches[i - 1].endIndex;
      const reader = new import_quilt_file.QuiltFileReader({
        quilt: this,
        sliverIndex: startIndex,
        identifier: patch.identifier,
        tags: patch.tags
      });
      return {
        identifier: patch.identifier,
        patchId: (0, import_utils.urlSafeBase64)(
          import_bcs.QuiltPatchId.serialize({
            quiltId: __privateGet(this, _blob).blobId,
            patchId: {
              version: 1,
              startIndex,
              endIndex: patch.endIndex
            }
          }).toBytes()
        ),
        tags: patch.tags,
        reader
      };
    });
  }
}
_blob = new WeakMap();
_cache = new WeakMap();
_QuiltReader_instances = new WeakSet();
readBytesFromSlivers_fn = async function(sliver, length, offset = 0, columnSize) {
  if (!length) {
    return new Uint8Array(0);
  }
  __privateGet(this, _blob).getSecondarySliver({ sliverIndex: sliver }).catch(() => {
  });
  columnSize = columnSize ?? await __privateGet(this, _blob).getColumnSize();
  const columnOffset = Math.floor(offset / columnSize);
  let remainingOffset = offset % columnSize;
  const bytes = new Uint8Array(length);
  let bytesRead = 0;
  const nSlivers = Math.ceil(length / columnSize);
  const slivers = new Array(nSlivers).fill(0).map((_, i) => __privateGet(this, _blob).getSecondarySliver({ sliverIndex: sliver + columnOffset + i }));
  slivers.forEach((p) => p.catch(() => {
  }));
  for (const sliverPromise of slivers) {
    const sliver2 = await sliverPromise;
    let chunk = remainingOffset > 0 ? sliver2.subarray(remainingOffset) : sliver2;
    remainingOffset -= chunk.length;
    if (chunk.length > length - bytesRead) {
      chunk = chunk.subarray(0, length - bytesRead);
    }
    bytes.set(chunk, bytesRead);
    bytesRead += chunk.length;
    if (bytesRead >= length) {
      break;
    }
  }
  return bytes;
};
readBytesFromBlob_fn = async function(startColumn, length, offset = 0) {
  const result = new Uint8Array(length);
  if (!length) {
    return result;
  }
  const blob = await __privateGet(this, _blob).getBytes();
  const [rowSize, symbolSize] = await Promise.all([
    __privateGet(this, _blob).getRowSize(),
    __privateGet(this, _blob).getSymbolSize()
  ]);
  const nRows = blob.length / rowSize;
  const symbolsToSkip = Math.floor(offset / symbolSize);
  let remainingOffset = offset % symbolSize;
  let currentCol = startColumn + Math.floor(symbolsToSkip / nRows);
  let currentRow = symbolsToSkip % nRows;
  let bytesRead = 0;
  while (bytesRead < length) {
    const baseIndex = currentRow * rowSize + currentCol * symbolSize;
    const startIndex = baseIndex + remainingOffset;
    const endIndex = Math.min(
      baseIndex + symbolSize,
      startIndex + length - bytesRead,
      blob.length
    );
    if (startIndex >= blob.length) {
      throw new Error("Index out of bounds");
    }
    const size = endIndex - startIndex;
    for (let i = 0; i < size; i++) {
      result[bytesRead + i] = blob[startIndex + i];
    }
    bytesRead += size;
    remainingOffset = 0;
    currentRow = (currentRow + 1) % nRows;
    if (currentRow === 0) {
      currentCol += 1;
    }
  }
  return result;
};
readBytes_fn = async function(sliver, length, offset = 0, columnSize) {
  if (__privateGet(this, _blob).hasStartedLoadingFullBlob) {
    return __privateMethod(this, _QuiltReader_instances, readBytesFromBlob_fn).call(this, sliver, length, offset);
  }
  try {
    const bytes = await __privateMethod(this, _QuiltReader_instances, readBytesFromSlivers_fn).call(this, sliver, length, offset, columnSize);
    return bytes;
  } catch (_error) {
    return __privateMethod(this, _QuiltReader_instances, readBytesFromBlob_fn).call(this, sliver, length, offset);
  }
};
//# sourceMappingURL=quilt.js.map

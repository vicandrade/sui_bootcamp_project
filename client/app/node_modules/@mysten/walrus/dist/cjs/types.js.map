{
  "version": 3,
  "sources": ["../../src/types.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiClient } from '@mysten/sui/client';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport type { ClientWithExtensions } from '@mysten/sui/experimental';\nimport type { Transaction, TransactionObjectArgument } from '@mysten/sui/transactions';\n\nimport type { StorageNodeInfo } from './contracts/walrus/storage_node.js';\nimport type { RequestOptions, StorageNodeClientOptions } from './storage-node/client.js';\nimport type {\n\tStorageConfirmation,\n\tStoreBlobMetadataRequestInput,\n\tStoreSliverRequestInput,\n\tUploadable,\n} from './storage-node/types.js';\nimport type { BlobMetadata, EncodingType } from './utils/bcs.js';\nimport type { UploadRelayClientOptions } from './upload-relay/client.js';\nimport type { WalrusFile } from './files/file.js';\nimport type { Blob } from './contracts/walrus/blob.js';\n\n/**\n * Configuration for the Walrus package on sui\n *\n * This is used to configure the Walrus package to use a specific package ID, system object ID, staking pool ID, and WAL package ID.\n */\nexport interface WalrusPackageConfig {\n\t/** The system object ID of the Walrus package */\n\tsystemObjectId: string;\n\t/** The staking pool ID of the Walrus package */\n\tstakingPoolId: string;\n\texchangeIds?: string[];\n}\n\ntype SuiClientOrRpcUrl =\n\t| {\n\t\t\tsuiClient: ClientWithExtensions<{\n\t\t\t\tjsonRpc: SuiClient;\n\t\t\t}>;\n\t\t\tsuiRpcUrl?: never;\n\t  }\n\t| {\n\t\t\tsuiRpcUrl: string;\n\t\t\tsuiClient?: never;\n\t  };\n\ntype WalrusNetworkOrPackageConfig =\n\t| {\n\t\t\tnetwork: 'mainnet' | 'testnet';\n\t\t\tpackageConfig?: WalrusPackageConfig;\n\t  }\n\t| {\n\t\t\tnetwork?: never;\n\t\t\tpackageConfig: WalrusPackageConfig;\n\t  };\n\nexport type TipStrategy =\n\t| {\n\t\t\tconst: number | bigint;\n\t  }\n\t| {\n\t\t\tlinear: {\n\t\t\t\tbase: number | bigint;\n\t\t\t\tperEncodedKib: number | bigint;\n\t\t\t};\n\t  };\n\nexport type UploadRelayTipConfig = {\n\taddress: string;\n\tmax?: number;\n\tkind: TipStrategy;\n};\n\nexport interface UploadRelayConfig extends UploadRelayClientOptions {\n\tsendTip?:\n\t\t| null\n\t\t| UploadRelayTipConfig\n\t\t| {\n\t\t\t\tmax: number;\n\t\t  };\n}\n\ninterface BaseWalrusClientConfig {\n\tstorageNodeClientOptions?: StorageNodeClientOptions;\n\twasmUrl?: string;\n\tuploadRelay?: UploadRelayConfig;\n}\n\n/**\n * Configuration for the Walrus client.\n *\n * This is used to configure the Walrus client to use a specific storage node client options, network, and Sui client or RPC URL.\n */\nexport type WalrusClientConfig = BaseWalrusClientConfig &\n\tWalrusNetworkOrPackageConfig &\n\tSuiClientOrRpcUrl;\n\nexport type WalrusClientExtensionOptions = BaseWalrusClientConfig & {\n\tpackageConfig?: WalrusPackageConfig;\n\tnetwork?: 'mainnet' | 'testnet';\n};\n\nexport type WalrusClientRequestOptions = Pick<RequestOptions, 'signal'>;\n\nexport interface StorageNode {\n\tnetworkUrl: string;\n\tinfo: (typeof StorageNodeInfo)['$inferType'];\n\tshardIndices: number[];\n\tnodeIndex: number;\n\tid: string;\n}\n\nexport interface CommitteeInfo {\n\tbyShardIndex: Map<number, StorageNode>;\n\tnodes: StorageNode[];\n}\n\nexport interface StorageWithSizeOptions {\n\t/** The encoded size of the blob. */\n\tsize: number;\n\t/** The number of epoch the storage will be reserved for. */\n\tepochs: number;\n\t/** optionally specify a WAL coin pay for the registration.  This will consume WAL from the signer by default. */\n\twalCoin?: TransactionObjectArgument;\n}\n\nexport interface RegisterBlobOptions extends StorageWithSizeOptions {\n\tblobId: string;\n\trootHash: Uint8Array;\n\tdeletable: boolean;\n\t/** optionally specify a WAL coin pay for the registration.  This will consume WAL from the signer by default. */\n\twalCoin?: TransactionObjectArgument;\n\t/** The attributes to write for the blob. */\n\tattributes?: Record<string, string | null>;\n}\n\nexport type CertifyBlobOptions = {\n\tblobId: string;\n\tblobObjectId: string;\n\tdeletable: boolean;\n} & (\n\t| {\n\t\t\t/** An array of confirmations.\n\t\t\t * These confirmations must be provided in the same order as the nodes in the committee.\n\t\t\t * For nodes that have not provided a confirmation you can pass `null` */\n\t\t\tconfirmations: (StorageConfirmation | null)[];\n\t\t\tcertificate?: never;\n\t  }\n\t| {\n\t\t\tcertificate: ProtocolMessageCertificate;\n\t\t\tconfirmations?: never;\n\t  }\n);\n\nexport type DeletableConfirmationOptions =\n\t| { deletable: false; objectId?: string }\n\t| { deletable: true; objectId: string };\n\nexport type GetStorageConfirmationOptions = {\n\tblobId: string;\n\tnodeIndex: number;\n} & DeletableConfirmationOptions &\n\tWalrusClientRequestOptions;\n\nexport type ReadBlobOptions = {\n\tblobId: string;\n} & WalrusClientRequestOptions;\n\nexport type GetCertificationEpochOptions = ReadBlobOptions;\n\nexport type GetBlobMetadataOptions = ReadBlobOptions;\n\nexport type GetSliversOptions = ReadBlobOptions;\n\nexport interface GetSecondarySliverOptions extends WalrusClientRequestOptions {\n\tblobId: string;\n\tindex: number;\n}\n\nexport type GetVerifiedBlobStatusOptions = ReadBlobOptions;\n\nexport type ComputeBlobMetadataOptions = {\n\tbytes: Uint8Array;\n\tnumShards?: number;\n};\n\nexport interface SliversForNode {\n\tprimary: {\n\t\tsliverIndex: number;\n\t\tsliverPairIndex: number;\n\t\tshardIndex: number;\n\t\tsliver: Uint8Array;\n\t}[];\n\tsecondary: {\n\t\tsliverIndex: number;\n\t\tsliverPairIndex: number;\n\t\tshardIndex: number;\n\t\tsliver: Uint8Array;\n\t}[];\n}\n\nexport type WriteSliversToNodeOptions = {\n\tblobId: string;\n\tnodeIndex: number;\n\tslivers: SliversForNode;\n} & WalrusClientRequestOptions;\n\nexport type WriteSliverOptions = StoreSliverRequestInput & WalrusClientRequestOptions;\n\nexport type WriteMetadataOptions = {\n\tnodeIndex: number;\n\tmetadata: Uploadable | typeof BlobMetadata.$inferInput;\n} & StoreBlobMetadataRequestInput &\n\tWalrusClientRequestOptions;\n\nexport type WriteEncodedBlobOptions = {\n\tblobId: string;\n\tnodeIndex: number;\n\tmetadata: Uploadable | typeof BlobMetadata.$inferInput;\n\tslivers: SliversForNode;\n} & DeletableConfirmationOptions &\n\tWalrusClientRequestOptions;\n\nexport type WriteEncodedBlobToNodesOptions = {\n\tblobId: string;\n\tmetadata: Uploadable | typeof BlobMetadata.$inferInput;\n\tsliversByNode: SliversForNode[];\n} & DeletableConfirmationOptions &\n\tWalrusClientRequestOptions;\n\nexport type WriteBlobToUploadRelayOptions = {\n\tblobId: string;\n\tblob: Uint8Array;\n\tnonce: Uint8Array;\n\ttxDigest: string;\n\tblobObjectId: string;\n\tdeletable: boolean;\n\tencodingType?: EncodingType;\n} & WalrusClientRequestOptions;\n\nexport type WriteBlobOptions = {\n\tblob: Uint8Array;\n\tdeletable: boolean;\n\t/** The number of epochs the blob should be stored for. */\n\tepochs: number;\n\tsigner: Signer;\n\t/** Where the blob should be transferred to after it is registered.  Defaults to the signer address. */\n\towner?: string;\n\t/** The attributes to write for the blob. */\n\tattributes?: Record<string, string | null>;\n} & WalrusClientRequestOptions;\n\nexport interface WriteQuiltOptions extends Omit<WriteBlobOptions, 'blob'> {\n\tblobs: {\n\t\tcontents: Uint8Array;\n\t\tidentifier: string;\n\t\ttags?: Record<string, string>;\n\t}[];\n}\n\nexport interface WriteFilesOptions extends Omit<WriteBlobOptions, 'blob'> {\n\tfiles: WalrusFile[];\n}\n\nexport interface WriteFilesFlowOptions {\n\tfiles: WalrusFile[];\n}\n\nexport interface WriteFilesFlowRegisterOptions extends Omit<WriteBlobOptions, 'blob' | 'signer'> {\n\towner: string;\n}\n\nexport interface WriteFilesFlowUploadOptions {\n\tdigest: string;\n}\n\nexport interface WriteFilesFlow {\n\tencode: () => Promise<void>;\n\tregister: (options: WriteFilesFlowRegisterOptions) => Transaction;\n\tupload: (options: WriteFilesFlowUploadOptions) => Promise<void>;\n\tcertify: () => Transaction;\n\tlistFiles: () => Promise<\n\t\t{\n\t\t\tid: string;\n\t\t\tblobId: string;\n\t\t\tblobObject: (typeof Blob)['$inferType'];\n\t\t}[]\n\t>;\n}\n\nexport interface WriteBlobFlowOptions {\n\tblob: Uint8Array;\n}\n\nexport interface WriteBlobFlowRegisterOptions extends Omit<WriteBlobOptions, 'blob' | 'signer'> {\n\towner: string;\n}\n\nexport interface WriteBlobFlowUploadOptions {\n\tdigest: string;\n}\n\nexport interface WriteBlobFlow {\n\tencode: () => Promise<void>;\n\tregister: (options: WriteBlobFlowRegisterOptions) => Transaction;\n\tupload: (options: WriteBlobFlowUploadOptions) => Promise<void>;\n\tcertify: () => Transaction;\n\tgetBlob: () => Promise<{\n\t\tblobId: string;\n\t\tblobObject: (typeof Blob)['$inferType'];\n\t}>;\n}\n\nexport interface DeleteBlobOptions {\n\tblobObjectId: string;\n}\n\nexport type ExtendBlobOptions = {\n\tblobObjectId: string;\n\t/** optionally specify a WAL coin pay for the registration.  This will consume WAL from the signer by default. */\n\twalCoin?: TransactionObjectArgument;\n} & (\n\t| {\n\t\t\t/** The number of epochs the blob should be stored for. */\n\t\t\tepochs: number;\n\t\t\tendEpoch?: never;\n\t  }\n\t| {\n\t\t\t/** The new end epoch for the storage period of the blob. */\n\t\t\tendEpoch: number;\n\t\t\tepochs?: never;\n\t  }\n);\n\nexport type WriteBlobAttributesOptions = {\n\tattributes: Record<string, string | null>;\n} & (\n\t| {\n\t\t\tblobObject: TransactionObjectArgument;\n\t\t\tblobObjectId?: never;\n\t  }\n\t| {\n\t\t\tblobObjectId: string;\n\t\t\tblobObject?: never;\n\t  }\n);\n\nexport type EncodingType = Extract<typeof EncodingType.$inferInput, string>;\n\nexport interface ProtocolMessageCertificate {\n\tsigners: number[];\n\tserializedMessage: Uint8Array;\n\tsignature: Uint8Array;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}

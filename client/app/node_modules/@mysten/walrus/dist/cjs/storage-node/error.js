"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var error_exports = {};
__export(error_exports, {
  AuthenticationError: () => AuthenticationError,
  BadRequestError: () => BadRequestError,
  BlobNotRegisteredError: () => BlobNotRegisteredError,
  ConflictError: () => ConflictError,
  ConnectionError: () => ConnectionError,
  ConnectionTimeoutError: () => ConnectionTimeoutError,
  InternalServerError: () => InternalServerError,
  LegallyUnavailableError: () => LegallyUnavailableError,
  NotFoundError: () => NotFoundError,
  PermissionDeniedError: () => PermissionDeniedError,
  RateLimitError: () => RateLimitError,
  StorageNodeAPIError: () => StorageNodeAPIError,
  StorageNodeError: () => StorageNodeError,
  UnprocessableEntityError: () => UnprocessableEntityError,
  UserAbortError: () => UserAbortError
});
module.exports = __toCommonJS(error_exports);
var _StorageNodeAPIError_static, makeMessage_fn;
class StorageNodeError extends Error {
}
const _StorageNodeAPIError = class _StorageNodeAPIError extends StorageNodeError {
  constructor(status, error, message) {
    var _a;
    super(__privateMethod(_a = _StorageNodeAPIError, _StorageNodeAPIError_static, makeMessage_fn).call(_a, status, error, message));
    this.status = status;
    this.error = error;
  }
  static generate(status, errorResponse, message) {
    if (!status) {
      return new ConnectionError({ message });
    }
    if (status === 400) {
      return BadRequestError.generate(status, errorResponse, message);
    }
    if (status === 401) {
      return new AuthenticationError(status, errorResponse, message);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, errorResponse, message);
    }
    if (status === 404) {
      return new NotFoundError(status, errorResponse, message);
    }
    if (status === 409) {
      return new ConflictError(status, errorResponse, message);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, errorResponse, message);
    }
    if (status === 429) {
      return new RateLimitError(status, errorResponse, message);
    }
    if (status === 451) {
      return new LegallyUnavailableError(status, errorResponse, message);
    }
    if (status >= 500) {
      return new InternalServerError(status, errorResponse, message);
    }
    return new _StorageNodeAPIError(status, errorResponse, message);
  }
};
_StorageNodeAPIError_static = new WeakSet();
makeMessage_fn = function(status, error, message) {
  function hasErrorMessage(error2) {
    return typeof error2?.error?.message === "string";
  }
  const inferredMessage = hasErrorMessage(error) ? error.error.message : message;
  const finalMessage = inferredMessage ? inferredMessage : JSON.stringify(error);
  if (status && finalMessage) {
    return `${status} ${finalMessage}`;
  } else if (finalMessage) {
    return finalMessage;
  } else if (status) {
    return `${status} status code (no body)`;
  }
  return "(no status code or body)";
};
__privateAdd(_StorageNodeAPIError, _StorageNodeAPIError_static);
let StorageNodeAPIError = _StorageNodeAPIError;
class UserAbortError extends StorageNodeAPIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.");
  }
}
class ConnectionError extends StorageNodeAPIError {
  constructor({ message }) {
    super(void 0, void 0, message || "Connection error.");
  }
}
class ConnectionTimeoutError extends StorageNodeAPIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message ?? "Request timed out.");
  }
}
class BadRequestError extends StorageNodeAPIError {
  static generate(status, errorResponse, message) {
    if (errorResponse && typeof errorResponse === "object" && "error" in errorResponse) {
      const error = errorResponse.error;
      if (error.details?.[0]?.reason === "NOT_REGISTERED") {
        return new BlobNotRegisteredError(errorResponse, message);
      }
    }
    return new BadRequestError(status, errorResponse, message);
  }
}
class BlobNotRegisteredError extends StorageNodeAPIError {
  constructor(error, message) {
    super(400, error, message);
  }
}
class AuthenticationError extends StorageNodeAPIError {
}
class PermissionDeniedError extends StorageNodeAPIError {
}
class NotFoundError extends StorageNodeAPIError {
}
class ConflictError extends StorageNodeAPIError {
}
class UnprocessableEntityError extends StorageNodeAPIError {
}
class RateLimitError extends StorageNodeAPIError {
}
class LegallyUnavailableError extends StorageNodeAPIError {
}
class InternalServerError extends StorageNodeAPIError {
}
//# sourceMappingURL=error.js.map

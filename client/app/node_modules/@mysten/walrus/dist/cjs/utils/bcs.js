"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var bcs_exports = {};
__export(bcs_exports, {
  BlobId: () => BlobId,
  BlobMetadata: () => BlobMetadata,
  BlobMetadataV1: () => BlobMetadataV1,
  BlobMetadataWithId: () => BlobMetadataWithId,
  BlobPersistenceType: () => BlobPersistenceType,
  EncodingType: () => EncodingType,
  Field: () => Field,
  Intent: () => Intent,
  IntentType: () => IntentType,
  ProtocolMessage: () => ProtocolMessage,
  QuiltIndexV1: () => QuiltIndexV1,
  QuiltPatchBlobHeader: () => QuiltPatchBlobHeader,
  QuiltPatchId: () => QuiltPatchId,
  QuiltPatchTags: () => QuiltPatchTags,
  QuiltPatchV1: () => QuiltPatchV1,
  Sliver: () => Sliver,
  SliverData: () => SliverData,
  SliverPair: () => SliverPair,
  StorageConfirmation: () => StorageConfirmation,
  StorageConfirmationBody: () => StorageConfirmationBody,
  blobIdFromBytes: () => blobIdFromBytes,
  blobIdFromInt: () => blobIdFromInt,
  blobIdToInt: () => blobIdToInt
});
module.exports = __toCommonJS(bcs_exports);
var import_bcs = require("@mysten/sui/bcs");
const MerkleNode = import_bcs.bcs.enum("MerkleNode", {
  Empty: null,
  Digest: import_bcs.bcs.bytes(32)
});
const SliverPairMetadata = import_bcs.bcs.struct("SliverPairMetadata", {
  primary_hash: MerkleNode,
  secondary_hash: MerkleNode
});
const EncodingType = import_bcs.bcs.enum("EncodingType", {
  RedStuff: null,
  RS2: null
}).transform({
  input: (encodingType) => typeof encodingType === "string" ? { [encodingType]: null } : encodingType,
  output: (encodingType) => encodingType
});
const BlobMetadataV1 = import_bcs.bcs.struct("BlobMetadataV1", {
  encoding_type: EncodingType,
  unencoded_length: import_bcs.bcs.u64(),
  hashes: import_bcs.bcs.vector(SliverPairMetadata)
});
const BlobMetadata = import_bcs.bcs.enum("BlobMetadata", {
  V1: BlobMetadataV1
});
const BlobId = import_bcs.bcs.u256().transform({
  input: (blobId) => typeof blobId === "string" ? blobIdToInt(blobId) : blobId,
  output: (id) => blobIdFromInt(id)
});
function blobIdFromInt(blobId) {
  return import_bcs.bcs.u256().serialize(blobId).toBase64().replace(/=*$/, "").replaceAll("+", "-").replaceAll("/", "_");
}
function blobIdFromBytes(blobId) {
  return blobIdFromInt(import_bcs.bcs.u256().parse(blobId));
}
function blobIdToInt(blobId) {
  return BigInt(import_bcs.bcs.u256().fromBase64(blobId.replaceAll("-", "+").replaceAll("_", "/")));
}
const BlobMetadataWithId = import_bcs.bcs.struct("BlobMetadataWithId", {
  blobId: BlobId,
  metadata: BlobMetadata
});
const Symbols = import_bcs.bcs.struct("Symbols", {
  data: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  symbol_size: import_bcs.bcs.u16()
});
const SliverData = import_bcs.bcs.struct("SliverData", {
  symbols: Symbols,
  index: import_bcs.bcs.u16()
});
const Sliver = import_bcs.bcs.enum("Sliver", {
  Primary: SliverData,
  Secondary: SliverData
});
const SliverPair = import_bcs.bcs.struct("SliverPair", {
  primary: SliverData,
  secondary: SliverData
});
var IntentType = /* @__PURE__ */ ((IntentType2) => {
  IntentType2[IntentType2["PROOF_OF_POSSESSION_MSG"] = 0] = "PROOF_OF_POSSESSION_MSG";
  IntentType2[IntentType2["BLOB_CERT_MSG"] = 1] = "BLOB_CERT_MSG";
  IntentType2[IntentType2["INVALID_BLOB_ID_MSG"] = 2] = "INVALID_BLOB_ID_MSG";
  IntentType2[IntentType2["SYNC_SHARD_MSG"] = 3] = "SYNC_SHARD_MSG";
  return IntentType2;
})(IntentType || {});
const Intent = import_bcs.bcs.struct("Intent", {
  type: import_bcs.bcs.u8().transform({
    input: (type) => type,
    output: (type) => type
  }),
  version: import_bcs.bcs.u8(),
  appId: import_bcs.bcs.u8()
}).transform({
  input: (intent) => ({
    type: intent,
    version: 0,
    appId: 3
  }),
  output: (intent) => intent.type
});
function ProtocolMessage(messageContents) {
  return import_bcs.bcs.struct(`ProtocolMessage<${messageContents.name}>`, {
    intent: Intent,
    epoch: import_bcs.bcs.u32(),
    messageContents
  });
}
const BlobPersistenceType = import_bcs.bcs.enum("BlobPersistenceType", {
  Permanent: null,
  Deletable: import_bcs.bcs.struct("Deletable", {
    objectId: import_bcs.bcs.Address
  })
});
const StorageConfirmationBody = import_bcs.bcs.struct("StorageConfirmationBody", {
  blobId: BlobId,
  blobType: BlobPersistenceType
});
const StorageConfirmation = ProtocolMessage(StorageConfirmationBody);
function Field(...typeParameters) {
  return import_bcs.bcs.struct("Field", {
    id: import_bcs.bcs.Address,
    name: typeParameters[0],
    value: typeParameters[1]
  });
}
const QuiltPatchTags = import_bcs.bcs.map(import_bcs.bcs.string(), import_bcs.bcs.string()).transform({
  // tags is a BTreeMap, so we need to sort entries before serializing
  input: (tags) => new Map(
    [...tags instanceof Map ? tags : Object.entries(tags)].sort(
      ([a], [b]) => (
        // TODO: sorting for map keys should be moved into @mysten/bcs
        compareBcsBytes(import_bcs.bcs.string().serialize(a).toBytes(), import_bcs.bcs.string().serialize(b).toBytes())
      )
    )
  ),
  output: (tags) => Object.fromEntries(tags)
});
const QuiltPatchV1 = import_bcs.bcs.struct("QuiltPatchV1", {
  endIndex: import_bcs.bcs.u16(),
  identifier: import_bcs.bcs.string(),
  tags: QuiltPatchTags
});
function compareBcsBytes(a, b) {
  if (a.length !== b.length) {
    return a.length - b.length;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return a[i] - b[i];
    }
  }
  return 0;
}
const QuiltIndexV1 = import_bcs.bcs.struct("QuiltIndexV1", {
  patches: import_bcs.bcs.vector(QuiltPatchV1)
});
const QuiltPatchId = import_bcs.bcs.struct("QuiltPatchId", {
  quiltId: BlobId,
  patchId: import_bcs.bcs.struct("InternalQuiltPatchId", {
    version: import_bcs.bcs.u8(),
    startIndex: import_bcs.bcs.u16(),
    endIndex: import_bcs.bcs.u16()
  })
});
const QuiltPatchBlobHeader = import_bcs.bcs.struct("QuiltPatchBlobHeader", {
  version: import_bcs.bcs.u8(),
  length: import_bcs.bcs.u32(),
  mask: import_bcs.bcs.u8()
});
//# sourceMappingURL=bcs.js.map

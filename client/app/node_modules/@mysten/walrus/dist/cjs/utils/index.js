"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var utils_exports = {};
__export(utils_exports, {
  MAX_SYMBOL_SIZE_BY_ENCODING_TYPE: () => MAX_SYMBOL_SIZE_BY_ENCODING_TYPE,
  REQUIRED_ALIGNMENT_BY_ENCODING_TYPE: () => REQUIRED_ALIGNMENT_BY_ENCODING_TYPE,
  encodedBlobLength: () => encodedBlobLength,
  encodedSliverSize: () => encodedSliverSize,
  fromUrlSafeBase64: () => fromUrlSafeBase64,
  getMaxFaultyNodes: () => getMaxFaultyNodes,
  getShardIndicesByNodeId: () => getShardIndicesByNodeId,
  getSizes: () => getSizes,
  getSourceSymbols: () => getSourceSymbols,
  isAboveValidity: () => isAboveValidity,
  isQuorum: () => isQuorum,
  nodesByShardIndex: () => nodesByShardIndex,
  shardIndexFromSecondarySliverIndex: () => shardIndexFromSecondarySliverIndex,
  signersToBitmap: () => signersToBitmap,
  sliverPairIndexFromSecondarySliverIndex: () => sliverPairIndexFromSecondarySliverIndex,
  storageUnitsFromSize: () => storageUnitsFromSize,
  toPairIndex: () => toPairIndex,
  toShardIndex: () => toShardIndex,
  toTypeString: () => toTypeString,
  urlSafeBase64: () => urlSafeBase64
});
module.exports = __toCommonJS(utils_exports);
var import_bcs = require("@mysten/bcs");
var import_bcs2 = require("./bcs.js");
const DIGEST_LEN = 32;
const BLOB_ID_LEN = 32;
const REQUIRED_ALIGNMENT_BY_ENCODING_TYPE = {
  RS2: 2,
  RedStuff: 2
};
const MAX_SYMBOL_SIZE_BY_ENCODING_TYPE = {
  RS2: 2 ** 16 - 1,
  RedStuff: 2 ** 16 - 1
};
function encodedBlobLength(unencodedLength, nShards, encodingType = "RS2") {
  const sliverSize = encodedSliverSize(unencodedLength, nShards, encodingType);
  const metadata = nShards * DIGEST_LEN * 2 + BLOB_ID_LEN;
  return nShards * metadata + sliverSize;
}
function encodedSliverSize(unencodedLength, nShards, encodingType = "RS2") {
  const { primarySymbols, secondarySymbols } = getSourceSymbols(nShards, encodingType);
  let symbolSize = Math.floor((Math.max(unencodedLength, 1) - 1) / (primarySymbols * secondarySymbols)) + 1;
  if (encodingType === "RS2" && symbolSize % 2 === 1) {
    symbolSize = symbolSize + 1;
  }
  const singleShardSize = (primarySymbols + secondarySymbols) * symbolSize;
  return singleShardSize * nShards;
}
function getSourceSymbols(nShards, encodingType = "RS2") {
  const safetyLimit = decodingSafetyLimit(nShards, encodingType);
  const maxFaulty = getMaxFaultyNodes(nShards);
  const minCorrect = nShards - maxFaulty;
  return {
    primarySymbols: minCorrect - maxFaulty - safetyLimit,
    secondarySymbols: minCorrect - safetyLimit
  };
}
function isQuorum(size, nShards) {
  const maxFaulty = getMaxFaultyNodes(nShards);
  return size > 2 * maxFaulty;
}
function isAboveValidity(size, nShards) {
  const maxFaulty = getMaxFaultyNodes(nShards);
  return size > maxFaulty;
}
function getMaxFaultyNodes(nShards) {
  return Math.floor((nShards - 1) / 3);
}
function decodingSafetyLimit(nShards, encodingType) {
  switch (encodingType) {
    case "RedStuff":
      return Math.min(5, Math.floor(getMaxFaultyNodes(nShards) / 5));
    case "RS2":
      return 0;
    default:
      throw new Error(`Encountered unknown encoding type of ${encodingType}`);
  }
}
const BYTES_PER_UNIT_SIZE = 1024 * 1024;
function storageUnitsFromSize(size) {
  return Math.ceil(size / BYTES_PER_UNIT_SIZE);
}
function rotationOffset(bytes, modulus) {
  return bytes.reduce((acc, byte) => (acc * 256 + byte) % modulus, 0);
}
function toShardIndex(sliverPairIndex, blobId, numShards) {
  const offset = rotationOffset(import_bcs2.BlobId.serialize(blobId).toBytes(), numShards);
  return (sliverPairIndex + offset) % numShards;
}
function sliverPairIndexFromSecondarySliverIndex(sliverIndex, numShards) {
  return numShards - sliverIndex - 1;
}
function shardIndexFromSecondarySliverIndex(sliverIndex, blobId, numShards) {
  const sliverPairIndex = sliverPairIndexFromSecondarySliverIndex(sliverIndex, numShards);
  return toShardIndex(sliverPairIndex, blobId, numShards);
}
function toPairIndex(shardIndex, blobId, numShards) {
  const offset = rotationOffset(import_bcs2.BlobId.serialize(blobId).toBytes(), numShards);
  return (numShards + shardIndex - offset) % numShards;
}
function signersToBitmap(signers, committeeSize) {
  const bitmapSize = Math.ceil(committeeSize / 8);
  const bitmap = new Uint8Array(bitmapSize);
  for (const signer of signers) {
    const byteIndex = Math.floor(signer / 8);
    const bitIndex = signer % 8;
    bitmap[byteIndex] |= 1 << bitIndex;
  }
  return bitmap;
}
function getShardIndicesByNodeId(committee) {
  const shardIndicesByNodeId = /* @__PURE__ */ new Map();
  for (const node of committee[0].contents) {
    if (!shardIndicesByNodeId.has(node.key)) {
      shardIndicesByNodeId.set(node.key, []);
    }
    shardIndicesByNodeId.get(node.key).push(...node.value);
  }
  return shardIndicesByNodeId;
}
function nodesByShardIndex(committee) {
  const nodesByShardIndex2 = /* @__PURE__ */ new Map();
  for (const node of committee[0].contents) {
    for (const shardIndex of node.value) {
      nodesByShardIndex2.set(shardIndex, node.key);
    }
  }
  return nodesByShardIndex2;
}
function toTypeString(type) {
  if (typeof type === "string") {
    switch (type) {
      case "Address":
        return "address";
      case "Bool":
        return "bool";
      case "U8":
        return "u8";
      case "U16":
        return "u16";
      case "U32":
        return "u32";
      case "U64":
        return "u64";
      case "U128":
        return "u128";
      case "U256":
        return "u256";
      default:
        throw new Error(`Unexpected type ${type}`);
    }
  }
  if ("Vector" in type) {
    return `vector<${toTypeString(type.Vector)}>`;
  }
  if ("Struct" in type) {
    if (type.Struct.typeArguments.length > 0) {
      return `${type.Struct.address}::${type.Struct.module}::${type.Struct.name}<${type.Struct.typeArguments.map(toTypeString).join(",")}>`;
    } else {
      return `${type.Struct.address}::${type.Struct.module}::${type.Struct.name}`;
    }
  }
  if ("TypeParameter" in type) {
    throw new Error(`Type parameters can't be converted to type strings`);
  }
  if ("Reference" in type) {
    return toTypeString(type.Reference);
  }
  if ("MutableReference" in type) {
    return toTypeString(type.MutableReference);
  }
  throw new Error(`Unexpected type ${JSON.stringify(type)}`);
}
function urlSafeBase64(bytes) {
  return (0, import_bcs.toBase64)(bytes).replace(/=*$/, "").replaceAll("+", "-").replaceAll("/", "_");
}
function fromUrlSafeBase64(base64) {
  return (0, import_bcs.fromBase64)(base64.replaceAll("-", "+").replaceAll("_", "/"));
}
function getSizes(blobSize, numShards) {
  const encodedBlobSize = encodedSliverSize(blobSize, numShards);
  const { primarySymbols, secondarySymbols } = getSourceSymbols(numShards);
  const totalSymbols = (primarySymbols + secondarySymbols) * numShards;
  if (encodedBlobSize % totalSymbols !== 0) {
    throw new Error("encoded blob size should be divisible by total symbols");
  }
  const symbolSize = encodedBlobSize / totalSymbols;
  if (encodedBlobSize % totalSymbols !== 0) {
    throw new Error("blob length should be divisible by total symbols");
  }
  const rowSize = symbolSize * secondarySymbols;
  const columnSize = symbolSize * primarySymbols;
  return {
    symbolSize,
    rowSize,
    columnSize,
    blobSize
  };
}
//# sourceMappingURL=index.js.map

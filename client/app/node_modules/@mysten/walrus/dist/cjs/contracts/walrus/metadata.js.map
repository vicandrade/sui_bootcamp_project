{
  "version": 3,
  "sources": ["../../../../src/contracts/walrus/metadata.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Contains the metadata for Blobs on Walrus. */\n\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as vec_map from './deps/sui/vec_map.js';\nconst $moduleName = '@local-pkg/walrus::metadata';\nexport const Metadata = new MoveStruct({\n\tname: `${$moduleName}::Metadata`,\n\tfields: {\n\t\tmetadata: vec_map.VecMap(bcs.string(), bcs.string()),\n\t},\n});\nexport interface NewOptions {\n\tpackage?: string;\n\targuments?: [];\n}\n/** Creates a new instance of Metadata. */\nexport function _new(options: NewOptions = {}) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'metadata',\n\t\t\tfunction: 'new',\n\t\t});\n}\nexport interface InsertOrUpdateArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n\tvalue: RawTransactionArgument<string>;\n}\nexport interface InsertOrUpdateOptions {\n\tpackage?: string;\n\targuments:\n\t\t| InsertOrUpdateArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tkey: RawTransactionArgument<string>,\n\t\t\t\tvalue: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Inserts a key-value pair into the metadata.\n *\n * If the key is already present, the value is updated.\n */\nexport function insertOrUpdate(options: InsertOrUpdateOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::metadata::Metadata`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key', 'value'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'metadata',\n\t\t\tfunction: 'insert_or_update',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RemoveArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n}\nexport interface RemoveOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RemoveArguments\n\t\t| [self: RawTransactionArgument<string>, key: RawTransactionArgument<string>];\n}\n/** Removes the metadata associated with the given key. */\nexport function remove(options: RemoveOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::metadata::Metadata`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'metadata',\n\t\t\tfunction: 'remove',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RemoveIfExistsArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n}\nexport interface RemoveIfExistsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RemoveIfExistsArguments\n\t\t| [self: RawTransactionArgument<string>, key: RawTransactionArgument<string>];\n}\n/**\n * Removes the metadata associated with the given key, if it exists.\n *\n * Optionally returns the previous value associated with the key.\n */\nexport function removeIfExists(options: RemoveIfExistsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::metadata::Metadata`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'metadata',\n\t\t\tfunction: 'remove_if_exists',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,mBAAmD;AAEnD,iBAAoB;AAEpB,cAAyB;AACzB,MAAM,cAAc;AACb,MAAM,WAAW,IAAI,wBAAW;AAAA,EACtC,MAAM,GAAG,WAAW;AAAA,EACpB,QAAQ;AAAA,IACP,UAAU,QAAQ,OAAO,eAAI,OAAO,GAAG,eAAI,OAAO,CAAC;AAAA,EACpD;AACD,CAAC;AAMM,SAAS,KAAK,UAAsB,CAAC,GAAG;AAC9C,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,SAAO,CAAC,OACP,GAAG,SAAS;AAAA,IACX,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,UAAU;AAAA,EACX,CAAC;AACH;AAqBO,SAAS,eAAe,SAAgC;AAC9D,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;AAAA,IACtB,GAAG,cAAc;AAAA,IACjB;AAAA,IACA;AAAA,EACD;AACA,QAAM,iBAAiB,CAAC,QAAQ,OAAO,OAAO;AAC9C,SAAO,CAAC,OACP,GAAG,SAAS;AAAA,IACX,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,eAAW,qCAAuB,QAAQ,WAAW,gBAAgB,cAAc;AAAA,EACpF,CAAC;AACH;AAYO,SAAS,OAAO,SAAwB;AAC9C,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;AAAA,IACtB,GAAG,cAAc;AAAA,IACjB;AAAA,EACD;AACA,QAAM,iBAAiB,CAAC,QAAQ,KAAK;AACrC,SAAO,CAAC,OACP,GAAG,SAAS;AAAA,IACX,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,eAAW,qCAAuB,QAAQ,WAAW,gBAAgB,cAAc;AAAA,EACpF,CAAC;AACH;AAgBO,SAAS,eAAe,SAAgC;AAC9D,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;AAAA,IACtB,GAAG,cAAc;AAAA,IACjB;AAAA,EACD;AACA,QAAM,iBAAiB,CAAC,QAAQ,KAAK;AACrC,SAAO,CAAC,OACP,GAAG,SAAS;AAAA,IACX,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,eAAW,qCAAuB,QAAQ,WAAW,gBAAgB,cAAc;AAAA,EACpF,CAAC;AACH;",
  "names": []
}

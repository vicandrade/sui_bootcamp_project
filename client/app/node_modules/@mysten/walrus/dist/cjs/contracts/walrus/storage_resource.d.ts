import { MoveStruct } from '../utils/index.js';
import type { RawTransactionArgument } from '../utils/index.js';
import type { Transaction } from '@mysten/sui/transactions';
export declare const Storage: MoveStruct<{
    id: MoveStruct<{
        id: import("@mysten/sui/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    start_epoch: import("@mysten/sui/bcs").BcsType<number, number, "u32">;
    end_epoch: import("@mysten/sui/bcs").BcsType<number, number, "u32">;
    storage_size: import("@mysten/sui/bcs").BcsType<string, string | number | bigint, "u64">;
}, "@local-pkg/walrus::storage_resource::Storage">;
export interface StartEpochArguments {
    self: RawTransactionArgument<string>;
}
export interface StartEpochOptions {
    package?: string;
    arguments: StartEpochArguments | [self: RawTransactionArgument<string>];
}
export declare function startEpoch(options: StartEpochOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface EndEpochArguments {
    self: RawTransactionArgument<string>;
}
export interface EndEpochOptions {
    package?: string;
    arguments: EndEpochArguments | [self: RawTransactionArgument<string>];
}
export declare function endEpoch(options: EndEpochOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SizeArguments {
    self: RawTransactionArgument<string>;
}
export interface SizeOptions {
    package?: string;
    arguments: SizeArguments | [self: RawTransactionArgument<string>];
}
export declare function size(options: SizeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SplitByEpochArguments {
    storage: RawTransactionArgument<string>;
    splitEpoch: RawTransactionArgument<number>;
}
export interface SplitByEpochOptions {
    package?: string;
    arguments: SplitByEpochArguments | [storage: RawTransactionArgument<string>, splitEpoch: RawTransactionArgument<number>];
}
/**
 * Splits the storage object into two based on `split_epoch`.
 *
 * `storage` is modified to cover the period from `start_epoch` to `split_epoch`
 * and a new storage object covering `split_epoch` to `end_epoch` is returned.
 */
export declare function splitByEpoch(options: SplitByEpochOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SplitBySizeArguments {
    storage: RawTransactionArgument<string>;
    splitSize: RawTransactionArgument<number | bigint>;
}
export interface SplitBySizeOptions {
    package?: string;
    arguments: SplitBySizeArguments | [storage: RawTransactionArgument<string>, splitSize: RawTransactionArgument<number | bigint>];
}
/**
 * Splits the storage object into two based on `split_size`.
 *
 * `storage` is modified to cover `split_size` and a new object covering
 * `storage.storage_size - split_size` is created.
 */
export declare function splitBySize(options: SplitBySizeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface FusePeriodsArguments {
    first: RawTransactionArgument<string>;
    second: RawTransactionArgument<string>;
}
export interface FusePeriodsOptions {
    package?: string;
    arguments: FusePeriodsArguments | [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];
}
/** Fuse two storage objects that cover adjacent periods with the same storage size. */
export declare function fusePeriods(options: FusePeriodsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface FuseAmountArguments {
    first: RawTransactionArgument<string>;
    second: RawTransactionArgument<string>;
}
export interface FuseAmountOptions {
    package?: string;
    arguments: FuseAmountArguments | [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];
}
/** Fuse two storage objects that cover the same period. */
export declare function fuseAmount(options: FuseAmountOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface FuseArguments {
    first: RawTransactionArgument<string>;
    second: RawTransactionArgument<string>;
}
export interface FuseOptions {
    package?: string;
    arguments: FuseArguments | [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];
}
/**
 * Fuse two storage objects that either cover the same period or adjacent periods
 * with the same storage size.
 */
export declare function fuse(options: FuseOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface DestroyArguments {
    storage: RawTransactionArgument<string>;
}
export interface DestroyOptions {
    package?: string;
    arguments: DestroyArguments | [storage: RawTransactionArgument<string>];
}
/** Destructor for [Storage] objects. */
export declare function destroy(options: DestroyOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;

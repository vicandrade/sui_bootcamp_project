{
  "version": 3,
  "sources": ["../../../../src/contracts/walrus/apportionment_queue.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * A custom priority queue implementation for use in the apportionment algorithm.\n * This implementation uses a quotient-based priority with a tie-breaker to break\n * ties when priorities are equal.\n */\n\nimport { bcs } from '@mysten/sui/bcs';\nimport type { BcsType } from '@mysten/sui/bcs';\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as uq64_64 from './deps/std/uq64_64.js';\nconst $moduleName = '@local-pkg/walrus::apportionment_queue';\nexport function Entry<T extends BcsType<any>>(...typeParameters: [T]) {\n\treturn new MoveStruct({\n\t\tname: `${$moduleName}::Entry<${typeParameters[0].name as T['name']}>`,\n\t\tfields: {\n\t\t\tpriority: uq64_64.UQ64_64,\n\t\t\ttie_breaker: bcs.u64(),\n\t\t\tvalue: typeParameters[0],\n\t\t},\n\t});\n}\n/** Struct representing a priority queue. */\nexport function ApportionmentQueue<T extends BcsType<any>>(...typeParameters: [T]) {\n\treturn new MoveStruct({\n\t\tname: `${$moduleName}::ApportionmentQueue<${typeParameters[0].name as T['name']}>`,\n\t\tfields: {\n\t\t\t/**\n\t\t\t * The `entries` vector contains a max heap, where the children of the node at\n\t\t\t * index `i` are at indices `2 * i + 1` and `2 * i + 2`. INV: The parent node's\n\t\t\t * priority is always higher or equal to its child nodes' priorities.\n\t\t\t */\n\t\t\tentries: bcs.vector(Entry(typeParameters[0])),\n\t\t},\n\t});\n}\nexport interface NewOptions {\n\tpackage?: string;\n\targuments?: [];\n\ttypeArguments: [string];\n}\n/** Create a new priority queue. */\nexport function _new(options: NewOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'apportionment_queue',\n\t\t\tfunction: 'new',\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface PopMaxArguments {\n\tpq: RawTransactionArgument<string>;\n}\nexport interface PopMaxOptions {\n\tpackage?: string;\n\targuments: PopMaxArguments | [pq: RawTransactionArgument<string>];\n\ttypeArguments: [string];\n}\n/** Pop the entry with the highest priority value. */\nexport function popMax(options: PopMaxOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::apportionment_queue::ApportionmentQueue<${options.typeArguments[0]}>`,\n\t] satisfies string[];\n\tconst parameterNames = ['pq'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'apportionment_queue',\n\t\t\tfunction: 'pop_max',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface InsertArguments<T extends BcsType<any>> {\n\tpq: RawTransactionArgument<string>;\n\tpriority: RawTransactionArgument<string>;\n\ttieBreaker: RawTransactionArgument<number | bigint>;\n\tvalue: RawTransactionArgument<T>;\n}\nexport interface InsertOptions<T extends BcsType<any>> {\n\tpackage?: string;\n\targuments:\n\t\t| InsertArguments<T>\n\t\t| [\n\t\t\t\tpq: RawTransactionArgument<string>,\n\t\t\t\tpriority: RawTransactionArgument<string>,\n\t\t\t\ttieBreaker: RawTransactionArgument<number | bigint>,\n\t\t\t\tvalue: RawTransactionArgument<T>,\n\t\t  ];\n\ttypeArguments: [string];\n}\n/** Insert a new entry into the queue. */\nexport function insert<T extends BcsType<any>>(options: InsertOptions<T>) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::apportionment_queue::ApportionmentQueue<${options.typeArguments[0]}>`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::uq64_64::UQ64_64',\n\t\t'u64',\n\t\t`${options.typeArguments[0]}`,\n\t] satisfies string[];\n\tconst parameterNames = ['pq', 'priority', 'tieBreaker', 'value'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'apportionment_queue',\n\t\t\tfunction: 'insert',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA,iBAAoB;AAEpB,mBAAmD;AAGnD,cAAyB;AACzB,MAAM,cAAc;AACb,SAAS,SAAiC,gBAAqB;AACrE,SAAO,IAAI,wBAAW;AAAA,IACrB,MAAM,GAAG,WAAW,WAAW,eAAe,CAAC,EAAE,IAAiB;AAAA,IAClE,QAAQ;AAAA,MACP,UAAU,QAAQ;AAAA,MAClB,aAAa,eAAI,IAAI;AAAA,MACrB,OAAO,eAAe,CAAC;AAAA,IACxB;AAAA,EACD,CAAC;AACF;AAEO,SAAS,sBAA8C,gBAAqB;AAClF,SAAO,IAAI,wBAAW;AAAA,IACrB,MAAM,GAAG,WAAW,wBAAwB,eAAe,CAAC,EAAE,IAAiB;AAAA,IAC/E,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMP,SAAS,eAAI,OAAO,MAAM,eAAe,CAAC,CAAC,CAAC;AAAA,IAC7C;AAAA,EACD,CAAC;AACF;AAOO,SAAS,KAAK,SAAqB;AACzC,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,SAAO,CAAC,OACP,GAAG,SAAS;AAAA,IACX,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,eAAe,QAAQ;AAAA,EACxB,CAAC;AACH;AAUO,SAAS,OAAO,SAAwB;AAC9C,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;AAAA,IACtB,GAAG,cAAc,6CAA6C,QAAQ,cAAc,CAAC,CAAC;AAAA,EACvF;AACA,QAAM,iBAAiB,CAAC,IAAI;AAC5B,SAAO,CAAC,OACP,GAAG,SAAS;AAAA,IACX,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,eAAW,qCAAuB,QAAQ,WAAW,gBAAgB,cAAc;AAAA,IACnF,eAAe,QAAQ;AAAA,EACxB,CAAC;AACH;AAoBO,SAAS,OAA+B,SAA2B;AACzE,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;AAAA,IACtB,GAAG,cAAc,6CAA6C,QAAQ,cAAc,CAAC,CAAC;AAAA,IACtF;AAAA,IACA;AAAA,IACA,GAAG,QAAQ,cAAc,CAAC,CAAC;AAAA,EAC5B;AACA,QAAM,iBAAiB,CAAC,MAAM,YAAY,cAAc,OAAO;AAC/D,SAAO,CAAC,OACP,GAAG,SAAS;AAAA,IACX,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,eAAW,qCAAuB,QAAQ,WAAW,gBAAgB,cAAc;AAAA,IACnF,eAAe,QAAQ;AAAA,EACxB,CAAC;AACH;",
  "names": []
}

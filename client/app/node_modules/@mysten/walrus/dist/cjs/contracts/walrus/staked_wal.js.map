{
  "version": 3,
  "sources": ["../../../../src/contracts/walrus/staked_wal.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Module: `staked_wal`\n *\n * Implements the `StakedWal` functionality - a staked WAL is an object that\n * represents a staked amount of WALs in a staking pool. It is created in the\n * `staking_pool` on staking and can be split, joined, and burned. The burning is\n * performed via the `withdraw_stake` method in the `staking_pool`.\n */\n\nimport { MoveEnum, MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nimport * as balance from './deps/sui/balance.js';\nconst $moduleName = '@local-pkg/walrus::staked_wal';\n/**\n * The state of the staked WAL. It can be either `Staked` or `Withdrawing`. The\n * `Withdrawing` state contains the epoch when the staked WAL can be withdrawn.\n */\nexport const StakedWalState = new MoveEnum({\n\tname: `${$moduleName}::StakedWalState`,\n\tfields: {\n\t\tStaked: null,\n\t\tWithdrawing: new MoveStruct({\n\t\t\tname: `StakedWalState.Withdrawing`,\n\t\t\tfields: {\n\t\t\t\twithdraw_epoch: bcs.u32(),\n\t\t\t},\n\t\t}),\n\t},\n});\nexport const StakedWal = new MoveStruct({\n\tname: `${$moduleName}::StakedWal`,\n\tfields: {\n\t\tid: object.UID,\n\t\t/** Whether the staked WAL is active or withdrawing. */\n\t\tstate: StakedWalState,\n\t\t/** ID of the staking pool. */\n\t\tnode_id: bcs.Address,\n\t\t/** The staked amount. */\n\t\tprincipal: balance.Balance,\n\t\t/** The Walrus epoch when the staked WAL was activated. */\n\t\tactivation_epoch: bcs.u32(),\n\t},\n});\nexport interface NodeIdArguments {\n\tsw: RawTransactionArgument<string>;\n}\nexport interface NodeIdOptions {\n\tpackage?: string;\n\targuments: NodeIdArguments | [sw: RawTransactionArgument<string>];\n}\n/** Returns the `node_id` of the staked WAL. */\nexport function nodeId(options: NodeIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staked_wal::StakedWal`] satisfies string[];\n\tconst parameterNames = ['sw'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staked_wal',\n\t\t\tfunction: 'node_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ValueArguments {\n\tsw: RawTransactionArgument<string>;\n}\nexport interface ValueOptions {\n\tpackage?: string;\n\targuments: ValueArguments | [sw: RawTransactionArgument<string>];\n}\n/**\n * Returns the `principal` of the staked WAL. Called `value` to be consistent with\n * `Coin`.\n */\nexport function value(options: ValueOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staked_wal::StakedWal`] satisfies string[];\n\tconst parameterNames = ['sw'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staked_wal',\n\t\t\tfunction: 'value',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ActivationEpochArguments {\n\tsw: RawTransactionArgument<string>;\n}\nexport interface ActivationEpochOptions {\n\tpackage?: string;\n\targuments: ActivationEpochArguments | [sw: RawTransactionArgument<string>];\n}\n/** Returns the `activation_epoch` of the staked WAL. */\nexport function activationEpoch(options: ActivationEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staked_wal::StakedWal`] satisfies string[];\n\tconst parameterNames = ['sw'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staked_wal',\n\t\t\tfunction: 'activation_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface IsStakedArguments {\n\tsw: RawTransactionArgument<string>;\n}\nexport interface IsStakedOptions {\n\tpackage?: string;\n\targuments: IsStakedArguments | [sw: RawTransactionArgument<string>];\n}\n/** Returns true if the staked WAL is in the `Staked` state. */\nexport function isStaked(options: IsStakedOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staked_wal::StakedWal`] satisfies string[];\n\tconst parameterNames = ['sw'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staked_wal',\n\t\t\tfunction: 'is_staked',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface IsWithdrawingArguments {\n\tsw: RawTransactionArgument<string>;\n}\nexport interface IsWithdrawingOptions {\n\tpackage?: string;\n\targuments: IsWithdrawingArguments | [sw: RawTransactionArgument<string>];\n}\n/** Checks whether the staked WAL is in the `Withdrawing` state. */\nexport function isWithdrawing(options: IsWithdrawingOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staked_wal::StakedWal`] satisfies string[];\n\tconst parameterNames = ['sw'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staked_wal',\n\t\t\tfunction: 'is_withdrawing',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface WithdrawEpochArguments {\n\tsw: RawTransactionArgument<string>;\n}\nexport interface WithdrawEpochOptions {\n\tpackage?: string;\n\targuments: WithdrawEpochArguments | [sw: RawTransactionArgument<string>];\n}\n/**\n * Returns the `withdraw_epoch` of the staked WAL if it is in the `Withdrawing`.\n * Aborts otherwise.\n */\nexport function withdrawEpoch(options: WithdrawEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staked_wal::StakedWal`] satisfies string[];\n\tconst parameterNames = ['sw'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staked_wal',\n\t\t\tfunction: 'withdraw_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface JoinArguments {\n\tsw: RawTransactionArgument<string>;\n\tother: RawTransactionArgument<string>;\n}\nexport interface JoinOptions {\n\tpackage?: string;\n\targuments:\n\t\t| JoinArguments\n\t\t| [sw: RawTransactionArgument<string>, other: RawTransactionArgument<string>];\n}\n/**\n * Joins the staked WAL with another staked WAL, adding the `principal` of the\n * `other` staked WAL to the current staked WAL.\n *\n * Aborts if the `node_id` or `activation_epoch` of the staked WALs do not match.\n */\nexport function join(options: JoinOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staked_wal::StakedWal`,\n\t\t`${packageAddress}::staked_wal::StakedWal`,\n\t] satisfies string[];\n\tconst parameterNames = ['sw', 'other'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staked_wal',\n\t\t\tfunction: 'join',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SplitArguments {\n\tsw: RawTransactionArgument<string>;\n\tamount: RawTransactionArgument<number | bigint>;\n}\nexport interface SplitOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SplitArguments\n\t\t| [sw: RawTransactionArgument<string>, amount: RawTransactionArgument<number | bigint>];\n}\n/**\n * Splits the staked WAL into two parts, one with the `amount` and the other with\n * the remaining `principal`. The `node_id`, `activation_epoch` are the same for\n * both the staked WALs.\n *\n * Aborts if the `amount` is greater than the `principal` of the staked WAL. Aborts\n * if the `amount` is zero.\n */\nexport function split(options: SplitOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staked_wal::StakedWal`, 'u64'] satisfies string[];\n\tconst parameterNames = ['sw', 'amount'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staked_wal',\n\t\t\tfunction: 'split',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n"],
  "mappings": "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",
  "names": []
}

{
  "version": 3,
  "sources": ["../../../../src/contracts/walrus/blob.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nimport * as storage_resource from './storage_resource.js';\nconst $moduleName = '@local-pkg/walrus::blob';\nexport const Blob = new MoveStruct({\n\tname: `${$moduleName}::Blob`,\n\tfields: {\n\t\tid: object.UID,\n\t\tregistered_epoch: bcs.u32(),\n\t\tblob_id: bcs.u256(),\n\t\tsize: bcs.u64(),\n\t\tencoding_type: bcs.u8(),\n\t\tcertified_epoch: bcs.option(bcs.u32()),\n\t\tstorage: storage_resource.Storage,\n\t\tdeletable: bcs.bool(),\n\t},\n});\nexport const BlobIdDerivation = new MoveStruct({\n\tname: `${$moduleName}::BlobIdDerivation`,\n\tfields: {\n\t\tencoding_type: bcs.u8(),\n\t\tsize: bcs.u64(),\n\t\troot_hash: bcs.u256(),\n\t},\n});\nexport interface ObjectIdArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface ObjectIdOptions {\n\tpackage?: string;\n\targuments: ObjectIdArguments | [self: RawTransactionArgument<string>];\n}\nexport function objectId(options: ObjectIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'object_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RegisteredEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface RegisteredEpochOptions {\n\tpackage?: string;\n\targuments: RegisteredEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function registeredEpoch(options: RegisteredEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'registered_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface BlobIdArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface BlobIdOptions {\n\tpackage?: string;\n\targuments: BlobIdArguments | [self: RawTransactionArgument<string>];\n}\nexport function blobId(options: BlobIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'blob_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface SizeOptions {\n\tpackage?: string;\n\targuments: SizeArguments | [self: RawTransactionArgument<string>];\n}\nexport function size(options: SizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EncodingTypeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface EncodingTypeOptions {\n\tpackage?: string;\n\targuments: EncodingTypeArguments | [self: RawTransactionArgument<string>];\n}\nexport function encodingType(options: EncodingTypeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'encoding_type',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CertifiedEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface CertifiedEpochOptions {\n\tpackage?: string;\n\targuments: CertifiedEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function certifiedEpoch(options: CertifiedEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'certified_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface StorageArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface StorageOptions {\n\tpackage?: string;\n\targuments: StorageArguments | [self: RawTransactionArgument<string>];\n}\nexport function storage(options: StorageOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'storage',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface IsDeletableArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface IsDeletableOptions {\n\tpackage?: string;\n\targuments: IsDeletableArguments | [self: RawTransactionArgument<string>];\n}\nexport function isDeletable(options: IsDeletableOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'is_deletable',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EncodedSizeArguments {\n\tself: RawTransactionArgument<string>;\n\tnShards: RawTransactionArgument<number>;\n}\nexport interface EncodedSizeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| EncodedSizeArguments\n\t\t| [self: RawTransactionArgument<string>, nShards: RawTransactionArgument<number>];\n}\nexport function encodedSize(options: EncodedSizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`, 'u16'] satisfies string[];\n\tconst parameterNames = ['self', 'nShards'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'encoded_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EndEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface EndEpochOptions {\n\tpackage?: string;\n\targuments: EndEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function endEpoch(options: EndEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'end_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DeriveBlobIdArguments {\n\trootHash: RawTransactionArgument<number | bigint>;\n\tencodingType: RawTransactionArgument<number>;\n\tsize: RawTransactionArgument<number | bigint>;\n}\nexport interface DeriveBlobIdOptions {\n\tpackage?: string;\n\targuments:\n\t\t| DeriveBlobIdArguments\n\t\t| [\n\t\t\t\trootHash: RawTransactionArgument<number | bigint>,\n\t\t\t\tencodingType: RawTransactionArgument<number>,\n\t\t\t\tsize: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Derives the blob_id for a blob given the root_hash, encoding_type and size. */\nexport function deriveBlobId(options: DeriveBlobIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = ['u256', 'u8', 'u64'] satisfies string[];\n\tconst parameterNames = ['rootHash', 'encodingType', 'size'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'derive_blob_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface BurnArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface BurnOptions {\n\tpackage?: string;\n\targuments: BurnArguments | [self: RawTransactionArgument<string>];\n}\n/**\n * Allow the owner of a blob object to destroy it.\n *\n * This function also burns any [`Metadata`] associated with the blob, if present.\n */\nexport function burn(options: BurnOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'burn',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddMetadataArguments {\n\tself: RawTransactionArgument<string>;\n\tmetadata: RawTransactionArgument<string>;\n}\nexport interface AddMetadataOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddMetadataArguments\n\t\t| [self: RawTransactionArgument<string>, metadata: RawTransactionArgument<string>];\n}\n/**\n * Adds the metadata dynamic field to the Blob.\n *\n * Aborts if the metadata is already present.\n */\nexport function addMetadata(options: AddMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t`${packageAddress}::metadata::Metadata`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'metadata'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'add_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddOrReplaceMetadataArguments {\n\tself: RawTransactionArgument<string>;\n\tmetadata: RawTransactionArgument<string>;\n}\nexport interface AddOrReplaceMetadataOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddOrReplaceMetadataArguments\n\t\t| [self: RawTransactionArgument<string>, metadata: RawTransactionArgument<string>];\n}\n/**\n * Adds the metadata dynamic field to the Blob, replacing the existing metadata if\n * present.\n *\n * Returns the replaced metadata if present.\n */\nexport function addOrReplaceMetadata(options: AddOrReplaceMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t`${packageAddress}::metadata::Metadata`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'metadata'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'add_or_replace_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface TakeMetadataArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface TakeMetadataOptions {\n\tpackage?: string;\n\targuments: TakeMetadataArguments | [self: RawTransactionArgument<string>];\n}\n/**\n * Removes the metadata dynamic field from the Blob, returning the contained\n * `Metadata`.\n *\n * Aborts if the metadata does not exist.\n */\nexport function takeMetadata(options: TakeMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'take_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface InsertOrUpdateMetadataPairArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n\tvalue: RawTransactionArgument<string>;\n}\nexport interface InsertOrUpdateMetadataPairOptions {\n\tpackage?: string;\n\targuments:\n\t\t| InsertOrUpdateMetadataPairArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tkey: RawTransactionArgument<string>,\n\t\t\t\tvalue: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Inserts a key-value pair into the metadata.\n *\n * If the key is already present, the value is updated. Creates new metadata on the\n * Blob object if it does not exist already.\n */\nexport function insertOrUpdateMetadataPair(options: InsertOrUpdateMetadataPairOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key', 'value'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'insert_or_update_metadata_pair',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RemoveMetadataPairArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n}\nexport interface RemoveMetadataPairOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RemoveMetadataPairArguments\n\t\t| [self: RawTransactionArgument<string>, key: RawTransactionArgument<string>];\n}\n/**\n * Removes the metadata associated with the given key.\n *\n * Aborts if the metadata does not exist.\n */\nexport function removeMetadataPair(options: RemoveMetadataPairOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'remove_metadata_pair',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RemoveMetadataPairIfExistsArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n}\nexport interface RemoveMetadataPairIfExistsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RemoveMetadataPairIfExistsArguments\n\t\t| [self: RawTransactionArgument<string>, key: RawTransactionArgument<string>];\n}\n/** Removes and returns the metadata associated with the given key, if it exists. */\nexport function removeMetadataPairIfExists(options: RemoveMetadataPairIfExistsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'remove_metadata_pair_if_exists',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n"],
  "mappings": "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",
  "names": []
}

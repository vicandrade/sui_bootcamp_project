{
  "version": 3,
  "sources": ["../../../../src/contracts/walrus/staking.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Module: staking */\n\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/walrus::staking';\nexport const Staking = new MoveStruct({\n\tname: `${$moduleName}::Staking`,\n\tfields: {\n\t\tid: object.UID,\n\t\tversion: bcs.u64(),\n\t\tpackage_id: bcs.Address,\n\t\tnew_package_id: bcs.option(bcs.Address),\n\t},\n});\nexport interface RegisterCandidateArguments {\n\tstaking: RawTransactionArgument<string>;\n\tname: RawTransactionArgument<string>;\n\tnetworkAddress: RawTransactionArgument<string>;\n\tmetadata: RawTransactionArgument<string>;\n\tpublicKey: RawTransactionArgument<number[]>;\n\tnetworkPublicKey: RawTransactionArgument<number[]>;\n\tproofOfPossession: RawTransactionArgument<number[]>;\n\tcommissionRate: RawTransactionArgument<number>;\n\tstoragePrice: RawTransactionArgument<number | bigint>;\n\twritePrice: RawTransactionArgument<number | bigint>;\n\tnodeCapacity: RawTransactionArgument<number | bigint>;\n}\nexport interface RegisterCandidateOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RegisterCandidateArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tname: RawTransactionArgument<string>,\n\t\t\t\tnetworkAddress: RawTransactionArgument<string>,\n\t\t\t\tmetadata: RawTransactionArgument<string>,\n\t\t\t\tpublicKey: RawTransactionArgument<number[]>,\n\t\t\t\tnetworkPublicKey: RawTransactionArgument<number[]>,\n\t\t\t\tproofOfPossession: RawTransactionArgument<number[]>,\n\t\t\t\tcommissionRate: RawTransactionArgument<number>,\n\t\t\t\tstoragePrice: RawTransactionArgument<number | bigint>,\n\t\t\t\twritePrice: RawTransactionArgument<number | bigint>,\n\t\t\t\tnodeCapacity: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/**\n * Creates a staking pool for the candidate, registers the candidate as a storage\n * node.\n */\nexport function registerCandidate(options: RegisterCandidateOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t\t`${packageAddress}::node_metadata::NodeMetadata`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'u16',\n\t\t'u64',\n\t\t'u64',\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = [\n\t\t'staking',\n\t\t'name',\n\t\t'networkAddress',\n\t\t'metadata',\n\t\t'publicKey',\n\t\t'networkPublicKey',\n\t\t'proofOfPossession',\n\t\t'commissionRate',\n\t\t'storagePrice',\n\t\t'writePrice',\n\t\t'nodeCapacity',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'register_candidate',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNextCommissionArguments {\n\tstaking: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tcommissionRate: RawTransactionArgument<number>;\n}\nexport interface SetNextCommissionOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNextCommissionArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tcommissionRate: RawTransactionArgument<number>,\n\t\t  ];\n}\n/**\n * Sets next_commission in the staking pool, which will then take effect as\n * commission rate one epoch after setting the value (to allow stakers to react to\n * setting this).\n */\nexport function setNextCommission(options: SetNextCommissionOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u16',\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'cap', 'commissionRate'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_next_commission',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CollectCommissionArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n\tauth: RawTransactionArgument<string>;\n}\nexport interface CollectCommissionOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CollectCommissionArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t\t\tauth: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Collects the commission for the node. Transaction sender must be the\n * `CommissionReceiver` for the `StakingPool`.\n */\nexport function collectCommission(options: CollectCommissionOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t\t`${packageAddress}::auth::Authenticated`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'nodeId', 'auth'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'collect_commission',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetCommissionReceiverArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n\tauth: RawTransactionArgument<string>;\n\treceiver: RawTransactionArgument<string>;\n}\nexport interface SetCommissionReceiverOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetCommissionReceiverArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t\t\tauth: RawTransactionArgument<string>,\n\t\t\t\treceiver: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the commission receiver for the node. */\nexport function setCommissionReceiver(options: SetCommissionReceiverOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t\t`${packageAddress}::auth::Authenticated`,\n\t\t`${packageAddress}::auth::Authorized`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'nodeId', 'auth', 'receiver'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_commission_receiver',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetGovernanceAuthorizedArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n\tauth: RawTransactionArgument<string>;\n\tauthorized: RawTransactionArgument<string>;\n}\nexport interface SetGovernanceAuthorizedOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetGovernanceAuthorizedArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t\t\tauth: RawTransactionArgument<string>,\n\t\t\t\tauthorized: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the governance authorized object for the pool. */\nexport function setGovernanceAuthorized(options: SetGovernanceAuthorizedOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t\t`${packageAddress}::auth::Authenticated`,\n\t\t`${packageAddress}::auth::Authorized`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'nodeId', 'auth', 'authorized'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_governance_authorized',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CommitteeArguments {\n\tstaking: RawTransactionArgument<string>;\n}\nexport interface CommitteeOptions {\n\tpackage?: string;\n\targuments: CommitteeArguments | [staking: RawTransactionArgument<string>];\n}\n/** Get the current committee. */\nexport function committee(options: CommitteeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staking::Staking`] satisfies string[];\n\tconst parameterNames = ['staking'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'committee',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ComputeNextCommitteeArguments {\n\tstaking: RawTransactionArgument<string>;\n}\nexport interface ComputeNextCommitteeOptions {\n\tpackage?: string;\n\targuments: ComputeNextCommitteeArguments | [staking: RawTransactionArgument<string>];\n}\n/** Computes the committee for the next epoch. */\nexport function computeNextCommittee(options: ComputeNextCommitteeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staking::Staking`] satisfies string[];\n\tconst parameterNames = ['staking'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'compute_next_committee',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetStoragePriceVoteArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tstoragePrice: RawTransactionArgument<number | bigint>;\n}\nexport interface SetStoragePriceVoteOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetStoragePriceVoteArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tstoragePrice: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Sets the storage price vote for the pool. */\nexport function setStoragePriceVote(options: SetStoragePriceVoteOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'storagePrice'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_storage_price_vote',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetWritePriceVoteArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\twritePrice: RawTransactionArgument<number | bigint>;\n}\nexport interface SetWritePriceVoteOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetWritePriceVoteArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\twritePrice: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Sets the write price vote for the pool. */\nexport function setWritePriceVote(options: SetWritePriceVoteOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'writePrice'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_write_price_vote',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNodeCapacityVoteArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tnodeCapacity: RawTransactionArgument<number | bigint>;\n}\nexport interface SetNodeCapacityVoteOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNodeCapacityVoteArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tnodeCapacity: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Sets the node capacity vote for the pool. */\nexport function setNodeCapacityVote(options: SetNodeCapacityVoteOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'nodeCapacity'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_node_capacity_vote',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface NodeMetadataArguments {\n\tself: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n}\nexport interface NodeMetadataOptions {\n\tpackage?: string;\n\targuments:\n\t\t| NodeMetadataArguments\n\t\t| [self: RawTransactionArgument<string>, nodeId: RawTransactionArgument<string>];\n}\n/** Get `NodeMetadata` for the given node. */\nexport function nodeMetadata(options: NodeMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'nodeId'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'node_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNextPublicKeyArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tpublicKey: RawTransactionArgument<number[]>;\n\tproofOfPossession: RawTransactionArgument<number[]>;\n}\nexport interface SetNextPublicKeyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNextPublicKeyArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tpublicKey: RawTransactionArgument<number[]>,\n\t\t\t\tproofOfPossession: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/**\n * Sets the public key of a node to be used starting from the next epoch for which\n * the node is selected.\n */\nexport function setNextPublicKey(options: SetNextPublicKeyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'publicKey', 'proofOfPossession'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_next_public_key',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNameArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tname: RawTransactionArgument<string>;\n}\nexport interface SetNameOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNameArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tname: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the name of a storage node. */\nexport function setName(options: SetNameOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'name'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_name',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNetworkAddressArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tnetworkAddress: RawTransactionArgument<string>;\n}\nexport interface SetNetworkAddressOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNetworkAddressArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tnetworkAddress: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the network address or host of a storage node. */\nexport function setNetworkAddress(options: SetNetworkAddressOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'networkAddress'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_network_address',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNetworkPublicKeyArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tnetworkPublicKey: RawTransactionArgument<number[]>;\n}\nexport interface SetNetworkPublicKeyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNetworkPublicKeyArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tnetworkPublicKey: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Sets the public key used for TLS communication for a node. */\nexport function setNetworkPublicKey(options: SetNetworkPublicKeyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'networkPublicKey'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_network_public_key',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNodeMetadataArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tmetadata: RawTransactionArgument<string>;\n}\nexport interface SetNodeMetadataOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNodeMetadataArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tmetadata: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the metadata of a storage node. */\nexport function setNodeMetadata(options: SetNodeMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t`${packageAddress}::node_metadata::NodeMetadata`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'metadata'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_node_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface VotingEndArguments {\n\tstaking: RawTransactionArgument<string>;\n}\nexport interface VotingEndOptions {\n\tpackage?: string;\n\targuments: VotingEndArguments | [staking: RawTransactionArgument<string>];\n}\n/**\n * Ends the voting period and runs the apportionment if the current time allows.\n *\n * This function is permissionless and can be called by anyone. Emits the\n * `EpochParametersSelected` event.\n */\nexport function votingEnd(options: VotingEndOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['staking'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'voting_end',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface InitiateEpochChangeArguments {\n\tstaking: RawTransactionArgument<string>;\n\tsystem: RawTransactionArgument<string>;\n}\nexport interface InitiateEpochChangeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| InitiateEpochChangeArguments\n\t\t| [staking: RawTransactionArgument<string>, system: RawTransactionArgument<string>];\n}\n/**\n * Initiates the epoch change if the current time allows.\n *\n * Emits the `EpochChangeStart` event.\n */\nexport function initiateEpochChange(options: InitiateEpochChangeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::system::System`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'system'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'initiate_epoch_change',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EpochSyncDoneArguments {\n\tstaking: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tepoch: RawTransactionArgument<number>;\n}\nexport interface EpochSyncDoneOptions {\n\tpackage?: string;\n\targuments:\n\t\t| EpochSyncDoneArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tepoch: RawTransactionArgument<number>,\n\t\t  ];\n}\n/**\n * Signals to the contract that the node has received all its shards for the new\n * epoch.\n */\nexport function epochSyncDone(options: EpochSyncDoneOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u32',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'cap', 'epoch'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'epoch_sync_done',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface StakeWithPoolArguments {\n\tstaking: RawTransactionArgument<string>;\n\ttoStake: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n}\nexport interface StakeWithPoolOptions {\n\tpackage?: string;\n\targuments:\n\t\t| StakeWithPoolArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\ttoStake: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Stake `Coin` with the staking pool. */\nexport function stakeWithPool(options: StakeWithPoolOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'toStake', 'nodeId'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'stake_with_pool',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RequestWithdrawStakeArguments {\n\tstaking: RawTransactionArgument<string>;\n\tstakedWal: RawTransactionArgument<string>;\n}\nexport interface RequestWithdrawStakeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RequestWithdrawStakeArguments\n\t\t| [staking: RawTransactionArgument<string>, stakedWal: RawTransactionArgument<string>];\n}\n/**\n * Marks the amount as a withdrawal to be processed and removes it from the stake\n * weight of the node.\n *\n * Allows the user to call `withdraw_stake` after the epoch change to the next\n * epoch and shard transfer is done.\n */\nexport function requestWithdrawStake(options: RequestWithdrawStakeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::staked_wal::StakedWal`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'stakedWal'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'request_withdraw_stake',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface WithdrawStakeArguments {\n\tstaking: RawTransactionArgument<string>;\n\tstakedWal: RawTransactionArgument<string>;\n}\nexport interface WithdrawStakeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| WithdrawStakeArguments\n\t\t| [staking: RawTransactionArgument<string>, stakedWal: RawTransactionArgument<string>];\n}\n/** Withdraws the staked amount from the staking pool. */\nexport function withdrawStake(options: WithdrawStakeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::staked_wal::StakedWal`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'stakedWal'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'withdraw_stake',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface TryJoinActiveSetArguments {\n\tstaking: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n}\nexport interface TryJoinActiveSetOptions {\n\tpackage?: string;\n\targuments:\n\t\t| TryJoinActiveSetArguments\n\t\t| [staking: RawTransactionArgument<string>, cap: RawTransactionArgument<string>];\n}\n/**\n * Allows a node to join the active set if it has sufficient stake.\n *\n * This can be useful if another node in the active set had its stake reduced below\n * that of the current node. In that case, the current node will be added to the\n * active set either the next time stake is added or by calling this function.\n */\nexport function tryJoinActiveSet(options: TryJoinActiveSetOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'try_join_active_set',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddCommissionToPoolsArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeIds: RawTransactionArgument<string[]>;\n\tcommissions: RawTransactionArgument<string[]>;\n}\nexport interface AddCommissionToPoolsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddCommissionToPoolsArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeIds: RawTransactionArgument<string[]>,\n\t\t\t\tcommissions: RawTransactionArgument<string[]>,\n\t\t  ];\n}\n/** Adds `commissions[i]` to the commission of pool `node_ids[i]`. */\nexport function addCommissionToPools(options: AddCommissionToPoolsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'vector<0x0000000000000000000000000000000000000000000000000000000000000002::object::ID>',\n\t\t`vector<0x0000000000000000000000000000000000000000000000000000000000000002::balance::Balance<${packageAddress}::wal::WAL>>`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'nodeIds', 'commissions'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'add_commission_to_pools',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EpochArguments {\n\tstaking: RawTransactionArgument<string>;\n}\nexport interface EpochOptions {\n\tpackage?: string;\n\targuments: EpochArguments | [staking: RawTransactionArgument<string>];\n}\n/** Returns the current epoch of the staking object. */\nexport function epoch(options: EpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staking::Staking`] satisfies string[];\n\tconst parameterNames = ['staking'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CalculateRewardsArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n\tstakedPrincipal: RawTransactionArgument<number | bigint>;\n\tactivationEpoch: RawTransactionArgument<number>;\n\twithdrawEpoch: RawTransactionArgument<number>;\n}\nexport interface CalculateRewardsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CalculateRewardsArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t\t\tstakedPrincipal: RawTransactionArgument<number | bigint>,\n\t\t\t\tactivationEpoch: RawTransactionArgument<number>,\n\t\t\t\twithdrawEpoch: RawTransactionArgument<number>,\n\t\t  ];\n}\n/**\n * Calculates the rewards for an amount with value `staked_principal`, staked in\n * the pool with the given `node_id` between `activation_epoch` and\n * `withdraw_epoch`.\n *\n * This function can be used with `dev_inspect` to calculate the expected rewards\n * for a `StakedWal` object or, more generally, the returns provided by a given\n * node over a given period.\n */\nexport function calculateRewards(options: CalculateRewardsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t\t'u64',\n\t\t'u32',\n\t\t'u32',\n\t] satisfies string[];\n\tconst parameterNames = [\n\t\t'staking',\n\t\t'nodeId',\n\t\t'stakedPrincipal',\n\t\t'activationEpoch',\n\t\t'withdrawEpoch',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'calculate_rewards',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CanWithdrawStakedWalEarlyArguments {\n\tstaking: RawTransactionArgument<string>;\n\tstakedWal: RawTransactionArgument<string>;\n}\nexport interface CanWithdrawStakedWalEarlyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CanWithdrawStakedWalEarlyArguments\n\t\t| [staking: RawTransactionArgument<string>, stakedWal: RawTransactionArgument<string>];\n}\n/**\n * Call `staked_wal::can_withdraw_early` to allow calling this method in\n * applications.\n */\nexport function canWithdrawStakedWalEarly(options: CanWithdrawStakedWalEarlyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::staked_wal::StakedWal`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'stakedWal'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'can_withdraw_staked_wal_early',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetMigrationEpochArguments {\n\tstaking: RawTransactionArgument<string>;\n}\nexport interface SetMigrationEpochOptions {\n\tpackage?: string;\n\targuments: SetMigrationEpochArguments | [staking: RawTransactionArgument<string>];\n}\n/**\n * Sets the epoch in which the staking and system objects can be migrated after an\n * upgrade.\n */\nexport function setMigrationEpoch(options: SetMigrationEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staking::Staking`] satisfies string[];\n\tconst parameterNames = ['staking'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_migration_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n"],
  "mappings": "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",
  "names": []
}

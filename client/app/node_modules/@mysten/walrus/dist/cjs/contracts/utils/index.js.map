{
  "version": 3,
  "sources": ["../../../../src/contracts/utils/index.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport type { BcsType, TypeTag } from '@mysten/sui/bcs';\nimport { bcs, TypeTagSerializer, BcsStruct, BcsEnum, BcsTuple } from '@mysten/sui/bcs';\nimport { normalizeSuiAddress } from '@mysten/sui/utils';\nimport type { TransactionArgument } from '@mysten/sui/transactions';\nimport { isArgument } from '@mysten/sui/transactions';\n\nconst MOVE_STDLIB_ADDRESS = normalizeSuiAddress('0x1');\nconst SUI_FRAMEWORK_ADDRESS = normalizeSuiAddress('0x2');\nconst SUI_SYSTEM_ADDRESS = normalizeSuiAddress('0x3');\n\nexport type RawTransactionArgument<T> = T | TransactionArgument;\n\nexport function getPureBcsSchema(typeTag: string | TypeTag): BcsType<any> | null {\n\tconst parsedTag = typeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag) : typeTag;\n\n\tif ('u8' in parsedTag) {\n\t\treturn bcs.U8;\n\t} else if ('u16' in parsedTag) {\n\t\treturn bcs.U16;\n\t} else if ('u32' in parsedTag) {\n\t\treturn bcs.U32;\n\t} else if ('u64' in parsedTag) {\n\t\treturn bcs.U64;\n\t} else if ('u128' in parsedTag) {\n\t\treturn bcs.U128;\n\t} else if ('u256' in parsedTag) {\n\t\treturn bcs.U256;\n\t} else if ('address' in parsedTag) {\n\t\treturn bcs.Address;\n\t} else if ('bool' in parsedTag) {\n\t\treturn bcs.Bool;\n\t} else if ('vector' in parsedTag) {\n\t\tconst type = getPureBcsSchema(parsedTag.vector);\n\t\treturn type ? bcs.vector(type) : null;\n\t} else if ('struct' in parsedTag) {\n\t\tconst structTag = parsedTag.struct;\n\t\tconst pkg = normalizeSuiAddress(parsedTag.struct.address);\n\n\t\tif (pkg === MOVE_STDLIB_ADDRESS) {\n\t\t\tif (\n\t\t\t\t(structTag.module === 'ascii' || structTag.module === 'string') &&\n\t\t\t\tstructTag.name === 'String'\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (structTag.module === 'option' && structTag.name === 'Option') {\n\t\t\t\tconst type = getPureBcsSchema(structTag.typeParams[0]!);\n\t\t\t\treturn type ? bcs.vector(type) : null;\n\t\t\t}\n\t\t}\n\n\t\tif (pkg === SUI_FRAMEWORK_ADDRESS && structTag.module === 'Object' && structTag.name === 'ID') {\n\t\t\treturn bcs.Address;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function normalizeMoveArguments(\n\targs: unknown[] | object,\n\targTypes: string[],\n\tparameterNames?: string[],\n) {\n\tconst argLen = Array.isArray(args) ? args.length : Object.keys(args).length;\n\tif (parameterNames && argLen !== parameterNames.length) {\n\t\tthrow new Error(\n\t\t\t`Invalid number of arguments, expected ${parameterNames.length}, got ${argLen}`,\n\t\t);\n\t}\n\n\tconst normalizedArgs: TransactionArgument[] = [];\n\n\tlet index = 0;\n\tfor (const [i, argType] of argTypes.entries()) {\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::deny_list::DenyList`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.denyList());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::random::Random`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.random());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::clock::Clock`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.clock());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_SYSTEM_ADDRESS}::sui_system::SuiSystemState`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.system());\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet arg;\n\t\tif (Array.isArray(args)) {\n\t\t\tif (index >= args.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid number of arguments, expected at least ${index + 1}, got ${args.length}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\targ = args[index];\n\t\t} else {\n\t\t\tif (!parameterNames) {\n\t\t\t\tthrow new Error(`Expected arguments to be passed as an array`);\n\t\t\t}\n\t\t\tconst name = parameterNames[index];\n\t\t\targ = args[name as keyof typeof args];\n\n\t\t\tif (arg == null) {\n\t\t\t\tthrow new Error(`Parameter ${name} is required`);\n\t\t\t}\n\t\t}\n\n\t\tindex += 1;\n\n\t\tif (typeof arg === 'function' || isArgument(arg)) {\n\t\t\tnormalizedArgs.push(arg as TransactionArgument);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst type = argTypes[i]!;\n\t\tconst bcsType = getPureBcsSchema(type);\n\n\t\tif (bcsType) {\n\t\t\tconst bytes = bcsType.serialize(arg as never);\n\t\t\tnormalizedArgs.push((tx) => tx.pure(bytes));\n\t\t\tcontinue;\n\t\t} else if (typeof arg === 'string') {\n\t\t\tnormalizedArgs.push((tx) => tx.object(arg));\n\t\t\tcontinue;\n\t\t}\n\n\t\tthrow new Error(`Invalid argument ${stringify(arg)} for type ${type}`);\n\t}\n\n\treturn normalizedArgs;\n}\n\nexport class MoveStruct<\n\tT extends Record<string, BcsType<any>>,\n\tconst Name extends string = string,\n> extends BcsStruct<T, Name> {}\n\nexport class MoveEnum<\n\tT extends Record<string, BcsType<any> | null>,\n\tconst Name extends string,\n> extends BcsEnum<T, Name> {}\n\nexport class MoveTuple<\n\tT extends readonly BcsType<any>[],\n\tconst Name extends string,\n> extends BcsTuple<T, Name> {}\n\nfunction stringify(val: unknown) {\n\tif (typeof val === 'object') {\n\t\treturn JSON.stringify(val, (val: unknown) => val);\n\t}\n\tif (typeof val === 'bigint') {\n\t\treturn val.toString();\n\t}\n\n\treturn val;\n}\n"],
  "mappings": "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",
  "names": ["val"]
}

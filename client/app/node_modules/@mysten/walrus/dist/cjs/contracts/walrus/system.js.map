{
  "version": 3,
  "sources": ["../../../../src/contracts/walrus/system.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Module: system */\n\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/walrus::system';\nexport const System = new MoveStruct({\n\tname: `${$moduleName}::System`,\n\tfields: {\n\t\tid: object.UID,\n\t\tversion: bcs.u64(),\n\t\tpackage_id: bcs.Address,\n\t\tnew_package_id: bcs.option(bcs.Address),\n\t},\n});\nexport interface InvalidateBlobIdArguments {\n\tsystem: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface InvalidateBlobIdOptions {\n\tpackage?: string;\n\targuments:\n\t\t| InvalidateBlobIdArguments\n\t\t| [\n\t\t\t\tsystem: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/**\n * === Public Functions === Marks blob as invalid given an invalid blob\n * certificate.\n */\nexport function invalidateBlobId(options: InvalidateBlobIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['system', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'invalidate_blob_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CertifyEventBlobArguments {\n\tsystem: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tblobId: RawTransactionArgument<number | bigint>;\n\trootHash: RawTransactionArgument<number | bigint>;\n\tsize: RawTransactionArgument<number | bigint>;\n\tencodingType: RawTransactionArgument<number>;\n\tendingCheckpointSequenceNum: RawTransactionArgument<number | bigint>;\n\tepoch: RawTransactionArgument<number>;\n}\nexport interface CertifyEventBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CertifyEventBlobArguments\n\t\t| [\n\t\t\t\tsystem: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tblobId: RawTransactionArgument<number | bigint>,\n\t\t\t\trootHash: RawTransactionArgument<number | bigint>,\n\t\t\t\tsize: RawTransactionArgument<number | bigint>,\n\t\t\t\tencodingType: RawTransactionArgument<number>,\n\t\t\t\tendingCheckpointSequenceNum: RawTransactionArgument<number | bigint>,\n\t\t\t\tepoch: RawTransactionArgument<number>,\n\t\t  ];\n}\n/** Certifies a blob containing Walrus events. */\nexport function certifyEventBlob(options: CertifyEventBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u256',\n\t\t'u256',\n\t\t'u64',\n\t\t'u8',\n\t\t'u64',\n\t\t'u32',\n\t] satisfies string[];\n\tconst parameterNames = [\n\t\t'system',\n\t\t'cap',\n\t\t'blobId',\n\t\t'rootHash',\n\t\t'size',\n\t\t'encodingType',\n\t\t'endingCheckpointSequenceNum',\n\t\t'epoch',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'certify_event_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ReserveSpaceArguments {\n\tself: RawTransactionArgument<string>;\n\tstorageAmount: RawTransactionArgument<number | bigint>;\n\tepochsAhead: RawTransactionArgument<number>;\n\tpayment: RawTransactionArgument<string>;\n}\nexport interface ReserveSpaceOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ReserveSpaceArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstorageAmount: RawTransactionArgument<number | bigint>,\n\t\t\t\tepochsAhead: RawTransactionArgument<number>,\n\t\t\t\tpayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Allows buying a storage reservation for a given period of epochs. */\nexport function reserveSpace(options: ReserveSpaceOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t'u64',\n\t\t'u32',\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'storageAmount', 'epochsAhead', 'payment'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'reserve_space',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ReserveSpaceForEpochsArguments {\n\tself: RawTransactionArgument<string>;\n\tstorageAmount: RawTransactionArgument<number | bigint>;\n\tstartEpoch: RawTransactionArgument<number>;\n\tendEpoch: RawTransactionArgument<number>;\n\tpayment: RawTransactionArgument<string>;\n}\nexport interface ReserveSpaceForEpochsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ReserveSpaceForEpochsArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstorageAmount: RawTransactionArgument<number | bigint>,\n\t\t\t\tstartEpoch: RawTransactionArgument<number>,\n\t\t\t\tendEpoch: RawTransactionArgument<number>,\n\t\t\t\tpayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Allows buying a storage reservation for a given period of epochs.\n *\n * Returns a storage resource for the period between `start_epoch` (inclusive) and\n * `end_epoch` (exclusive). If `start_epoch` has already passed, reserves space\n * starting from the current epoch.\n */\nexport function reserveSpaceForEpochs(options: ReserveSpaceForEpochsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t'u64',\n\t\t'u32',\n\t\t'u32',\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'storageAmount', 'startEpoch', 'endEpoch', 'payment'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'reserve_space_for_epochs',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RegisterBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tstorage: RawTransactionArgument<string>;\n\tblobId: RawTransactionArgument<number | bigint>;\n\trootHash: RawTransactionArgument<number | bigint>;\n\tsize: RawTransactionArgument<number | bigint>;\n\tencodingType: RawTransactionArgument<number>;\n\tdeletable: RawTransactionArgument<boolean>;\n\twritePayment: RawTransactionArgument<string>;\n}\nexport interface RegisterBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RegisterBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstorage: RawTransactionArgument<string>,\n\t\t\t\tblobId: RawTransactionArgument<number | bigint>,\n\t\t\t\trootHash: RawTransactionArgument<number | bigint>,\n\t\t\t\tsize: RawTransactionArgument<number | bigint>,\n\t\t\t\tencodingType: RawTransactionArgument<number>,\n\t\t\t\tdeletable: RawTransactionArgument<boolean>,\n\t\t\t\twritePayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Registers a new blob in the system. `size` is the size of the unencoded blob.\n * The reserved space in `storage` must be at least the size of the encoded blob.\n */\nexport function registerBlob(options: RegisterBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t\t'u256',\n\t\t'u256',\n\t\t'u64',\n\t\t'u8',\n\t\t'bool',\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t] satisfies string[];\n\tconst parameterNames = [\n\t\t'self',\n\t\t'storage',\n\t\t'blobId',\n\t\t'rootHash',\n\t\t'size',\n\t\t'encodingType',\n\t\t'deletable',\n\t\t'writePayment',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'register_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CertifyBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tsignersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface CertifyBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CertifyBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tblob: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tsignersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/**\n * Certify that a blob will be available in the storage system until the end epoch\n * of the storage associated with it.\n */\nexport function certifyBlob(options: CertifyBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'blob', 'signature', 'signersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'certify_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DeleteBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n}\nexport interface DeleteBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| DeleteBlobArguments\n\t\t| [self: RawTransactionArgument<string>, blob: RawTransactionArgument<string>];\n}\n/** Deletes a deletable blob and returns the contained storage resource. */\nexport function deleteBlob(options: DeleteBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::blob::Blob`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'blob'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'delete_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ExtendBlobWithResourceArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n\textension: RawTransactionArgument<string>;\n}\nexport interface ExtendBlobWithResourceOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ExtendBlobWithResourceArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tblob: RawTransactionArgument<string>,\n\t\t\t\textension: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Extend the period of validity of a blob with a new storage resource. The new\n * storage resource must be the same size as the storage resource used in the blob,\n * and have a longer period of validity.\n */\nexport function extendBlobWithResource(options: ExtendBlobWithResourceOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::blob::Blob`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'blob', 'extension'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'extend_blob_with_resource',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ExtendBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n\textendedEpochs: RawTransactionArgument<number>;\n\tpayment: RawTransactionArgument<string>;\n}\nexport interface ExtendBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ExtendBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tblob: RawTransactionArgument<string>,\n\t\t\t\textendedEpochs: RawTransactionArgument<number>,\n\t\t\t\tpayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Extend the period of validity of a blob by extending its contained storage\n * resource by `extended_epochs` epochs.\n */\nexport function extendBlob(options: ExtendBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'u32',\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'blob', 'extendedEpochs', 'payment'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'extend_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddSubsidyArguments {\n\tsystem: RawTransactionArgument<string>;\n\tsubsidy: RawTransactionArgument<string>;\n\tepochsAhead: RawTransactionArgument<number>;\n}\nexport interface AddSubsidyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddSubsidyArguments\n\t\t| [\n\t\t\t\tsystem: RawTransactionArgument<string>,\n\t\t\t\tsubsidy: RawTransactionArgument<string>,\n\t\t\t\tepochsAhead: RawTransactionArgument<number>,\n\t\t  ];\n}\n/**\n * Adds rewards to the system for the specified number of epochs ahead. The rewards\n * are split equally across the future accounting ring buffer up to the specified\n * epoch.\n */\nexport function addSubsidy(options: AddSubsidyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t\t'u32',\n\t] satisfies string[];\n\tconst parameterNames = ['system', 'subsidy', 'epochsAhead'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'add_subsidy',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddPerEpochSubsidiesArguments {\n\tsystem: RawTransactionArgument<string>;\n\tsubsidies: RawTransactionArgument<string[]>;\n}\nexport interface AddPerEpochSubsidiesOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddPerEpochSubsidiesArguments\n\t\t| [system: RawTransactionArgument<string>, subsidies: RawTransactionArgument<string[]>];\n}\n/**\n * Adds rewards to the system for future epochs, where `subsidies[i]` is added to\n * the rewards of epoch `system.epoch() + i`.\n */\nexport function addPerEpochSubsidies(options: AddPerEpochSubsidiesOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`vector<0x0000000000000000000000000000000000000000000000000000000000000002::balance::Balance<${packageAddress}::wal::WAL>>`,\n\t] satisfies string[];\n\tconst parameterNames = ['system', 'subsidies'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'add_per_epoch_subsidies',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface UpdateProtocolVersionArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface UpdateProtocolVersionOptions {\n\tpackage?: string;\n\targuments:\n\t\t| UpdateProtocolVersionArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Node collects signatures on the protocol version event and emits it. */\nexport function updateProtocolVersion(options: UpdateProtocolVersionOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'update_protocol_version',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RegisterDenyListUpdateArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tdenyListRoot: RawTransactionArgument<number | bigint>;\n\tdenyListSequence: RawTransactionArgument<number | bigint>;\n}\nexport interface RegisterDenyListUpdateOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RegisterDenyListUpdateArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tdenyListRoot: RawTransactionArgument<number | bigint>,\n\t\t\t\tdenyListSequence: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Register a deny list update. */\nexport function registerDenyListUpdate(options: RegisterDenyListUpdateOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u256',\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'denyListRoot', 'denyListSequence'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'register_deny_list_update',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface UpdateDenyListArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface UpdateDenyListOptions {\n\tpackage?: string;\n\targuments:\n\t\t| UpdateDenyListArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Perform the update of the deny list. */\nexport function updateDenyList(options: UpdateDenyListOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'update_deny_list',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DeleteDenyListedBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface DeleteDenyListedBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| DeleteDenyListedBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Delete a blob that is deny listed by f+1 members. */\nexport function deleteDenyListedBlob(options: DeleteDenyListedBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'delete_deny_listed_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface EpochOptions {\n\tpackage?: string;\n\targuments: EpochArguments | [self: RawTransactionArgument<string>];\n}\n/** Get epoch. Uses the committee to get the epoch. */\nexport function epoch(options: EpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface TotalCapacitySizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface TotalCapacitySizeOptions {\n\tpackage?: string;\n\targuments: TotalCapacitySizeArguments | [self: RawTransactionArgument<string>];\n}\n/** Accessor for total capacity size. */\nexport function totalCapacitySize(options: TotalCapacitySizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'total_capacity_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface UsedCapacitySizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface UsedCapacitySizeOptions {\n\tpackage?: string;\n\targuments: UsedCapacitySizeArguments | [self: RawTransactionArgument<string>];\n}\n/** Accessor for used capacity size. */\nexport function usedCapacitySize(options: UsedCapacitySizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'used_capacity_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface NShardsArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface NShardsOptions {\n\tpackage?: string;\n\targuments: NShardsArguments | [self: RawTransactionArgument<string>];\n}\n/** Accessor for the number of shards. */\nexport function nShards(options: NShardsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'n_shards',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FutureAccountingArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface FutureAccountingOptions {\n\tpackage?: string;\n\targuments: FutureAccountingArguments | [self: RawTransactionArgument<string>];\n}\n/** Read-only access to the accounting ring buffer. */\nexport function futureAccounting(options: FutureAccountingOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'future_accounting',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface VersionArguments {\n\tsystem: RawTransactionArgument<string>;\n}\nexport interface VersionOptions {\n\tpackage?: string;\n\targuments: VersionArguments | [system: RawTransactionArgument<string>];\n}\nexport function version(options: VersionOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['system'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'version',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n"],
  "mappings": "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",
  "names": []
}

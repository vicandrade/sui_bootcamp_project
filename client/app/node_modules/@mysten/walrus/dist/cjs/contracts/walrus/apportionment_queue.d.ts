import type { BcsType } from '@mysten/sui/bcs';
import { MoveStruct } from '../utils/index.js';
import type { RawTransactionArgument } from '../utils/index.js';
import type { Transaction } from '@mysten/sui/transactions';
export declare function Entry<T extends BcsType<any>>(...typeParameters: [T]): MoveStruct<{
    priority: import("../utils/index.js").MoveTuple<BcsType<string, string | number | bigint, "u128">[], "std::uq64_64::UQ64_64">;
    tie_breaker: BcsType<string, string | number | bigint, "u64">;
    value: T;
}, `@local-pkg/walrus::apportionment_queue::Entry<${T["name"]}>`>;
/** Struct representing a priority queue. */
export declare function ApportionmentQueue<T extends BcsType<any>>(...typeParameters: [T]): MoveStruct<{
    /**
     * The `entries` vector contains a max heap, where the children of the node at
     * index `i` are at indices `2 * i + 1` and `2 * i + 2`. INV: The parent node's
     * priority is always higher or equal to its child nodes' priorities.
     */
    entries: BcsType<{
        priority: string[];
        tie_breaker: string;
        value: T extends BcsType<infer U, any, string> ? U : never;
    }[], Iterable<{
        priority: (string | number | bigint)[];
        tie_breaker: string | number | bigint;
        value: T extends BcsType<any, infer U_1, string> ? U_1 : never;
    }> & {
        length: number;
    }, string>;
}, `@local-pkg/walrus::apportionment_queue::ApportionmentQueue<${T["name"]}>`>;
export interface NewOptions {
    package?: string;
    arguments?: [];
    typeArguments: [string];
}
/** Create a new priority queue. */
export declare function _new(options: NewOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface PopMaxArguments {
    pq: RawTransactionArgument<string>;
}
export interface PopMaxOptions {
    package?: string;
    arguments: PopMaxArguments | [pq: RawTransactionArgument<string>];
    typeArguments: [string];
}
/** Pop the entry with the highest priority value. */
export declare function popMax(options: PopMaxOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface InsertArguments<T extends BcsType<any>> {
    pq: RawTransactionArgument<string>;
    priority: RawTransactionArgument<string>;
    tieBreaker: RawTransactionArgument<number | bigint>;
    value: RawTransactionArgument<T>;
}
export interface InsertOptions<T extends BcsType<any>> {
    package?: string;
    arguments: InsertArguments<T> | [
        pq: RawTransactionArgument<string>,
        priority: RawTransactionArgument<string>,
        tieBreaker: RawTransactionArgument<number | bigint>,
        value: RawTransactionArgument<T>
    ];
    typeArguments: [string];
}
/** Insert a new entry into the queue. */
export declare function insert<T extends BcsType<any>>(options: InsertOptions<T>): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var staking_pool_exports = {};
__export(staking_pool_exports, {
  PoolState: () => PoolState,
  StakingPool: () => StakingPool,
  VotingParams: () => VotingParams
});
module.exports = __toCommonJS(staking_pool_exports);
var import_utils = require("../utils/index.js");
var import_bcs = require("@mysten/sui/bcs");
var object = __toESM(require("./deps/sui/object.js"));
var storage_node = __toESM(require("./storage_node.js"));
var pending_values = __toESM(require("./pending_values.js"));
var table = __toESM(require("./deps/sui/table.js"));
var balance = __toESM(require("./deps/sui/balance.js"));
var auth = __toESM(require("./auth.js"));
var bag = __toESM(require("./deps/sui/bag.js"));
const $moduleName = "@local-pkg/walrus::staking_pool";
const VotingParams = new import_utils.MoveStruct({
  name: `${$moduleName}::VotingParams`,
  fields: {
    /** Voting: storage price for the next epoch. */
    storage_price: import_bcs.bcs.u64(),
    /** Voting: write price for the next epoch. */
    write_price: import_bcs.bcs.u64(),
    /** Voting: node capacity for the next epoch. */
    node_capacity: import_bcs.bcs.u64()
  }
});
const PoolState = new import_utils.MoveEnum({
  name: `${$moduleName}::PoolState`,
  fields: {
    Active: null,
    Withdrawing: import_bcs.bcs.u32(),
    Withdrawn: null
  }
});
const StakingPool = new import_utils.MoveStruct({
  name: `${$moduleName}::StakingPool`,
  fields: {
    id: object.UID,
    /** The current state of the pool. */
    state: PoolState,
    /** Current epoch's pool parameters. */
    voting_params: VotingParams,
    /** The storage node info for the pool. */
    node_info: storage_node.StorageNodeInfo,
    /**
     * The epoch when the pool is / will be activated. Serves information purposes
     * only, the checks are performed in the `state` property.
     */
    activation_epoch: import_bcs.bcs.u32(),
    /** Epoch when the pool was last updated. */
    latest_epoch: import_bcs.bcs.u32(),
    /** Currently staked WAL in the pool + rewards pool. */
    wal_balance: import_bcs.bcs.u64(),
    /** The total number of shares in the current epoch. */
    num_shares: import_bcs.bcs.u64(),
    /**
     * The amount of the shares that will be withdrawn in E+1 or E+2. We use this
     * amount to calculate the WAL withdrawal in the `process_pending_stake`.
     */
    pending_shares_withdraw: pending_values.PendingValues,
    /**
     * The amount of the stake requested for withdrawal for a node that may part of the
     * next committee. Stores principals of not yet active stakes. In practice, those
     * tokens are staked for exactly one epoch.
     */
    pre_active_withdrawals: pending_values.PendingValues,
    /**
     * The pending commission rate for the pool. Commission rate is applied in E+2, so
     * we store the value for the matching epoch and apply it in the `advance_epoch`
     * function.
     */
    pending_commission_rate: pending_values.PendingValues,
    /** The commission rate for the pool, in basis points. */
    commission_rate: import_bcs.bcs.u16(),
    /**
     * Historical exchange rates for the pool. The key is the epoch when the exchange
     * rate was set, and the value is the exchange rate (the ratio of the amount of WAL
     * tokens for the pool shares).
     */
    exchange_rates: table.Table,
    /**
     * The amount of stake that will be added to the `wal_balance`. Can hold up to two
     * keys: E+1 and E+2, due to the differences in the activation epoch.
     *
     * ```
     * E+1 -> Balance
     * E+2 -> Balance
     * ```
     *
     * Single key is cleared in the `advance_epoch` function, leaving only the next
     * epoch's stake.
     */
    pending_stake: pending_values.PendingValues,
    /** The rewards that the pool has received from being in the committee. */
    rewards_pool: balance.Balance,
    /** The commission that the pool has received from the rewards. */
    commission: balance.Balance,
    /** An Object or an address which can claim the commission. */
    commission_receiver: auth.Authorized,
    /** An Object or address that can authorize governance actions, such as upgrades. */
    governance_authorized: auth.Authorized,
    /** Reserved for future use and migrations. */
    extra_fields: bag.Bag
  }
});
//# sourceMappingURL=staking_pool.js.map

/** Module: system */
import { MoveStruct } from '../utils/index.js';
import type { RawTransactionArgument } from '../utils/index.js';
import type { Transaction } from '@mysten/sui/transactions';
export declare const System: MoveStruct<{
    id: MoveStruct<{
        id: import("@mysten/sui/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    version: import("@mysten/sui/bcs").BcsType<string, string | number | bigint, "u64">;
    package_id: import("@mysten/sui/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    new_package_id: import("@mysten/sui/bcs").BcsType<string | null, string | Uint8Array<ArrayBufferLike> | null | undefined, "Option<bytes[32]>">;
}, "@local-pkg/walrus::system::System">;
export interface InvalidateBlobIdArguments {
    system: RawTransactionArgument<string>;
    signature: RawTransactionArgument<number[]>;
    membersBitmap: RawTransactionArgument<number[]>;
    message: RawTransactionArgument<number[]>;
}
export interface InvalidateBlobIdOptions {
    package?: string;
    arguments: InvalidateBlobIdArguments | [
        system: RawTransactionArgument<string>,
        signature: RawTransactionArgument<number[]>,
        membersBitmap: RawTransactionArgument<number[]>,
        message: RawTransactionArgument<number[]>
    ];
}
/**
 * === Public Functions === Marks blob as invalid given an invalid blob
 * certificate.
 */
export declare function invalidateBlobId(options: InvalidateBlobIdOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CertifyEventBlobArguments {
    system: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    blobId: RawTransactionArgument<number | bigint>;
    rootHash: RawTransactionArgument<number | bigint>;
    size: RawTransactionArgument<number | bigint>;
    encodingType: RawTransactionArgument<number>;
    endingCheckpointSequenceNum: RawTransactionArgument<number | bigint>;
    epoch: RawTransactionArgument<number>;
}
export interface CertifyEventBlobOptions {
    package?: string;
    arguments: CertifyEventBlobArguments | [
        system: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        blobId: RawTransactionArgument<number | bigint>,
        rootHash: RawTransactionArgument<number | bigint>,
        size: RawTransactionArgument<number | bigint>,
        encodingType: RawTransactionArgument<number>,
        endingCheckpointSequenceNum: RawTransactionArgument<number | bigint>,
        epoch: RawTransactionArgument<number>
    ];
}
/** Certifies a blob containing Walrus events. */
export declare function certifyEventBlob(options: CertifyEventBlobOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ReserveSpaceArguments {
    self: RawTransactionArgument<string>;
    storageAmount: RawTransactionArgument<number | bigint>;
    epochsAhead: RawTransactionArgument<number>;
    payment: RawTransactionArgument<string>;
}
export interface ReserveSpaceOptions {
    package?: string;
    arguments: ReserveSpaceArguments | [
        self: RawTransactionArgument<string>,
        storageAmount: RawTransactionArgument<number | bigint>,
        epochsAhead: RawTransactionArgument<number>,
        payment: RawTransactionArgument<string>
    ];
}
/** Allows buying a storage reservation for a given period of epochs. */
export declare function reserveSpace(options: ReserveSpaceOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ReserveSpaceForEpochsArguments {
    self: RawTransactionArgument<string>;
    storageAmount: RawTransactionArgument<number | bigint>;
    startEpoch: RawTransactionArgument<number>;
    endEpoch: RawTransactionArgument<number>;
    payment: RawTransactionArgument<string>;
}
export interface ReserveSpaceForEpochsOptions {
    package?: string;
    arguments: ReserveSpaceForEpochsArguments | [
        self: RawTransactionArgument<string>,
        storageAmount: RawTransactionArgument<number | bigint>,
        startEpoch: RawTransactionArgument<number>,
        endEpoch: RawTransactionArgument<number>,
        payment: RawTransactionArgument<string>
    ];
}
/**
 * Allows buying a storage reservation for a given period of epochs.
 *
 * Returns a storage resource for the period between `start_epoch` (inclusive) and
 * `end_epoch` (exclusive). If `start_epoch` has already passed, reserves space
 * starting from the current epoch.
 */
export declare function reserveSpaceForEpochs(options: ReserveSpaceForEpochsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RegisterBlobArguments {
    self: RawTransactionArgument<string>;
    storage: RawTransactionArgument<string>;
    blobId: RawTransactionArgument<number | bigint>;
    rootHash: RawTransactionArgument<number | bigint>;
    size: RawTransactionArgument<number | bigint>;
    encodingType: RawTransactionArgument<number>;
    deletable: RawTransactionArgument<boolean>;
    writePayment: RawTransactionArgument<string>;
}
export interface RegisterBlobOptions {
    package?: string;
    arguments: RegisterBlobArguments | [
        self: RawTransactionArgument<string>,
        storage: RawTransactionArgument<string>,
        blobId: RawTransactionArgument<number | bigint>,
        rootHash: RawTransactionArgument<number | bigint>,
        size: RawTransactionArgument<number | bigint>,
        encodingType: RawTransactionArgument<number>,
        deletable: RawTransactionArgument<boolean>,
        writePayment: RawTransactionArgument<string>
    ];
}
/**
 * Registers a new blob in the system. `size` is the size of the unencoded blob.
 * The reserved space in `storage` must be at least the size of the encoded blob.
 */
export declare function registerBlob(options: RegisterBlobOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CertifyBlobArguments {
    self: RawTransactionArgument<string>;
    blob: RawTransactionArgument<string>;
    signature: RawTransactionArgument<number[]>;
    signersBitmap: RawTransactionArgument<number[]>;
    message: RawTransactionArgument<number[]>;
}
export interface CertifyBlobOptions {
    package?: string;
    arguments: CertifyBlobArguments | [
        self: RawTransactionArgument<string>,
        blob: RawTransactionArgument<string>,
        signature: RawTransactionArgument<number[]>,
        signersBitmap: RawTransactionArgument<number[]>,
        message: RawTransactionArgument<number[]>
    ];
}
/**
 * Certify that a blob will be available in the storage system until the end epoch
 * of the storage associated with it.
 */
export declare function certifyBlob(options: CertifyBlobOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface DeleteBlobArguments {
    self: RawTransactionArgument<string>;
    blob: RawTransactionArgument<string>;
}
export interface DeleteBlobOptions {
    package?: string;
    arguments: DeleteBlobArguments | [self: RawTransactionArgument<string>, blob: RawTransactionArgument<string>];
}
/** Deletes a deletable blob and returns the contained storage resource. */
export declare function deleteBlob(options: DeleteBlobOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ExtendBlobWithResourceArguments {
    self: RawTransactionArgument<string>;
    blob: RawTransactionArgument<string>;
    extension: RawTransactionArgument<string>;
}
export interface ExtendBlobWithResourceOptions {
    package?: string;
    arguments: ExtendBlobWithResourceArguments | [
        self: RawTransactionArgument<string>,
        blob: RawTransactionArgument<string>,
        extension: RawTransactionArgument<string>
    ];
}
/**
 * Extend the period of validity of a blob with a new storage resource. The new
 * storage resource must be the same size as the storage resource used in the blob,
 * and have a longer period of validity.
 */
export declare function extendBlobWithResource(options: ExtendBlobWithResourceOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ExtendBlobArguments {
    self: RawTransactionArgument<string>;
    blob: RawTransactionArgument<string>;
    extendedEpochs: RawTransactionArgument<number>;
    payment: RawTransactionArgument<string>;
}
export interface ExtendBlobOptions {
    package?: string;
    arguments: ExtendBlobArguments | [
        self: RawTransactionArgument<string>,
        blob: RawTransactionArgument<string>,
        extendedEpochs: RawTransactionArgument<number>,
        payment: RawTransactionArgument<string>
    ];
}
/**
 * Extend the period of validity of a blob by extending its contained storage
 * resource by `extended_epochs` epochs.
 */
export declare function extendBlob(options: ExtendBlobOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AddSubsidyArguments {
    system: RawTransactionArgument<string>;
    subsidy: RawTransactionArgument<string>;
    epochsAhead: RawTransactionArgument<number>;
}
export interface AddSubsidyOptions {
    package?: string;
    arguments: AddSubsidyArguments | [
        system: RawTransactionArgument<string>,
        subsidy: RawTransactionArgument<string>,
        epochsAhead: RawTransactionArgument<number>
    ];
}
/**
 * Adds rewards to the system for the specified number of epochs ahead. The rewards
 * are split equally across the future accounting ring buffer up to the specified
 * epoch.
 */
export declare function addSubsidy(options: AddSubsidyOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AddPerEpochSubsidiesArguments {
    system: RawTransactionArgument<string>;
    subsidies: RawTransactionArgument<string[]>;
}
export interface AddPerEpochSubsidiesOptions {
    package?: string;
    arguments: AddPerEpochSubsidiesArguments | [system: RawTransactionArgument<string>, subsidies: RawTransactionArgument<string[]>];
}
/**
 * Adds rewards to the system for future epochs, where `subsidies[i]` is added to
 * the rewards of epoch `system.epoch() + i`.
 */
export declare function addPerEpochSubsidies(options: AddPerEpochSubsidiesOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface UpdateProtocolVersionArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    signature: RawTransactionArgument<number[]>;
    membersBitmap: RawTransactionArgument<number[]>;
    message: RawTransactionArgument<number[]>;
}
export interface UpdateProtocolVersionOptions {
    package?: string;
    arguments: UpdateProtocolVersionArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        signature: RawTransactionArgument<number[]>,
        membersBitmap: RawTransactionArgument<number[]>,
        message: RawTransactionArgument<number[]>
    ];
}
/** Node collects signatures on the protocol version event and emits it. */
export declare function updateProtocolVersion(options: UpdateProtocolVersionOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RegisterDenyListUpdateArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    denyListRoot: RawTransactionArgument<number | bigint>;
    denyListSequence: RawTransactionArgument<number | bigint>;
}
export interface RegisterDenyListUpdateOptions {
    package?: string;
    arguments: RegisterDenyListUpdateArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        denyListRoot: RawTransactionArgument<number | bigint>,
        denyListSequence: RawTransactionArgument<number | bigint>
    ];
}
/** Register a deny list update. */
export declare function registerDenyListUpdate(options: RegisterDenyListUpdateOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface UpdateDenyListArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    signature: RawTransactionArgument<number[]>;
    membersBitmap: RawTransactionArgument<number[]>;
    message: RawTransactionArgument<number[]>;
}
export interface UpdateDenyListOptions {
    package?: string;
    arguments: UpdateDenyListArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        signature: RawTransactionArgument<number[]>,
        membersBitmap: RawTransactionArgument<number[]>,
        message: RawTransactionArgument<number[]>
    ];
}
/** Perform the update of the deny list. */
export declare function updateDenyList(options: UpdateDenyListOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface DeleteDenyListedBlobArguments {
    self: RawTransactionArgument<string>;
    signature: RawTransactionArgument<number[]>;
    membersBitmap: RawTransactionArgument<number[]>;
    message: RawTransactionArgument<number[]>;
}
export interface DeleteDenyListedBlobOptions {
    package?: string;
    arguments: DeleteDenyListedBlobArguments | [
        self: RawTransactionArgument<string>,
        signature: RawTransactionArgument<number[]>,
        membersBitmap: RawTransactionArgument<number[]>,
        message: RawTransactionArgument<number[]>
    ];
}
/** Delete a blob that is deny listed by f+1 members. */
export declare function deleteDenyListedBlob(options: DeleteDenyListedBlobOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface EpochArguments {
    self: RawTransactionArgument<string>;
}
export interface EpochOptions {
    package?: string;
    arguments: EpochArguments | [self: RawTransactionArgument<string>];
}
/** Get epoch. Uses the committee to get the epoch. */
export declare function epoch(options: EpochOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface TotalCapacitySizeArguments {
    self: RawTransactionArgument<string>;
}
export interface TotalCapacitySizeOptions {
    package?: string;
    arguments: TotalCapacitySizeArguments | [self: RawTransactionArgument<string>];
}
/** Accessor for total capacity size. */
export declare function totalCapacitySize(options: TotalCapacitySizeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface UsedCapacitySizeArguments {
    self: RawTransactionArgument<string>;
}
export interface UsedCapacitySizeOptions {
    package?: string;
    arguments: UsedCapacitySizeArguments | [self: RawTransactionArgument<string>];
}
/** Accessor for used capacity size. */
export declare function usedCapacitySize(options: UsedCapacitySizeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface NShardsArguments {
    self: RawTransactionArgument<string>;
}
export interface NShardsOptions {
    package?: string;
    arguments: NShardsArguments | [self: RawTransactionArgument<string>];
}
/** Accessor for the number of shards. */
export declare function nShards(options: NShardsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface FutureAccountingArguments {
    self: RawTransactionArgument<string>;
}
export interface FutureAccountingOptions {
    package?: string;
    arguments: FutureAccountingArguments | [self: RawTransactionArgument<string>];
}
/** Read-only access to the accounting ring buffer. */
export declare function futureAccounting(options: FutureAccountingOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface VersionArguments {
    system: RawTransactionArgument<string>;
}
export interface VersionOptions {
    package?: string;
    arguments: VersionArguments | [system: RawTransactionArgument<string>];
}
export declare function version(options: VersionOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;

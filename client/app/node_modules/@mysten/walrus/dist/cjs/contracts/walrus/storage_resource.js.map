{
  "version": 3,
  "sources": ["../../../../src/contracts/walrus/storage_resource.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/walrus::storage_resource';\nexport const Storage = new MoveStruct({\n\tname: `${$moduleName}::Storage`,\n\tfields: {\n\t\tid: object.UID,\n\t\tstart_epoch: bcs.u32(),\n\t\tend_epoch: bcs.u32(),\n\t\tstorage_size: bcs.u64(),\n\t},\n});\nexport interface StartEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface StartEpochOptions {\n\tpackage?: string;\n\targuments: StartEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function startEpoch(options: StartEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'start_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EndEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface EndEpochOptions {\n\tpackage?: string;\n\targuments: EndEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function endEpoch(options: EndEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'end_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface SizeOptions {\n\tpackage?: string;\n\targuments: SizeArguments | [self: RawTransactionArgument<string>];\n}\nexport function size(options: SizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SplitByEpochArguments {\n\tstorage: RawTransactionArgument<string>;\n\tsplitEpoch: RawTransactionArgument<number>;\n}\nexport interface SplitByEpochOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SplitByEpochArguments\n\t\t| [storage: RawTransactionArgument<string>, splitEpoch: RawTransactionArgument<number>];\n}\n/**\n * Splits the storage object into two based on `split_epoch`.\n *\n * `storage` is modified to cover the period from `start_epoch` to `split_epoch`\n * and a new storage object covering `split_epoch` to `end_epoch` is returned.\n */\nexport function splitByEpoch(options: SplitByEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`, 'u32'] satisfies string[];\n\tconst parameterNames = ['storage', 'splitEpoch'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'split_by_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SplitBySizeArguments {\n\tstorage: RawTransactionArgument<string>;\n\tsplitSize: RawTransactionArgument<number | bigint>;\n}\nexport interface SplitBySizeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SplitBySizeArguments\n\t\t| [storage: RawTransactionArgument<string>, splitSize: RawTransactionArgument<number | bigint>];\n}\n/**\n * Splits the storage object into two based on `split_size`.\n *\n * `storage` is modified to cover `split_size` and a new object covering\n * `storage.storage_size - split_size` is created.\n */\nexport function splitBySize(options: SplitBySizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`, 'u64'] satisfies string[];\n\tconst parameterNames = ['storage', 'splitSize'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'split_by_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FusePeriodsArguments {\n\tfirst: RawTransactionArgument<string>;\n\tsecond: RawTransactionArgument<string>;\n}\nexport interface FusePeriodsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| FusePeriodsArguments\n\t\t| [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];\n}\n/** Fuse two storage objects that cover adjacent periods with the same storage size. */\nexport function fusePeriods(options: FusePeriodsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t] satisfies string[];\n\tconst parameterNames = ['first', 'second'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'fuse_periods',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FuseAmountArguments {\n\tfirst: RawTransactionArgument<string>;\n\tsecond: RawTransactionArgument<string>;\n}\nexport interface FuseAmountOptions {\n\tpackage?: string;\n\targuments:\n\t\t| FuseAmountArguments\n\t\t| [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];\n}\n/** Fuse two storage objects that cover the same period. */\nexport function fuseAmount(options: FuseAmountOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t] satisfies string[];\n\tconst parameterNames = ['first', 'second'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'fuse_amount',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FuseArguments {\n\tfirst: RawTransactionArgument<string>;\n\tsecond: RawTransactionArgument<string>;\n}\nexport interface FuseOptions {\n\tpackage?: string;\n\targuments:\n\t\t| FuseArguments\n\t\t| [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];\n}\n/**\n * Fuse two storage objects that either cover the same period or adjacent periods\n * with the same storage size.\n */\nexport function fuse(options: FuseOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t] satisfies string[];\n\tconst parameterNames = ['first', 'second'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'fuse',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DestroyArguments {\n\tstorage: RawTransactionArgument<string>;\n}\nexport interface DestroyOptions {\n\tpackage?: string;\n\targuments: DestroyArguments | [storage: RawTransactionArgument<string>];\n}\n/** Destructor for [Storage] objects. */\nexport function destroy(options: DestroyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`] satisfies string[];\n\tconst parameterNames = ['storage'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'destroy',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n"],
  "mappings": "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",
  "names": []
}

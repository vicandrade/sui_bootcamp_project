import { SuiClient } from '@mysten/sui/client';
import type { Signer } from '@mysten/sui/cryptography';
import type { ClientWithExtensions } from '@mysten/sui/experimental';
import type { TransactionResult } from '@mysten/sui/transactions';
import { Transaction } from '@mysten/sui/transactions';
import { Blob } from './contracts/walrus/blob.js';
import type { BlobStatus } from './storage-node/types.js';
import type { CertifyBlobOptions, ComputeBlobMetadataOptions, DeleteBlobOptions, ExtendBlobOptions, GetBlobMetadataOptions, GetSecondarySliverOptions, GetSliversOptions, GetStorageConfirmationOptions, GetVerifiedBlobStatusOptions, ProtocolMessageCertificate, ReadBlobOptions, RegisterBlobOptions, SliversForNode, StorageWithSizeOptions, WalrusClientConfig, WalrusClientExtensionOptions, WriteBlobAttributesOptions, WriteBlobOptions, WriteBlobToUploadRelayOptions, WriteEncodedBlobOptions, WriteEncodedBlobToNodesOptions, WriteMetadataOptions, WriteQuiltOptions, WriteSliverOptions, WriteSliversToNodeOptions, WriteFilesOptions, WriteFilesFlowOptions, WriteFilesFlow, WriteBlobFlow, WriteBlobFlowOptions } from './types.js';
import { WalrusBlob } from './files/blob.js';
import { WalrusFile } from './files/file.js';
export declare class WalrusClient {
    #private;
    constructor(config: WalrusClientConfig);
    static experimental_asClientExtension({ packageConfig, network, ...options }?: WalrusClientExtensionOptions): {
        name: "walrus";
        register: (client: ClientWithExtensions<{
            jsonRpc: SuiClient;
        }>) => WalrusClient;
    };
    /** The Move type for a Blob object */
    getBlobType(): string | Promise<string>;
    /** The cached system object for the walrus package */
    systemObject(): Promise<{
        id: {
            id: string;
        };
        version: string;
        package_id: string;
        new_package_id: string | null;
    }>;
    /** The cached staking pool object for the walrus package */
    stakingObject(): Promise<{
        id: {
            id: string;
        };
        version: string;
        package_id: string;
        new_package_id: string | null;
    }>;
    /** The system state for the current version of walrus contract  */
    systemState(): Promise<{
        committee: {
            members: {
                public_key: {
                    bytes: number[];
                };
                weight: number;
                node_id: string;
            }[];
            n_shards: number;
            epoch: number;
            total_aggregated_key: {
                bytes: number[];
            };
        };
        total_capacity_size: string;
        used_capacity_size: string;
        storage_price_per_unit_size: string;
        write_price_per_unit_size: string;
        future_accounting: {
            current_index: number;
            length: number;
            ring_buffer: {
                epoch: number;
                used_capacity: string;
                rewards_to_distribute: {
                    value: string;
                };
            }[];
        };
        event_blob_certification_state: {
            latest_certified_blob: {
                blob_id: string;
                ending_checkpoint_sequence_number: string;
            } | null;
            aggregate_weight_per_blob: {
                contents: {
                    key: {
                        blob_id: string;
                        ending_checkpoint_sequence_number: string;
                    };
                    value: number;
                }[];
            };
        };
        deny_list_sizes: {
            id: {
                id: string;
            };
        };
    }>;
    /** The staking state for the current version of walrus contract */
    stakingState(): Promise<{
        n_shards: number;
        epoch_duration: string;
        first_epoch_start: string;
        pools: {
            id: {
                id: string;
            };
            size: string;
        };
        epoch: number;
        active_set: {
            id: {
                id: string;
            };
        };
        next_committee: {
            contents: {
                key: string;
                value: number[];
            }[];
        }[] | null;
        committee: {
            contents: {
                key: string;
                value: number[];
            }[];
        }[];
        previous_committee: {
            contents: {
                key: string;
                value: number[];
            }[];
        }[];
        next_epoch_params: {
            total_capacity_size: string;
            storage_price_per_unit_size: string;
            write_price_per_unit_size: string;
        } | null;
        epoch_state: import("@mysten/bcs").EnumOutputShapeWithKeys<{
            EpochChangeSync: number;
            EpochChangeDone: string;
            NextParamsSelected: string;
        }, "EpochChangeSync" | "EpochChangeDone" | "NextParamsSelected">;
        next_epoch_public_keys: {
            id: {
                id: string;
            };
        };
    }>;
    /** Read a blob from the storage nodes */
    readBlob: ({ blobId, signal }: ReadBlobOptions) => Promise<Uint8Array<ArrayBufferLike>>;
    computeBlobMetadata({ bytes, numShards }: ComputeBlobMetadataOptions): Promise<{
        rootHash: Uint8Array<ArrayBufferLike>;
        blobId: string;
        metadata: {
            encodingType: "RedStuff" | "RS2" | {
                RedStuff: boolean | object | null;
            } | {
                RS2: boolean | object | null;
            };
            hashes: {
                primaryHash: import("@mysten/bcs").EnumInputShape<{
                    Empty: boolean | object | null;
                    Digest: Iterable<number>;
                }>;
                secondaryHash: import("@mysten/bcs").EnumInputShape<{
                    Empty: boolean | object | null;
                    Digest: Iterable<number>;
                }>;
            }[];
            unencodedLength: string | number | bigint;
        };
        nonce: Uint8Array<ArrayBuffer>;
        blobDigest: () => Promise<Uint8Array<ArrayBufferLike>>;
    }>;
    getBlobMetadata({ blobId, signal }: GetBlobMetadataOptions): Promise<{
        blobId: string;
        metadata: {
            V1: {
                encoding_type: import("@mysten/bcs").EnumOutputShapeWithKeys<{
                    RedStuff: true;
                    RS2: true;
                }, "RedStuff" | "RS2">;
                unencoded_length: string;
                hashes: {
                    primary_hash: import("@mysten/bcs").EnumOutputShapeWithKeys<{
                        Empty: true;
                        Digest: Uint8Array<ArrayBufferLike>;
                    }, "Empty" | "Digest">;
                    secondary_hash: import("@mysten/bcs").EnumOutputShapeWithKeys<{
                        Empty: true;
                        Digest: Uint8Array<ArrayBufferLike>;
                    }, "Empty" | "Digest">;
                }[];
            };
            $kind: "V1";
        };
    }>;
    getSecondarySliver: ({ blobId, index, signal }: GetSecondarySliverOptions) => Promise<{
        symbols: {
            data: number[];
            symbol_size: number;
        };
        index: number;
    }>;
    internalGetSecondarySliver({ blobId, index, signal }: GetSecondarySliverOptions): Promise<{
        symbols: {
            data: number[];
            symbol_size: number;
        };
        index: number;
    }>;
    getSlivers({ blobId, signal }: GetSliversOptions): Promise<{
        symbols: {
            data: number[];
            symbol_size: number;
        };
        index: number;
    }[]>;
    /**
     * Gets the blob status from multiple storage nodes and returns the latest status that can be verified.
     */
    getVerifiedBlobStatus({ blobId, signal }: GetVerifiedBlobStatusOptions): Promise<BlobStatus>;
    /**
     * Calculate the cost of storing a blob for a given a size and number of epochs.
     */
    storageCost(size: number, epochs: number): Promise<{
        storageCost: bigint;
        writeCost: bigint;
        totalCost: bigint;
    }>;
    /**
     * A utility for creating a storage object in a transaction.
     *
     * @usage
     * ```ts
     * tx.transferObjects([client.createStorage({ size: 1000, epochs: 3 })], owner);
     * ```
     */
    createStorage({ size, epochs, walCoin }: StorageWithSizeOptions): (tx: Transaction) => Promise<TransactionResult>;
    /**
     * Create a transaction that creates a storage object
     *
     * @usage
     * ```ts
     * const tx = client.createStorageTransaction({ size: 1000, epochs: 3, owner: signer.toSuiAddress() });
     * ```
     */
    createStorageTransaction({ transaction, size, epochs, owner, }: StorageWithSizeOptions & {
        transaction?: Transaction;
        /** Address the storage resource should be transferred to */
        owner: string;
    }): Transaction;
    /**
     * Execute a transaction that creates a storage object
     *
     * @usage
     * ```ts
     * const { digest, storage } = await client.executeCreateStorageTransaction({ size: 1000, epochs: 3, signer });
     * ```
     */
    executeCreateStorageTransaction({ signer, ...options }: StorageWithSizeOptions & {
        transaction?: Transaction;
        signer: Signer;
    }): Promise<{
        digest: string;
        storage: {
            id: {
                id: string;
            };
            start_epoch: number;
            end_epoch: number;
            storage_size: string;
        };
    }>;
    /**
     * Register a blob in a transaction
     *
     * @usage
     * ```ts
     * tx.transferObjects([client.registerBlob({ size: 1000, epochs: 3, blobId, rootHash, deletable: true })], owner);
     * ```
     */
    registerBlob({ size, epochs, blobId, rootHash, deletable, walCoin, attributes, }: RegisterBlobOptions): (tx: Transaction) => Promise<TransactionResult>;
    addAuthPayload({ size, blobDigest, nonce, }: {
        size: number;
        blobDigest: Uint8Array | (() => Promise<Uint8Array>);
        nonce: Uint8Array;
    }): (transaction: Transaction) => Promise<void>;
    calculateUploadRelayTip(options: {
        size: number;
    }): Promise<number | bigint>;
    sendUploadRelayTip({ size, blobDigest, nonce, }: {
        size: number;
        blobDigest: Uint8Array | (() => Promise<Uint8Array>);
        nonce: Uint8Array;
    }): (transaction: Transaction) => Promise<void>;
    /**
     * Create a transaction that registers a blob
     *
     * @usage
     * ```ts
     * const tx = client.registerBlobTransaction({ size: 1000, epochs: 3, blobId, rootHash, deletable: true });
     * ```
     */
    registerBlobTransaction({ transaction, ...options }: RegisterBlobOptions & {
        transaction?: Transaction;
        /** Address the blob should be transferred to */
        owner: string;
    }): Transaction;
    /**
     * Execute a transaction that registers a blob
     *
     * @usage
     * ```ts
     * const { digest, blob } = await client.executeRegisterBlobTransaction({ size: 1000, epochs: 3, signer });
     * ```
     */
    executeRegisterBlobTransaction({ signer, ...options }: RegisterBlobOptions & {
        transaction?: Transaction;
        signer: Signer;
        /** Address the blob should be transferred to */
        owner?: string;
    }): Promise<{
        blob: (typeof Blob)['$inferType'];
        digest: string;
    }>;
    certificateFromConfirmations({ confirmations, blobId, deletable, blobObjectId, }: Extract<CertifyBlobOptions, {
        confirmations: unknown[];
    }>): Promise<ProtocolMessageCertificate>;
    /**
     * Certify a blob in a transaction
     *
     * @usage
     * ```ts
     * tx.add(client.certifyBlob({ blobId, blobObjectId, confirmations }));
     * ```
     */
    certifyBlob({ blobId, blobObjectId, confirmations, certificate, deletable }: CertifyBlobOptions): (tx: Transaction) => Promise<void>;
    /**
     * Create a transaction that certifies a blob
     *
     * @usage
     * ```ts
     * const tx = client.certifyBlobTransaction({ blobId, blobObjectId, confirmations });
     * ```
     */
    certifyBlobTransaction({ transaction, ...options }: CertifyBlobOptions & {
        transaction?: Transaction;
    }): Transaction;
    /**
     * Execute a transaction that certifies a blob
     *
     * @usage
     * ```ts
     * const { digest } = await client.executeCertifyBlobTransaction({ blobId, blobObjectId, confirmations, signer });
     * ```
     */
    executeCertifyBlobTransaction({ signer, ...options }: CertifyBlobOptions & {
        transaction?: Transaction;
        signer: Signer;
    }): Promise<{
        digest: string;
    }>;
    /**
     * Delete a blob in a transaction
     *
     * @usage
     * ```ts
     * const storage = await client.deleteBlob({ blobObjectId });
     * tx.transferObjects([storage], owner);
     * ```
     */
    deleteBlob({ blobObjectId }: DeleteBlobOptions): (tx: Transaction) => Promise<TransactionResult>;
    /**
     * Create a transaction that deletes a blob
     *
     * @usage
     * ```ts
     * const tx = client.deleteBlobTransaction({ blobObjectId, owner });
     * ```
     */
    deleteBlobTransaction({ owner, blobObjectId, transaction, }: DeleteBlobOptions & {
        transaction?: Transaction;
        /** Address the storage resource should be returned to */
        owner: string;
    }): Transaction;
    /**
     * Execute a transaction that deletes a blob
     *
     * @usage
     * ```ts
     * const { digest } = await client.executeDeleteBlobTransaction({ blobObjectId, signer });
     * ```
     */
    executeDeleteBlobTransaction({ signer, transaction, blobObjectId, }: DeleteBlobOptions & {
        signer: Signer;
        transaction?: Transaction;
    }): Promise<{
        digest: string;
    }>;
    /**
     * Extend a blob in a transaction
     *
     * @usage
     * ```ts
     * const tx = client.extendBlobTransaction({ blobObjectId, epochs });
     * ```
     */
    extendBlob({ blobObjectId, epochs, endEpoch, walCoin }: ExtendBlobOptions): (tx: Transaction) => Promise<void>;
    /**
     * Create a transaction that extends a blob
     *
     * @usage
     * ```ts
     * const tx = client.extendBlobTransaction({ blobObjectId, epochs });
     * ```
     */
    extendBlobTransaction({ transaction, ...options }: ExtendBlobOptions & {
        transaction?: Transaction;
    }): Promise<Transaction>;
    /**
     * Execute a transaction that extends a blob
     *
     * @usage
     * ```ts
     * const { digest } = await client.executeExtendBlobTransaction({ blobObjectId, signer });
     * ```
     */
    executeExtendBlobTransaction({ signer, ...options }: ExtendBlobOptions & {
        signer: Signer;
        transaction?: Transaction;
    }): Promise<{
        digest: string;
    }>;
    readBlobAttributes({ blobObjectId, }: {
        blobObjectId: string;
    }): Promise<Record<string, string> | null>;
    /**
     * Write attributes to a blob
     *
     * If attributes already exists, their previous values will be overwritten
     * If an attribute is set to `null`, it will be removed from the blob
     *
     * @usage
     * ```ts
     * tx.add(client.writeBlobAttributes({ blobObjectId, attributes: { key: 'value', keyToRemove: null } }));
     * ```
     */
    writeBlobAttributes({ blobObject, blobObjectId, attributes }: WriteBlobAttributesOptions): (tx: Transaction) => Promise<void>;
    /**
     * Create a transaction that writes attributes to a blob
     *
     * If attributes already exists, their previous values will be overwritten
     * If an attribute is set to `null`, it will be removed from the blob
     *
     * @usage
     * ```ts
     * const tx = client.writeBlobAttributesTransaction({ blobObjectId, attributes: { key: 'value', keyToRemove: null } });
     * ```
     */
    writeBlobAttributesTransaction({ transaction, ...options }: WriteBlobAttributesOptions & {
        transaction?: Transaction;
    }): Promise<Transaction>;
    /**
     * Execute a transaction that writes attributes to a blob
     *
     * If attributes already exists, their previous values will be overwritten
     * If an attribute is set to `null`, it will be removed from the blob
     *
     * @usage
     * ```ts
     * const { digest } = await client.executeWriteBlobAttributesTransaction({ blobObjectId, signer });
     * ```
     */
    executeWriteBlobAttributesTransaction({ signer, ...options }: WriteBlobAttributesOptions & {
        signer: Signer;
        transaction?: Transaction;
    }): Promise<{
        digest: string;
    }>;
    /**
     * Write a sliver to a storage node
     *
     * @usage
     * ```ts
     * const res = await client.writeSliver({ blobId, sliverPairIndex, sliverType, sliver });
     * ```
     */
    writeSliver({ blobId, sliverPairIndex, sliverType, sliver, signal }: WriteSliverOptions): Promise<import("./storage-node/types.js").StoreSliverResponse>;
    /**
     * Write metadata to a storage node
     *
     * @usage
     * ```ts
     * const res = await client.writeMetadataToNode({ nodeIndex, blobId, metadata });
     * ```
     */
    writeMetadataToNode({ nodeIndex, blobId, metadata, signal }: WriteMetadataOptions): Promise<import("./storage-node/types.js").StoreBlobMetadataResponse>;
    /**
     * Get a storage confirmation from a storage node
     *
     * @usage
     * ```ts
     * const confirmation = await client.getStorageConfirmationFromNode({ nodeIndex, blobId, deletable, objectId });
     * ```
     */
    getStorageConfirmationFromNode({ nodeIndex, blobId, deletable, objectId, signal, }: GetStorageConfirmationOptions): Promise<import("./storage-node/types.js").StorageConfirmation>;
    /**
     * Encode a blob into slivers for each node
     *
     * @usage
     * ```ts
     * const { blobId, metadata, sliversByNode, rootHash } = await client.encodeBlob(blob);
     * ```
     */
    encodeBlob(blob: Uint8Array): Promise<{
        blobId: string;
        metadata: {
            V1: {
                encoding_type: "RedStuff" | "RS2" | {
                    RedStuff: boolean | object | null;
                } | {
                    RS2: boolean | object | null;
                };
                unencoded_length: string | number | bigint;
                hashes: Iterable<{
                    primary_hash: import("@mysten/bcs").EnumInputShape<{
                        Empty: boolean | object | null;
                        Digest: Iterable<number>;
                    }>;
                    secondary_hash: import("@mysten/bcs").EnumInputShape<{
                        Empty: boolean | object | null;
                        Digest: Iterable<number>;
                    }>;
                }> & {
                    length: number;
                };
            };
        };
        rootHash: Uint8Array<ArrayBufferLike>;
        sliversByNode: SliversForNode[];
    }>;
    /**
     * Write slivers to a storage node
     *
     * @usage
     * ```ts
     * await client.writeSliversToNode({ blobId, slivers, signal });
     * ```
     */
    writeSliversToNode({ blobId, slivers, signal }: WriteSliversToNodeOptions): Promise<void>;
    /**
     * Write a blob to all storage nodes
     *
     * @usage
     * ```ts
     * await client.writeEncodedBlobToNodes({ blob, deletable, epochs, signer });
     * ```
     */
    writeEncodedBlobToNodes({ blobId, metadata, sliversByNode, signal, ...options }: WriteEncodedBlobToNodesOptions): Promise<(import("./storage-node/types.js").StorageConfirmation | null)[]>;
    /**
     * Writes a blob to to an upload relay
     *
     * @usage
     * ```ts
     * await client.writeBlobToUploadRelay({ blob, deletable, epochs, signer });
     * ```
     */
    writeBlobToUploadRelay(options: WriteBlobToUploadRelayOptions): Promise<{
        blobId: string;
        certificate: ProtocolMessageCertificate;
    }>;
    /**
     * Write encoded blob to a storage node
     *
     * @usage
     * ```ts
     * const res = await client.writeEncodedBlobToNode({ nodeIndex, blobId, metadata, slivers });
     * ```
     */
    writeEncodedBlobToNode({ nodeIndex, blobId, metadata, slivers, signal, ...options }: WriteEncodedBlobOptions): Promise<import("./storage-node/types.js").StorageConfirmation>;
    /**
     * Write a blob to all storage nodes
     *
     * @usage
     * ```ts
     * const { blobId, blobObject } = await client.writeBlob({ blob, deletable, epochs, signer });
     * ```
     */
    writeBlob({ blob, deletable, epochs, signer, signal, owner, attributes, }: WriteBlobOptions): Promise<{
        blobId: string;
        blobObject: {
            id: {
                id: string;
            };
            registered_epoch: number;
            blob_id: string;
            size: string;
            encoding_type: number;
            certified_epoch: number | null;
            storage: {
                id: {
                    id: string;
                };
                start_epoch: number;
                end_epoch: number;
                storage_size: string;
            };
            deletable: boolean;
        };
    }>;
    writeQuilt({ blobs, ...options }: WriteQuiltOptions): Promise<{
        index: {
            patches: {
                patchId: string;
                endIndex: number;
                identifier: string;
                tags: Map<string, string> | Record<string, string>;
                startIndex: number;
            }[];
        };
        blobId: string;
        blobObject: {
            id: {
                id: string;
            };
            registered_epoch: number;
            blob_id: string;
            size: string;
            encoding_type: number;
            certified_epoch: number | null;
            storage: {
                id: {
                    id: string;
                };
                start_epoch: number;
                end_epoch: number;
                storage_size: string;
            };
            deletable: boolean;
        };
    }>;
    encodeQuilt({ blobs, }: {
        blobs: {
            contents: Uint8Array;
            identifier: string;
            tags?: Record<string, string>;
        }[];
    }): Promise<{
        quilt: Uint8Array<ArrayBuffer>;
        index: {
            patches: ({
                endIndex: number;
                identifier: string;
                tags: Map<string, string> | Record<string, string>;
            } & {
                startIndex: number;
            })[];
        };
    }>;
    /**
     * Reset cached data in the client
     *
     * @usage
     * ```ts
     * client.reset();
     * ```
     */
    reset(): void;
    getBlob({ blobId }: {
        blobId: string;
    }): Promise<WalrusBlob>;
    getFiles({ ids }: {
        ids: string[];
    }): Promise<WalrusFile[]>;
    writeFiles({ files, ...options }: WriteFilesOptions): Promise<{
        id: string;
        blobId: string;
        blobObject: {
            id: {
                id: string;
            };
            registered_epoch: number;
            blob_id: string;
            size: string;
            encoding_type: number;
            certified_epoch: number | null;
            storage: {
                id: {
                    id: string;
                };
                start_epoch: number;
                end_epoch: number;
                storage_size: string;
            };
            deletable: boolean;
        };
    }[]>;
    writeFilesFlow({ files }: WriteFilesFlowOptions): WriteFilesFlow;
    writeBlobFlow({ blob }: WriteBlobFlowOptions): WriteBlobFlow;
}
